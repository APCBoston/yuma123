module ietf-netconf {

  // the namespace for NETCONF XML definitions has not changed
  // this value is pre-determined by RFC 4741
  namespace "urn:ietf:params:xml:ns:netconf:base:1.0";

  prefix nc;
   
  import ietf-inet-types {
    prefix inet;
  }

  organization
    "IETF NETCONF (Network Configuration) Working Group";

  contact
    "WG Web:   <http://tools.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>

     WG Chair: Bert Wijnen
               <mailto:bertietf@bwijnen.net>

     WG Chair: Mehmet Ersue
               <mailto:mehmet.ersue@nsn.com>

     Editor:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Editor:   Juergen Schoenwaelder
               <mailto:j.schoenwaelder@jacobs-university.de>

     Editor:   Andy Bierman
               <mailto:andyb@iwl.com>";

  description 
    "NETCONF Protocol Data Types and RPC methods.

     Copyright (c) 2010 IETF Trust and the persons identified as
     the document authors.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.";
   // RFC Ed.: replace XXXX with actual RFC number and remove this note
  
  revision 2010-05-18 {
    description 
      "Initial revision";
    reference 
      "RFC XXXX: Network Configuration Protocol";
  }

  extension get-filter-element-attributes {
    description
      "If this extension is present within the
       an 'anyxml' statement named 'filter', which must be
       conceptually defined within the RPC input section
       for the 'get' and 'get-config' RPC operations,
       then the following unqualified XML attribute is
       supported within the 'filter' element, within
       a 'get' or 'get-config' protocol operation:

         type : optional attribute with allowed
                value strings 'subtree' and 'xpath'.
                If missing, the default value is 'subtree'.

       If the 'xpath' feature is supported, then the
       following unqualified XML attribute is
       also supported:

         select: optional attribute containing a
                 string representing an XPath expression.
                 The 'type' attribute must be equal to 'xpath'
                 if this attribute is present.";
  }

  // NETCONF capabilities defined as features
  feature writable-running {
    description 
      "NETCONF :writable-running capability;
       If the server advertises the :writable-running
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
    reference "RFC XXXX, #X#Writable-Running Capability#";
  }

  feature candidate {
    description 
      "NETCONF :candidate capability;
       If the server advertises the :candidate
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
    reference "RFC XXXX, #X#Candidate Configuration Capability#";
  }

  feature confirmed-commit {
    if-feature candidate;
    description 
      "NETCONF :confirmed-commit capability;
       If the server advertises the :confirmed-commit
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";

    reference "RFC XXXX, #X#Confirmed Commit Capability#";
  }
  
  feature rollback-on-error {
    description 
      "NETCONF :rollback-on-error capability;
       If the server advertises the :rollback-on-error
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
    reference "RFC XXXX, #X#Rollback on Error Capability#";
  }

  feature validate {
    description 
      "NETCONF :validate:1.0 capability;
       If the server advertises the :validate:1.0
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
    reference "RFC XXXX, #X#Validate Capability#";
  }
  
  feature validate-1.1 {
    if-feature validate;
    description 
      "NETCONF :validate:1.1 capability;
       If the server advertises the :validate:1.1
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
    reference "RFC XXXX, #X#Validate Capability#";
  }
  
  feature startup {
    description 
      "NETCONF :startup capability;
       If the server advertises the :startup
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
    reference "RFC XXXX, #X#Distinct Startup Capability#";
  }

  feature url {
    description 
      "NETCONF :url capability;
       If the server advertises the :url
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
    reference "RFC XXXX, #X#URL Capability#";
  }

  feature xpath {
    description 
      "NETCONF :xpath capability;
       If the server advertises the :xpath
       capability for a session, then this feature must
       also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
    reference "RFC XXXX, #X#XPath Capability#";
  }

  // NETCONF Simple Types

  typedef session-id-type {
    type uint32 {
      range "1..max"; 
    }
    description
      "NETCONF Session Id";
  }
  
  typedef session-id-or-zero-type {
    type uint32; 
    description 
      "NETCONF Session Id or Zero to indicate none";
  }
  
  // NETCONF Standard RPC Methods
  
  rpc get-config {
    description
      "Retrieve all or part of a specified configuration.";

    reference "RFC XXXX, #X#<get-config>#";
    
    input {
      container source {
        description
          "Particular configuration to retrieve.";

        choice config-source {
          mandatory true;
          
          leaf candidate {
            if-feature candidate;
            type empty;
          }
          leaf running {
            type empty;
          }
          leaf startup {
            if-feature startup;
            type empty;
            description
              "This is optional-to-implement on the server because
               not all servers will support filtering for this
               database.";
          }
        }
      }
      
      anyxml filter {
        description
          "Subtree or Xpath filter to use.";
        nc:get-filter-element-attributes;
      }
    }

    output {
      container data {
        presence 
          "An empty data container indicates that the
           request did not produce any results.";
        description 
          "Copy of the source database subset which matched
           the filter criteria (if any).";
      }
     }
  }

  rpc edit-config {
    description
      "The 'edit-config' operation loads all or part of a specified
       configuration to the specified target configuration.";

    reference "RFC XXXX, #X#<edit-config>#";

    input {
      container target {
        description
          "Particular configuration to edit.";

        choice config-target {
          mandatory true;
          
          leaf candidate {
            if-feature candidate;
            type empty;
          }
          leaf running {
            if-feature writable-running;
            type empty;
          }
        }
      }
      
      leaf default-operation {
        type enumeration { 
          enum merge;
          enum replace;
          enum none;
        }
        default "merge";
      }
      
      leaf test-option {
        if-feature validate;
        type enumeration {
          enum test-then-set;
          enum set;
          enum test-only {
            description
              "This value can only be used if the 'validate-1.1' 
               feature is supported.";
          }
        }
      }
      
      leaf error-option {
        type enumeration { 
          enum stop-on-error;
          enum continue-on-error;
          enum rollback-on-error {
            description
              "This value can only be used if the 'rollback-on-error'
               feature is supported.";
          }
        }
        default "stop-on-error";
      }

      choice edit-content {
        mandatory true;
        anyxml config {
          description 
            "Inline Config content: 'config' element.
             This is not full 'anyxml' because the <config>
             element cannot directly contain a text node.";
        }
        leaf url {
          if-feature url;
          type inet:uri;
        }
      }
    }
  }

  rpc copy-config {
    description
      "Create or replace an entire configuration datastore with the
       contents of another complete configuration datastore.";

    reference "RFC XXXX, #X#<copy-config>#";

    input {
      container target {
        description
          "Particular configuration to copy to.";

        choice config-target {
          mandatory true;
          
          leaf candidate {
            if-feature candidate;
            type empty;
          }
          leaf running {
            if-feature writable-running;
            type empty;
            description
              "This is optional-to-implement on the server.";
          }
          leaf startup {
            if-feature startup;
            type empty;
          }
          leaf url {
            if-feature url;
            type inet:uri;
          }
        }
      }
      
      container source {
        description
          "Particular configuration to copy from.";

        choice config-source {
          mandatory true;
          
          leaf candidate {
            if-feature candidate;
            type empty;
          }
          leaf running {
            type empty;
          }
          leaf startup {
            if-feature startup;
            type empty;
          }
          leaf url {
            if-feature url;
            type inet:uri;
          }
          anyxml config {
            description 
              "Inline Config content: 'config' element.
               Represents an entire 'stand-alone' 
               configuration database, not a subset of 
               the running database.";
          }
        }
      }
    }
  }
  
  rpc delete-config {
    description
      "Delete a configuration datastore.";

    reference "RFC XXXX, #X#<delete-config>#";
    
    input {
      container target {
        description
          "Particular configuration to delete.";
        
        choice config-target {
          mandatory true;
          
          leaf startup {
            if-feature startup;
            type empty;
          }
          leaf url {
            if-feature url;
            type inet:uri;
          }
        }
      }
    }
  }
  
  rpc lock {
    description
      "The lock operation allows the client to lock the configuration
       system of a device.";

    reference "RFC XXXX, #X#<lock>#";

    input {
      container target {
        description
          "Particular configuration to lock";

        choice config-target {
          mandatory true;
          
          leaf candidate {
            if-feature candidate;
            type empty;
          }
          leaf running {
            type empty;
          }
          leaf startup {
            if-feature startup;
            type empty;
          }
        }
      }
    }
  }
  
  rpc unlock {
    description
      "The unlock operation is used to release a configuration lock,
       previously obtained with the 'lock' operation.";

    reference "RFC XXXX, #X#<unlock>#";
    
    input {
      container target {
        description
          "Particular configuration to unlock.";

        choice config-target {
          mandatory true;
          
          leaf candidate {
            if-feature candidate;
            type empty;
          }
          leaf running {
            type empty;
          }
          leaf startup {
            if-feature startup;
            type empty;
          }
        }
      }
    }
  }
  
  rpc get {
    description
      "Retrieve running configuration and device state information.";

    reference "RFC XXXX, #X#<get>#";

    input {
      anyxml filter {
        description
          "This parameter specifies the portion of the system
           configuration and state data to retrieve.";
        nc:get-filter-element-attributes;
      }
    }

    output {
      container data {
        presence 
          "An empty data container indicates that the filter
           request did not match any results.";
        description 
          "Copy of the 'running' database subset and/or state 
           data which matched the filter criteria (if any).";
      }
    }
  }
  
  rpc close-session {
    description
      "Request graceful termination of a NETCONF session.";
    
    reference "RFC XXXX, #X#<close-session>#";
  }

  rpc kill-session {
    description
      "Force the termination of a NETCONF session.";
    
    reference "RFC XXXX, #X#<kill-session>#";
    
    input {
      leaf session-id {
        type session-id-type;
        mandatory true;
        description
          "Particular session to kill.";
      }
    }
  }

  rpc commit {
    if-feature candidate;

    description
      "Commit the candidate configuration as the device's new
       current configuration";
    
    reference "RFC XXXX, #X#<commit>#";

    input {
      leaf confirmed {
        if-feature confirmed-commit;
        type empty;
        reference "RFC XXXX, #X#<commit>#";
      }

      leaf confirm-timeout {
        if-feature confirmed-commit;
        type uint32 { 
          range "1..max";
        }
        units "seconds";
        default "600";   // 10 minutes
        reference "RFC XXXX, #X#<commit>#";
      }
    }
  }

  rpc discard-changes {
    if-feature candidate;

    description
      "Revert the candidate configuration to the current 
       running configuration.";

    reference "RFC XXXX, #X#<discard-changes>#";
  }

  rpc validate {
    if-feature validate;

    description
      "Validates the contents of the specified configuration.";

    reference "RFC XXXX, #X#<validate>#";

    input {
      container source {
        description
          "Particular configuration to validate.";

        choice config-source {
          mandatory true;
          
          leaf candidate {
            if-feature candidate;
            type empty;
          }
          leaf running {
            type empty;
          }
          leaf startup {
            if-feature startup;
            type empty;
          }
          leaf url {
            if-feature url;
            type inet:uri;
          }
          anyxml config {
            description 
              "Inline Config content: 'config' element.
               Represents an entire 'stand-alone' 
               configuration database, not a subset of 
               the running database.";
          }
        }
      }
    }
  }
  
}
