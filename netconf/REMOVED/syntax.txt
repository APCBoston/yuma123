NCX Language Documentation
Copyright "(C) 2006, Andy Bierman."

---------------------------

NCX Framework Notes

   - NCX modules


  A NCX Module has the following format:

   ncx-module moduleName {
     header { ... }
     imports { ... }?
     definitions { ... }?
   }

   A Definition can be one of:

     type        - Type definition
     parmset     - Parameter Set definitions
     rpc         - RPC Method definitions
     notif       - Notification definitions


 Everything except the header is optional, although a module
 without any of the other sections is not very useful, except
 as a placeholder.


 Everything except the header is optional, although a module
 without any of the other sections is not very useful, except
 as a placeholder.

 NCX Built-in Data Types
 -----------------------

    any                          # container for any 1 node of any type
    anyapp                       # container for any number of app. nodes
    ename                        # element name, e.g. { running startup }
    enum <enum-spec>             # like C enum or SMI enumerated INTEGER
    flag                         # like <ok>, resolves to enum (boolean)
    int [range]                  # 32 bit signed integer
    uint [range]                 # 32 bit unsigned integer
    long [range]                 # 64 bit signed integer
    ulong [range]                # 64 bit unsigned integer
    float [range]                # 32 bit float (or string if !HAS_FLOAT)
    double [range]               # 64 bit double float (if HAS_FLOAT)
    string <string-spec>         # str with range, val set, pattern
    ustring [pattern]            # octet str with range, vset, pattern
    list [simpleType]            # XSD list of 0 to 65535 simpleTypes
    xlist [pattern, pattern*]    # list of 0 to 65535 strings
    struct <struct-spec>         # container of arbitrary members
    choice <choice-spec>         # choice of 1 or more (blocks of) members
    table <table-spec>           # table with SMI-like simple or struct index
    container <any-type-name>    # container-ized object

 NCX Names
 ---------

 - All fields used as identifiers or versions in some fashion 
   within the NCX syntax are ASCII strings from 1 to 1023 characters
   (This limit refers to s simple identifier, not any of
    the complex identifier forms.)
 - All names are case-sensitive
 - The first character must be a letter ('a'..'z' or 'A'..'Z')
 - The rest of the characters in an NCX name can be any of:
    - letter ('a'..'z' or 'A'..'Z')
    - number ('0'..'9')
    - underscore ('_')
    - dash ('-')

 NCX Strings
 -----------

 - All string fields are from 0 to 4,294,967,295 bytes in length
 - The underlying data type is signed char
 - A string value is either 'unquoted' or 'quoted'.
 - Sometimes either form is allowed, otherwise a quoted-string
   may be required
 - A quoted string (double quote char -- string -- double quote char)
   is allowed to contain whitespace, and any NCX tokens inside the
   string (even comments) will be ignored.
 - The character entity (&quot;) is used to allow a double quote char 
   inside a string
   - An unquoted string begins with a char and ends on the first
     NCX token or whitespace
 - TBD: C String concatenation; 
   e.g.; <foo>    "long "
               string</foo>  --> "long string"
 - Strings can be constrained with size ranges, value sets,
   XSD patterns and C regular expressions



 NCX UStrings (Hex Parsing still TBD!)
 ------------

 - All ustring fields are from 0 to 2^32-1 bytes in length
 - The underlying data type is unsigned char
 - C Hex strings (e.g., 0xfeff458dea) are allowed in instances
   of ustrings. 
   - There must be an integral number of bytes represented
   - The on-the-wire length and encoding is irrelevant. 
   - The NCX engine will convert the C-hex to binary
   - Length clauses for ustrings refer to the binary length,
     not the on-the-wire length;
   - Example:
       syntax: ustring ipv4addr (4);
       valid encoding:   "0xc0a80001"       # 192.168.0.1
   - To encode as ASCII ("192.168.0.1") use the string base type
   - TBD: Support BinaryHex and Base64 encoded strings as ustring
     instances, in addition to C-hex
 - Ustrings can be constrained with size ranges, value sets,
   XSD patterns and C regular expressions

 NCX Lists
 ---------

 - A list is an ordered sequence of 0 .. 2^32-1 strings
 - list base type is specified by the user
 - xlist base type is string, and patterns + valsets control the parsing
 - lists and xlists can be constrained with size ranges, value sets, and
   XSD patterns. This is similar to the mechanisms for strings, except 
   multiple patterns or expressions can be specified, corresponding to 
   the ordinal position of the string.

  Example:

    <foo> is a list of 0 to 3 integers:

    list foo (0..3) type = int;

       <foo>27 44 -23</foo>

    xlist favorite-colors = { { red, blue, green}+ {house car}};

       <foo>green red car</foo>


 NCX Numbers
 -----------

  - There are three forms of number input
    - Decimal number: 
       begins with optional + or - 
       contains one or more decimal digits 
    - Hex number
       begins with the sequence '0x' or '0X'
       contains one or more hex or decimal digits
       There should be an integral number of bytes represented.
       If not, a leading 0 nibble will be added to unsigned
       numbers, and signed numbers will be sign-extended 
       (i.e., prefixed with 0x0 or 0xf )
    - Real number
       begins with optional + or -
       contains one or more decimal digits, followed by
       an optional decimal point, followed by one or more digits
       TBD: Full IEEE Floating point support


 NCX Modules vs. Application Parmsets
 ------------------------------------

    Modules are simply containers of definitions. 

    The conceptual data model is a hierarchy of applications. 
    Each application contains parameter sets and notifications.
 
    The special data type 'anyapp' is used to repeat the
    hierarchy, and support nested, instanced parmsets.
    (e.g., <config> is 'anyapp', the hook inside <interface>
    to support interface-specific application data.)

    Each module specifies one owner and application name,
    which has one namespaces associated with it.

    'N' Namespaces can be mapped to a single owner name.

    The ['owner', 'application'] tuple, not the module, is the 
    real data model container.  

    All owner-specific definitions (e.g., type, parmset,
    rpc, notif) are considered be be in the same naming scope 
    if they share the same owner name.  
    (Not owner, application name!!!)
    This allows parmsets to be used in multiple applications.

 Header
 ------

  header {
   [description   "Optional Module Description";]
    version       versionString;
    owner         ownerName;
    application   appName;
   [copyright     "copyright string";]
   [contact-info  "contact info string";]
   [namespace     "OverrideDefaultNamespaceID";]
   [last-update   dateTime;]
   [revision-history { version-string description;+ }]
  }

  name: module name.  
        This is the value used is imports.module field

  version: Module version; no specified format; it is up
        to the module designer to establish a version pattern

  owner: NCX application owner; this could be a vendor name
         or the reserved owner name 'ncx', or some other
         administratively unique string.  If <namespace>
         is omitted, then a default namespace using the
         owner field will be constructed instead.

  application: name of the application that this module applies.
         This is only relevant if actual data model objects
         are included (e.g., parmset) in the module.
         This string will be used as the application container
         for the elements defined in NCX data models. 

  copyright: Optional copyright text
 
  contact-info: Optional author and/or owner contact info

  description: Optional description of module contents

  namespace: Optional namespace ID; If this parameter is
         present then the data model namespace will be set
         to this field instead of the default constructed string.
         Do not include the 'xmlns' attribute or any prefix
         values, just the namespace URI value.

 last-update: date Time string representing when the data model
        was last revised.

 revision-history: container with zero or more revision history comments.
        Each clause must identify the version string of the revision it 
        describes. Entries should appear in descending order, so the 
        newer revisions are listed first.

 Imports
 -------

  imports {
    import {
      module ModuleName [ { Item1 Item2;]
    }*
  }

 Import Resolution Processing
 -----------------------------
 
  - Duplicate <import> entries are not errors (what about warnings?)
  - If the items list is present, then only the listed
    items will be available from that module. Otherwise,
    the <import> clause simply declares module search order.
  - The built-in types cannot be imported or redefined.
  - Definition Resolution Processing Order
    1) Specific module if "module::identifier" form used in definition
         if not:
    1) Current module being parsed
    2) Search the importQ in order for the first <items> list
       that contains the definition name
    3) Search the importQ in order, checking all modules
       without an items list, for the first one that contains 
       the definition name

  - Each parameter set definition (PSD) contains one or more
    parameter definitions.

  - Each PSD is keyed by 2 strings 

    - ( owner-name, parmset-name )


  There are two uses for parameter set definitions:

   - rpc parameter set
     The IN or OUT parameter set for an Remote Procedure Call

     The application-name key is set to the rpc-method name.
     The optional version attribute is in the rpc-method name

   - data parameter set

     A data model parameter set for a particular application

     The parmset-name is the top-level node (at layer N)

     A data model parmset cannot be directly contained within 
     an element of type 'anyapp'.  An XML node identifying
     the [owner, application name] tuple must be used as a
     container for 0 to N parmsets for the same application.


  Values allowed in the <parm> type field

  - Typename

    A type name can be specified, which may be declared in this
    module or an imported module.


   Special Types allowed in the <syntax> clause

  - 'any'

     This special flag indicates the parameter is the root
     placeholder for 1 (unspecified) node of any type.
     
  - 'anyapp'

     This special flag indicates the parameter is the root
     placeholder for N (unspecified) application nodes,
     Parmsets can be placed anywhere in a data structure, and
     they are encoded in XML instance documents in the following
     manner:
         - owner of the PS encoded in the NS of the top level element
         - application name is the top level element name
         - parmset name encoded in a child element
          
  - 'flag'

     This special data type is used to support flag type parameters
     such as the <ok> flag in NETCONF. Also, many CMDLINE params
     are declared to be TRUE if present and FALSE is not present.
     This data type resolves to 'enum boolean' in Canonical Config Format.
     All data models are supposed to be static representations of
     configuration parameters, but the flag is message dependent.

     By design, NCX data models are defined independent of any
     particular NETCONF or other RPC method that uses the data model.
     The max-access clause (and some algorithms) determine what
     protocol operation can be done to each bit of data. 
     Use of the flag data type tells the parser that this 
     is a boolean that needs special instance document handling.
     
  - 'ename'

     This data type represents the name of an element.
     There are some parameters in NETCONF that are encoded
     as empty elements, such that the only real semantics
     that needs to be retained is which element name is present.

     E.g.,
        <target>
           <running/>
        </target>

      The 'target' parameter can be declared as type 'ename'
      and the parser will parse the elements and namespaces,
      and save the element name as a 'ustring'.

  - 'enum'

     This data type is specified in the NCX module in a manner
     similar to C enum syntax.  Enums begin at zero by default.
     The base type of an enum is 'int', and the enumerated values
     can be any valid 32 bit integer value.  

     In XML output, enums are rendered as SMI enums:

     E.g.,

     Enum Definition:

       enum foo = { start=1 next last=40 };

     3 Forms of Acceptable Output:

        Form 1  2   3
        ---------------------
        start   1   start(1)
        next    2   next(2)
        last    40  last(40)

     By default, Canonical Form is Form 3.

   - 'container'
 
    This special type provides a simple way to create a 
    containerized table of a specific struct type.
    This is kind of a hack to avoid an extra layer of
    XML in the data model, and still define the contents
    of a table row (struct) independently of table indexing.
    It is bad practice to define the row contents inline
    within the table, if the table may be indexed in
    multiple ways, or the row contents may need to be
    reused in the future.

    Syntax for 'container' is like 'table', except a scoped-local
    index (or * allindex flag) must be used, and only one
    child node is allowed, which can have any data type.

   E.g.

    footable:  type FooTab;

    syntax {
      struct FooRow {
        int id;
        ulong counter;
      }
    }

    syntax {
      container fooTab [foo.id] {
        FooRow foo;
      }
    }

    <footable>
      <foo>
        <id>2</id>
        <counter>77</counter>
      </foo>
      <foo>
        <id>9</id>
        <counter>8234</counter>
      </foo>
    </footable>

  Maxrows:
  -------

  Table and container declarations may include a clause
  to indicate the maximum number of rows (siblings) that 
  are allowed to be created in a table or container.
    
  syntax {
     # create 0 to 60 rows of this data type
     table [name] (60) {
        string foo (1..20);
        int bar;
     }
   }

              
  Data Types Allowed In Index Clauses
  -----------------------------------

  When the parser encounters the first token string in an
  index clause component (i.e., just after left bracket or comma)
  it tries to resolve the identifier in the following manner
  and in this order:

  A) - any of the following builtin types:
       (called an inline index definition)
       - ename
       - enum
       - int
       - long
       - uint
       - ulong
       - float
       - double
       - string
       - ustring

  B) - any named simple type which resolves to a base type in (A)
       (called a named index definition)

  C) - any named struct containing only members which conform to (A), (B),
       or (C) (called a named index definition)

  D) - any name of a top level member in the table being defined
       (called a local index type)

  E) If the string is a scoped-string (e.g., foo.bar.baz) then
     the current module and import path is searched for this
     as any named member of any exported symbol. In this example
     the module and then import path would look for the symbol 'foo'
     and if it contained a double-nested node called 'bar.baz',
     then the semantics for this node are assumed, and the syntax for 
     this object are used to validate the index.  A member called
     'foo.bar.baz' will be added to the top level of the table entry.

     Note that if a module qualified form is encountered, the module
     qualifer will not be present in the instance document as this
     is not needed and conflicts with XML namespace prefixes.

  F) If the string or scoped-string is a not found externally, it is 
     assumed to be a local index (or local scoped index) and is a
     forward reference to a member name that follows in the table
     definition.  This is validated after the table members are
     parsed, and if there is no match then an error is generated.

     If the unresolved token is a module-qualified identifier,
     then an error is returned, since this cannot be the name
     of a local member of the table.

Appinfo Support
---------------

   The appinfo clause may be present in the following constructs:
     - module header
     - type definition
     - parm definition
     - parmset definition
     - notification definition
     - rpc definition

   appinfo {
      <appinfo-clause>*
   }

   appinfo-clause has a simple form

       name [string];

   E.g.,   foo "fred";  
           mergetype first;
           no-duplicates;

     <xs:appinfo>
        <ncx:foo>fred</ncx:foo>
        <ncx:mergetype>first</ncx:mergetype>
        <ncx:duplicates>no</ncx:duplicates>
     </xs:appinfo>

  Appinfo is also available internally to agent callback functions.

  Initial Set of NCX APPINFO Extensions

  * display-hint <string> ;    

   Purpose:   SNMP application display format
              Not used internally --- passed to XSD generator
   Parms:

      string: follows SMIv2 DISPLAY-HINT format

      Default:   none
    

  * status
      == (current, deprecated, obsolete)

   Purpose:   definition is deprecated and may be deleted in the future
              Not used internally --- passed to XSD generator            

   Parms:     none


  * replaced-by <string> ;

   Purpose:   deprecated redirect clause
              Used only is status is 'deprecated', 

   Parms:

      string: expression string or description string

      Default:   none


  * no-duplicates ;

   Purpose: Disallow duplicates in list or unnamed arrays
   Parms:   none

Note: When determining if duplicates are allowed, the NCX agent
      will check the typedef chain to find the first instance 
      of 'duplicates' or 'no-duplicates' in the appinfo 

  * merge-type <string> ;

   Purpose: Control the merge behavior for lists and unnamed arrays

   Parms:
     string: 'first'    # merge first
              'last'    # merge last
              'sort'    # sorted by some means

     Default: 'last'



NCX Extensions to the NETCONF Protocol
---------------------------------------

 * test-only enumeration

   edit-config, test-option parameter:

   -- NCX agent accepts the enumeration 'test-only' to perform
      a validatation of an inline <config> fragment against
      the target config, and exit before the 'apply' phase

 * pos attribute

   pos = "positiveInteger"  

   E.g., pos="3"

   edit-config, <config> parameter

   Indicates the position 'N', where instances are numbered 1 .. N

   For unnamed arrays that use sorting as the merge action,
   the NCX agent will look for this parameter, and if present,
   the merge will be done such that the merged node will be
   at the Nth position.

NCX Module Syntax
------------------

# Basic Encoding Rules
#
# A comment is a hash mark to end-of-line, and is treated
# syntactically as a whitespace character.
# 
# Module and sub-sections follow the form
#   <construct> construct-name "{" 
#      <construct-contents>
#   "}"
#
# A simple clause ends in a semi-colon;
#
# Basic Rule:
#   If it starts with a left brace, it ends with a right brace
#   and not a semi-colon.
#
# Exceptions are:
#   - Index clause components are comma-terminated (except last)
#   - Notification objects components are comma-terminated (except last)
#
# These exceptions exist to align with current SMI and C conventions 
# for these clauses.  They can contain inline or named type
# declarations, object names, module-qualified names,
# or scoped object names.
#
# Whitespace is not significant unless specified as such.
# All whitespace within quoted strings is preserved.
# Unquoted strings end on the first whitespace, EOLN, or NCX token.
#
# User named types are allowed anywhere a base type name can be used.
# User named types must be defined using base types. They 
# cannot be defined using other named types.  This limitation
# simplifies module maintenance and is consistent with SMIv2.
#
# Metadata is translated to XML attributes in NETCONF PDUs.
# Types used in this clause are limited to a subset of the
# base types.  If a named type is used in a metadata item
# declaration, then any metadata defined in that named type
# is ignored (for metadata usage only).
#
# Unnamed instances are specified with the ABNF constructs
# for this purpose:
#  no qualifier:  1 instance
#  ? qualifier: 0-1 instances
#  + qualifier: 1 or more instances
#  * qualifier: 0 or more instances
#
# Named instances are specified using the 'table' construct.
# The [index] clause specifies the instance identifiers
# for the contents of the table.  Index components can
# be inline or named types, identifiers of type, parmset,
# or object constructs, or their child member names.
#
# The special index clause [*] indicates all the table
# members are part of the index (no duplicates allowed).
#
# The special index clause [] indicates none the table
# members are part of the index (duplicates allowed).
# This unnamed form of a table is equivalent to declaring
# a struct type with the '*' qualifier (0 or more instances).
#
# Scoped names are specified as in C, using field names
# separated by the dot char:  foo.bar.baz
# 
# Items listed explicitly or implicitly in the imports section
# can be used in the module as if they are defined there.
# Multiple definitions with the same name can be used if
# one of the module-qualified forms is used
#    simple form: fooModule:bar
#    scoped form: fooModule:bar.baz.bax
#
# The module name 'fooModule' must be listed in the imports section.
# If a module-qualified form is used, then the normal imports 
# processing order is ignored and only the specified module
# will be checked.
#
# Built-in Type Names
#
# any                  Any type
# anyapp               Any parmset
# ename                element name string
# enum                 enumerated integer
# flag                 boolean flag element 
# int                  32 bit signed integer
# uint                 32 bit unsigned integer
# long                 64 bit signed integer
# ulong                64 bit unsigned integer
# string               64k signed char string
# ustring              64k unsigned char string
# list                 list of 'simpleType'
# xlist                extended list of strings
# struct               container of anything
# choice               choose 1 of N of anything
# table                named or unnamed instances of anything
# container             containerized table of 1 named struct type
#
# These type names cannot be re-defined in any way.
# The base types are not associated with any owner
# or module, so they cannot be used in a 
# module-qualified identifier variant. NO 'fooModule:int'
#
# The header.owner, and header.namespace fields
# are very important in parmset instance documents.  
#
# The owner is used to construct the namespace of 
# the top-level element of parmset, unless the 
# header.namespace field is present to override the
# namespace default.  
#

# SYNTAX EXAMPLE (With Instance Qualifier Markup)
ncx-module ModuleName {
  header {
    description "Optional Module Description";?
    version ModuleVersionString;
    owner ModuleOwnerName;
    copyright "Copyright String";?
    contact-info "Contact Info";?
    namespace OverrideDefaultNamespaceUri;?
  }
  imports {
    # 2 forms of the import clause
    import ModuleName { ItemName* };*
    import ModuleName;*
  }?
  definitions {
    # no defined order but no forward references allowed

    # Types are abstract data structure descriptors
    # associated with the owner, not the namespace.
    # They have no access control attributes.
    # All types imported into a module can be used
    # in the same namespace or same owner,
    # within the module and in XML instance documents.

    type TypeName {
      description "descriptionString";?
      condition   "conditionString";?
      syntax  {
        # elements defined here
        # all data types allowed in elements
        #  -- see ncx-syntax-contents ABNF -- 
      }
      metadata {   
        # attributes are called metadata
        # a subset of inline data type decls are allowed in metadata
        # named types resolving to this subset are also allowed
        # Named types which resolve to structs containing 
        # (structs containing) only these declarations are also allowed.
        # Such structs will be encoded in XML instance documents
        # using the data's scoped name for the attribute name (foo.bar.baz)
        #  -- see ncx-metadata ABNF --       
      }?
      default "value-string";?
      max-access "access-string";?
      data-class config;      # config or state; may be redundant 
      appinfo {
        # name value pairs are all stored as strings
        name [value];*
      }?
    }*

    # Parameter Set Definitions contain writable parameters
    # They can also contain read-only and notify-only parameters
    # but this is not encouraged.
    # 
    # Parmsets are associated with an owner, application tuple
    # If the application field is missing then the default 
    # application specified in the header is used

    parmset PsdName {
      description "Optional PSD Description";?
      condition "Condition Expression";?
      order OrderType;?       # strict or loose ordering, def: loose
      type ParmsetType;?      # rpc or data parmset, def: data
      data-class config;      # config or state; if type==data
      appinfo {
        # name value pairs are all stored as strings
        name [value];*
      }?

      parms {
        parm ParameterName {
          description "Description Clause";?
          condition "Condition Expression";?  # parm supported or not
          type ParameterTypeName;
          max-access AllowedAccessClause;?
          usage UsageType;?   # mandatory, optional, or conditional
          data-class config;  # config or state; may be redundant 
          appinfo {
             # name value pairs are all stored as strings
             name [value];*
          }?

        # choices are optional, nested choices are not allowed
        # 3 choices, choose 1 of parm: p1, p2, p3 & p4
        choice {
          parm p1 ...

          parm p2 ...

          # nested brackets are not allowed
         [  parm p3 ...

            parm p4 ... ]
        }
      }  # end parms section

        
    }*   # end parmset

    # User-defined RPC method definition
    # The input parameter set is optional
    # The output data is mandatory and can 
    # contain a type or parmset name
    #

    rpc RpcMethodName {
      description "Description Clause";?
      condition "Condition Expression";?
      rpc-type RpcMethodType;
      input InputPsdName;?
      output OutputDataName;
      appinfo {
        # name value pairs are all stored as strings
        name [value];*
      }?
    }*


    # NCX Notification definition
    # The notif-data output data is optional
    #

    notif NotificationName {
      description "Description Clause";?
      condition "Condition Expression";?
      notif-class NotificationClass;
      notif-type  NotificationtType;
      notif-data {
        # objects can be any identifier type
        # for any type, parmset, parmset.parm, 
        #
        # -- see notif-objects ABNF
      }?   # 0 or 1 objects section
    }*     # 0 or more notif sections
  }?       # 0 or 1 definitions section
}          # 1 ncx-module container



-------------------------------------------------------------------------
# NCX SYNTAX ABNF
# Not strict ABNF yet
# The quoted strings are supposed to be case-insensitive
# but in NCX they are always case-sensitive.
# Start symbol is 'ncx-module'

 ncx-module = ncx-module wspace name "{"
              ncx-header [ncx-imports] [ncx-definitions] "}"

 ncx-header =  "header" "{" header-contents "}"

 header-contents = [ncx-descr] hdr-version hdr-owner 
                   [hdr-copyright] [hdr-contact] [hdr-ns]
		   [hdr-last-update] [hdr-rev-history] [ncx-appinfo]
 
 hdr-version = "version" wspace ver-string ";"

 ver-string = string      # limited in size to  (1..63) chars

 hdr-owner = "owner" wspace name ";"

 hdr-copyright = "copyright" wspace quoted-string ";"

 hdr-contact = "contact-info" wspace quoted-string ";"   

 ncx-descr = "description" wspace quoted-string ";"

 hdr-ns = "namespace" wspace quoted-string ";"

 hdr-last-update = "last-update" wspace unquoted-string ";"

 hdr-rev-history = "revision-history" "{" 0*(hdr-revhist-entry) "}"

 hdr-revhist-entry = unquoted-string wspace quoted-string ";"

 ncx-appinfo = "appinfo" "{" 0*(ncx-appinfo-entry) "}"

 ncx-appinfo-entry = unquoted-string [wspace string] ";"

 ncx-imports = "imports" "{" 0*(ncx-import) "}"

 ncx-import = "import" wspace name [import-items] ";" 

 import-items = "{" 0*(name) "}"

 ncx-definitions = "definitions" "{" 0*(ncx-definition) "}"

 ncx-definition = ncx-type / ncx-ps / ncx-rpc / ncx-notif

 ncx-type = "type" name "{" 
                 [ncx-descr] 
                 [ncx-condition] 
                  ncx-syntax 
                 [ncx-metadata] 
                 [ncx-default] 
                 [ncx-max-access]
                 [ncx-data-class]
                 [ncx-appinfo]
             "}"

 ncx-syntax = "syntax" "{" ncx-syntax-contents "}"

 ncx-metadata = "metadata" "{" 0*(ncx-metadata-decl) "}"

 ncx-metadata-decl = metatype-decl ["?"] ";"

 ncx-parmset = "parmset" wspace name "{" ncx-ps-contents "}"
 
 ncx-ps-contents = [ncx-descr] 
                   [ncx-condition] 
                   [ncx-order] 
                   [ncx-appinfo]
                   "parms" "{" 1*(ncx-pterm) "}"

 ncx-condition = "condition" wspace quoted-string ";"

 ncx-order = "order" wspace ncx-order-val ";"
 
 ncx-order-val = "loose" / "strict" 

 ncx-pterm = ncx-pchoice / ncx-parm

 # nested choices are not allowed but eventually at least 
 # one ncx-parm must be specified

 ncx-pchoice = "choice" "{" 1*(ncx-pchoice-member) "}"

 ncx-pchoice-member = ncx-pchoice-block / ncx-parm

 ncx-pchoice-block = "[" 1*(ncx-parm) "]"
 
 ncx-parm = "parm" name "{" ncx-parm-contents "}"

 ncx-parm-contents = [ncx-descr] 
                     [ncx-condition] 
                      ncx-typname 
                     [ncx-max-access]
		     [ncx-ps-usage]
                     [ncx-data-class] 
		     [ncx-appinfo]


### [ncx-ps-usage]

 ncx-data-class = "class" wspace ncx-data-class-type ";"

 ncx-data-class-type = "config" / "state"

 ncx-typname = "type" wspace mname ";"

 # if the default value has embedded NCX tokens then it must
 # be a quoted-string, otherwise it will be parsed as multiple
 # tokens instead of 1 string
 ncx-default = "default" wspace quoted-string ";"

### ncx-ps-usage = "usage" wspace ncx-ps-usage-val ";"

### ncx-ps-usage-val = "mandatory" / "optional" / "conditional"

 ncx-max-access = "max-access" wspace ncx-max-access-val ";"

 ncx-max-access-val = "read-only" / "read-write" / "read-create"

 ncx-rpc = "rpc" wspace name "{" ncx-rpc-contents "}"

 ncx-rpc-contents = [ncx-descr] [ncx-condition]
                    ncx-rpc-type [ncx-input] [ncx-output]

 ncx-rpc-type = "rpc-type" wspace ncx-rpc-type-val ";"

 ncx-rpc-type-val = "other" / "config" / "exec" / 
                    "monitor" / "debug"

 ncx-input = "input" wspace mname ";"

 ncx-output = "output" wspace mname ";"

 ncx-notif = "notif" wspace name "{" ncx-notif-contents "}"

 ncx-notif-contents = [ncx-descr] [ncx-condition]
                     ncx-notif-class ncx-notif-type [ncx-notif-data]

 ncx-notif-class = "notif-class" wspace string ";"

 ncx-notif-type = "notif-type" wspace string ";"

 ncx-notif-data = "notif-data" "{" [ncx-notif-objs] "}" 

 ncx-notif-objs = ncx-notif-obj 0*("," ncx-notif-obj)

 ncx-notif-obj = mname / scoped-name

 # <syntax> clause ABNF

 ncx-syntax-contents = simple-type / complex-type / full-named-type
 
 simple-type = sim-type [inst-qual] ";"

 sim-type = any-type / anyapp-type / flag-type
               / num-type / ename-type / union-type /
               / enum-type / string-type / list-type / xlist-type

 any-type = "any"

 anyapp-type = "anyapp"

 flag-type = "flag"

 num-type = ord-type / real-type

 ord-type = ord-type-val [ord-range]

 ord-type-val = "int" / "uint" / "long" / "ulong"

 real-type = real-type-val [real-range]

 real-type-val = "float" / "double"

 range = "(" range-spec 0*("|" range-spec) ")"

 range-spec = number / number-pair

 number-pair = number-pair-1 / number-pair-2 

 number-pair-1 = [number] ".." number 

 number-pair-2 = number ".." [number]

 ord-range = "(" ord-range-spec 0*("|" ord-range-spec) ")"

 ord-range-spec = ord-num / ord-num-pair

 ord-num-pair = ord-num-pair-1 / ord-num-pair-2

 ord-num-pair-1 = [ord-num] ".." ord-num

 ord-num-pair-2 = ord-num ".." [ord-num]

 uint-range = "(" uint-range-spec 0*("|" uint-range-spec) ")"

 uint-range-spec = uint-num / uint-num-pair 

 uint-num-pair = uint-num-pair-1 / uint-num-pair-2

 uint-num-pair-1 = [uint-num] ".." uint-num

 uint-num-pair-2 = uint-num ".." [uint-num]

 real-range = "(" real-range-spec 0*("|" real-range-spec) ")"

 real-range-spec = real-num / real-num-pair

 real-num-pair = real-num-pair-1 / real-num-pair-2

 real-num-pair-1 = [real-num] ".." real-num

 real-num-pair-2 = real-num ".." [real-num]

 ename-type = "ename" [string-set]

 string-restrictions = string-restriction / string-set

 string-restriction = [uint-range] [string-val-restriction]

 string-val-restriction = string-pattern 

 enum-type = "enum" "=" enum-spec

 enum-spec = "{" 1*(enum-elem) "}"

 enum-elem = name ["=" int-num] 

 string-type = string-type-val [string-restrictions]

 string-set = "=" "{" 1*(string) "}"

 string = quoted-string / unquoted-string

 quoted-string = """ whitespace-allowed-string """

 unquoted-string = whitespace-not-allowed-string

 string-pattern = "pattern" "=" <quoted-string>

 union-type = "union" union-body

 union-body = "{" typename 1*(wspace typename) "}"

 list-type = "list" list-body

 list-body = [uint-range] wspace "{" unquoted-string "}"

 xlist-type = "xlist" [xlist-restrictions]

 xlist-restrictions = xlist-restriction / xlist-set

 xlist-restriction = [uint-range] [xlist-val-restriction]

 xlist-val-restriction = xlist-pattern 

 xlist-set = "{" 0*(xlist) "}"

 xlist = "{" 0*(string) "}" [inst-qual]

 xlist-pattern = wspace "pattern" "=" xlist-set

 complex-type = complex-type-val  [inst-qual]

 complex-type-val = struct-type / choice-type 
          / table-type / container-type

 struct-type =  "struct" "{" 1*(c-member) "}"

 choice-type =  "choice" "{" 1*(choice-member)  "}"

 choice-member = choice-block / c-member
 
 choice-block = "[" 1*(c-member) "]"

 table-type = "table" index-decl "{" 1*(c-member) "}"

 # container data type
 #   index-decl: only scoped-local index form allowed here
 #        mname: name of a struct data type
 #         name: name of the struct (row)
 
 container-type = "container" index-decl 
       "{" mname wspace name ";" "}"

 # typename member-name [new range, etc.]
 named-type =  name wspace name [named-type-ext]  

 full-named-type =  named-type [named-type-ext] ";"   

 named-type-ext = named-num-ext / named-str-ext / named-enum-ext

 named-ext-type = "=" / "+=" 

 named-num-ext = named-ext-type range

 named-str-ext = named-ext-type string-restrictions

 named-enum-ext = named-ext-type enum-spec

 index-decl = "[" [index-decl-val] "]"

 index-decl-val = index-components / "*"

 index-components = index-component 0*("," index-component)

 index-component = c-index-type> / scoped-name 
                  / name / named-type

 # check this!!
 c-index-type = c-num-type / c-enum-type / c-string-type 


 # Each name component (between the dots) is
 # limited in size to (1..63) + NCX name rules
 # No space allowed between the module qualifier and the string
 # limited in size (1..63) + NCX name rules
 # No space allowed between the module name and the colon char

 mod-qual = unquoted-string ":"

 name        = unquoted-string

 mname       = [mod-qual] unquoted-string    # IfMib:IfTable

 scoped-name = [mod-qual] unquoted-string    # name1.name2.name3 ...

 # inside complex type members
 # rules need to be replicated with an additional name field

 c-member = c-complex-member / c-simple-member

 c-complex-member = c-complex-type [inst-qual] 

 c-simple-member =  c-simple-member-val [inst-qual] ";"
 
 c-simple-member-val = c-simple-type / named-type

 c-complex-type = c-struct-type / c-choice-type 
                  / c-table-type / c-container-type

 c-struct-type =  "struct" wspace name "{" 1*(c-member) "}"

 c-choice-type =  "choice" wspace name "{" 1*(choice-member) "}"

 c-table-type = "table" wspace name index-decl "{" 1*(c-member) "}"

 c-container-type = "container" wspace name index-decl 
       "{" mname wspace name ";" "}"

 # named type must resolve to one of the listed base types
 # or to a struct that contains (a struct that contains...)
 # a named or base type in the list below

 metatype-decl = c-num-type / c-enum-type 
                 / c-string-type / named-type

 c-simple-type = c-any-type / c-anyapp-type
                 /c-flag-type
                 / c-num-type / c-ename-type
                 / c-enum-type / c-string-type / c-list-type / c-xlist-type

 c-any-type = "any" wspace name

 c-anyapp-type = "anyapp" wspace name

 c-flag-type = flag wspace name

 # !!! redo with 3 different ranges from above
 c-num-type = c-num-type-val wspace name [range]

 c-num-type-val = "int" / "uint" / "long" / "ulong" / "float" / "double"

 c-ename-type = "ename" wspace name [string-restrictions]

 c-enum-type = "enum" wspace name "=" enum-spec

 c-string-type = string-type-val wspace name [string-restrictions]

 c-union-type = "union" wspace name union-body

 c-list-type = "list" wspace name list-body

 c-xlist-type = "xlist" wspace name [xlist-restrictions]

 # RelaxNG Instance Occurance Qualifiers
 # ? == 0 or 1 
 # + == 1 or more
 # * == 0 or more

 inst-qual = "?" / "+" / "*" 

 number =  ord-num / real-num

 ord-num = int-num / hex-num

 int-num = [num-sign] 1*(dec-digit)

 num-sign = "+" / "-" 

 uint-num = 1*(dec-digit)

 hex-num =  "0X" 1*(hex-digit>)    # "0x" also here

 real-num =  [int-sign] 1*(dec-digit) [real-num-p2]

 real-num-p2 = "." 1*(dec-digit)

 dec-digit = "0" .. "9"

 hex-digit = dec-digit / "A" .. "F"  / "a" .. "f"

 wspace = space / htab / vtab / cr / lf / comment

 comment = first "#" (not in quoted string) to end of line




------------------------------------------------------------

                   NCX Syntax Clause Examples

syntax {
  int (0 | 5..127);

  # integer with value from 0 to 127
  # <foo>16</foo>
}

syntax {
  string (..255);

  # string with length from 0 to 255
  # <foo>barney rubble</foo>
}

syntax {
  string = { "fred flintstone" barney wilma };

  # string enum with 3 fixed values
  # <foo>wilma</foo>
}

syntax {
  string = { "fred flintstone" barney wilma };

  # string enum with 3 fixed values
  # <foo>wilma</foo>
}

syntax {
  enum = { fred barney wilma=20 last };

  # enum starts at zero and increment by one by default
  # enums must be in ascending order
  # optional number assignnment overrides default, can't go backwards
  # enum content in instance documents (3 forms):
  #   <foo>barney</foo>
  #   <foo>barney(1)<foo>
  #   <foo>1</foo>
}

syntax {
  # struct containing 3 simple types
  # <foo>
  #   <name>Wilma Flintstone</name>
  #   <address>123 Main St., Bedrock, NY</address>
  #   <phone>212-452-8845</phone>
  # </foo>

  struct {
     string name;
     string address;
     string phone;
  }
}

syntax {
  choice {
     OwnerInfo owner;
     RenterInfo renter;
  }

  # choice of 2 named complex types
  # choice of multiple content types within a simple types 
  # is not allowed
  # <foo>
  #   <owner>
  #     <owner-data>
  #       <foobar>data</foobar>
  #     </owner-data>
  #   </owner>
  # <foo>
  # OR
  # <foo>
  #   <renter>
  #      <blah>data</blah>
  #   </renter>
  # </foo>
  # 
}

syntax {

  # Type: Contacts
  table [int id (1..255)] {
     string name;
     string address;
     string phone?;
  }

  # table containing 3 simple types, indexed by an integer
  # named id that can be a value from 1 to 60
  # The 'phone' table member is optional (? == 0 or 1 instance).
  #
  # An Index component must resolve to a simple type
  # and cannot be zero-length.  As with all NCX identifiers,
  # all leading and trailing whitespace is ignored.
  # 
  # If the index component is not one of the table contents
  # top-level nodes, then it is placed within the table
  # contents, ahead of the nodes actually defined in the table.
  #
  # The index component names MUST NOT conflict with any
  # of the top-level nodes defined in the table contents.
  # The <imports> processing will determine where the
  # index component is defined and its namespace
  #
  # Table instances are not constructed within containers
  # but simply as multiple instances (maxOccurs="unbounded")
  #
  # <foo>
  #   <id>44</id>
  #   <name>Wilma</name>
  #   <address>123 Main St., Bedrock, NY</address>
  #   <phone>212-452-8845</phone>
  # </foo>
  # <foo>
  #   <id>63</id>
  #   <name>Wilma</name>
  #   <address>123 Main St., Bedrock, NY</address>
  #   <phone>212-452-8845</phone>
  # </foo>
}


syntax {
  table server [addr] {
     InetAddress addr;
     string protocol;
     Port  port-num;
     MacAddress mac-addr;  
  }

  # 
  # To declare an table that uses one or more table content
  # members as index components, simply declare the index
  # component as a scoped-name or a name
  #
  # <servers>
  #   <server>
  #      <addr type="ipv4">192.168.0.1</addr>
  #      <protocol>http</protocol>
  #      <port-num>80</port-num>
  #      <mac-addr>22:44:10:ef:00:00:40</mac-addr>
  #   </server>
  #   <server>
  #      <addr type="ipv4">192.168.0.10</addr>
  #      <protocol>ssh</protocol>
  #      <port-num>110</port-num>
  #      <mac-addr>22:44:aa:00:00:45:80</mac-addr>
  #   </server>
}


syntax {
  # Type: ContactList with inline integer index
  # Index id can be value 3, 5, 7, 8, 9, 10
  struct {
    table node [int id ( 3 | 5 | 7 .. 10 )] {
      string name;
      string address;
      string phone;
    }
  }
}



syntax {
  table [positiveInteger contact-id] {
    #customer contact
    Contact contact;

    # contact history
    struct contact-history {
      table event [dateTime contact-time] {
        SalesRepId  handler;
        string contact-type = { phone email in-person };
        choice details {
          string    brief;
          EventRec  full;
        }
      }
    }
  }

  #
  # <foo>
  #   <contact-id>12</contact-id>
  #   <contact>
  #     <name>Fred</name>
  #     <address>144 Elm St</address>
  #     <phone>555-1212</phone>
  #   </contact>
  #   <contact-history>
  #     <event>
  #       <contact-time>2005-10-15</contact-time>
  #       <handler>username</handler>
  #       <contact-type>phone</contact-type>
  #       <details>
  #         <brief>Called to order P43 printer</brief>
  #       </details>
  #     </event>
  #     <event>
  #       <contact-time>2005-11-02</contact-time>
  #       <handler>username</handler>
  #       <contact-type>phone</contact-type>
  #       <details>
  #         <brief>Called to cancel P43 printer</brief>
  #       </details>
  #     </event>
  #   </contact-history>
  # </foo>
  #
}
  


