NCX Framework Notes

   - NCX modules


  A NCX Module has the following format:

   ncx-module moduleName {
     header { ... }
     imports { ... }?
     definitions { ... }?
   }

   A Definition can be one of:

     type        - Type definition
     parmset     - Parameter Set definitions
     monitor     - Monitoring Object Definitions
     rpc         - RPC Method definitions
     notif       - Notification definitions


 Everything except the header is optional, although a module
 without any of the other sections is not very useful, except
 as a placeholder.

 NCX Built-in Data Types
 -----------------------

    any                          # container for any 1 node of any type
    anyps                        # container for any 1 parmset
    boolean                      # alias for enum { false true };
    ename                        # element name, e.g. { running startup }
    enum <enum-spec>             # like C enum or SMI enumerated INTEGER
    flag                         # like <ok>, resolves to boolean
    int [range]                  # 32 bit signed integer
    uint [range]                 # 32 bit unsigned integer
    long [range]                 # 64 bit signed integer
    ulong [range]                # 64 bit unsigned integer
    float [range]                # 32 bit float (or string if !HAS_FLOAT)
    double [range]               # 64 bit double float (if HAS_FLOAT)
    string <string-spec>         # str with range, val set, pattern, regexp
    ustring [pattern | regexp]   # octet str with range, vset, pattern, regexp
    list [pattern | regexp]      # list of 0 to 65535 strings
    ulist [pattern | regexp]     # list of 0 to 65535 ustrings
    struct <struct-spec>         # container of arbitrary members
    choice <choice-spec>         # choice of 1 or more (blocks of) members
    table <table-spec>           # table with SMI-like simple or struct index

 NCX Names
 ---------

 - All fields used as identifiers or versions in some fashion 
   within the NCX syntax are ASCII strings from 1 to 63 characters
 - All names are case-sensitive
 - The first character must be a letter ('a'..'z' or 'A'..'Z')
 - The rest of the characters in an NCX name can be any of:
    - letter ('a'..'z' or 'A'..'Z')
    - number ('0'..'9')
    - underscore ('_')
    - dash ('-')

 NCX Strings
 -----------

 - All string fields are from 0 to 65535 bytes in length
 - The underlying data type is signed char
 - A string value is either 'unquoted' or 'quoted'.
 - Sometimes either form is allowed, otherwise a quoted-string
   may be required
 - A quoted string (double quote char -- string -- double quote char)
   is allowed to contain whitespace, and any NCX tokens inside the
   string (even comments) will be ignored.
 - The escape sequence (/") is used to allow a double quote char 
   inside a string
   - An unquoted string begins with a char and ends on the first
     NCX token or whitespace
 - TBD: C String concatenation; 
   e.g.; <foo>    "long "
               string</foo>  --> "long string"
 - Strings can be constrained with size ranges, value sets,
   XSD patterns and C regular expressions


 NCX UStrings
 ------------
 - All ustring fields are from 0 to 65535 bytes in length
 - The underlying data type is unsigned char
 - C Hex strings (e.g., 0xfeff458dea) are allowed in instances
   of ustrings. 
   - There must be an integral number of bytes represented
   - The on-the-wire length and encoding is irrelevant. 
   - The NCX engine will convert the C-hex to binary
   - Length clauses for ustrings refer to the binary length,
     not the on-the-wire length;
   - Example:
       syntax: ustring ipv4addr (4);
       valid encoding:   "0xc0a80001"       # 192.168.0.1
   - To encode as ASCII ("192.168.0.1") use the string base type
   - TBD: Support BinaryHex and Base64 encoded strings as ustring
     instances, in addition to C-hex
 - Ustrings can be constrained with size ranges, value sets,
   XSD patterns and C regular expressions

 NCX Lists
 ---------

 - A list is an ordered sequence of (0..65535) strings
 - list base type is string
 - ulist base type is ustring
 - Lists and Ulists can be constrained with size ranges, value sets,
   XSD patterns and C regular expressions. This is similar to the
   mechanisms for strings, except multiple patterns or expressions
   can be specified, corresponding to the ordinal position of the string.

  Example:
    list foo regexp =  { "w*", "m*", "*" };

    <foo>"western" movies "any old string"</foo>

 NCX Numbers
 -----------
  - There are three forms of number input
    - Decimal number: 
       begins with optional + or - 
       contains one or more decimal digits 
    - Hex number
       begins with the sequence '0x' or '0X'
       contains one or more hex or decimal digits
       There should be an integral number of bytes represented.
       If not, a leading 0 nibble will be added to unsigned
       numbers, and signed numbers will be sign-extended 
       (i.e., prefixed with 0x0 or 0xf )
    - Real number
       begins with optional + or -
       contains one or more decimal digits, followed by
       an optional decimal point, followed by one or more digits
       TBD: Full IEEE Floating point support


 NCX Modules vs. Applications
 ----------------------------

    Modules are simply containers of definitions. 
    Each module specifies one <owner> name,
    which has one or more specific namespaces associated with it.

    The (owner, application) pair, not the module, is the 
    real data model container.  

    All application-specific definitions (e.g., parmset, 
    rpc, notif) are considered be be in the same naming scope 
    if they share the same owner and application name.  

    Types are considered to be owner-specific, (owner, type) not
    application-specific.  Only one type-name per owner
    is allowed, instead of different versions per application.

    Parameter set and Monitor set definitions are always
    application-specific (owner, application, definition).

    Rpc method and notification definitions can be either 
    owner-specific (owner, notif) or application-specific
    (owner, application, notif).  If the "application" 
    attribute is present in the <rpc> element, then the
    NCX engine will treat an RPC invocation as application
    specific, otherwise an owner-specific method will be used.
    In other words, app-specific methods and notifications
    have precedence if both kinds are defined in the same data model.


 Header
 ------

  <header>
    <name>ModuleName</name>
    <version>moduleVersionString</version>
    <owner>applicationOwnerName</owner>
    <application>applicationName</application>
   [<copyright>copyright string</copyright>]
   [<contact-info>contact info string</contact-info>]
   [<description>Optional Module Description</description>]
   [<namespace>OverrideDefaultNamespaceID</namespace>
  </header>

  name: module name.  
        This is the value used is imports.module field

  version: Module version; no specified format; it is up
        to the module designer to establish a version pattern
     
  owner: NCX application owner; this could be a vendor name
         or the reserved owner name 'ncx', or some other
         administratively unique string.  If <namespace>
         is omitted, then a default namespace using the
         owner field will be constructed instead.

  application: NCX application name : parent ID node for
        the parmsetdefs in this module

  copyright: Optional copyright text
 
  contact-info: Optional author and/or owner contact info

  description: Optional description of module contents

  namespace: Optional namespace ID; If this parameter is
         present then the application namespace will be set
         to this field instead of the default constructed string.
         Do not include the 'xmlns' attribute or any prefix
         values, just the namespace string value.

 Imports
 -------

  <imports>
    <import>
      <module>ModuleName</module>
      [<items>Item1 Item2</items>]
    </import>
  </imports>

 Import Resolution Processing
 -----------------------------
 
  - Duplicate <import> entries are not errors (what about warnings?)
  - If the items list is present, then only the listed
    items will be available from that module. Otherwise,
    the <import> clause simply declares module search order.
  - The built-in types cannot be imported or redefined.
  - Definition Resolution Processing Order
    1) Current module being parsed
    2) Search the importQ in order for the first <items> list
       that contains the definition name
    3) Search the importQ in order, checking all modules
       without an items list, for the first one that contains 
       the definition name


  - Each parameter set definition (PSD) contains zero or more
    parameter definitions.

  - Each PSD is keyed by 2 strings 

    - ( application-name, parmset-name )

  Maximum string lengths

    - All application, Parmset, rpc, and type names: [1..63]

  There are three uses for parameter set definitions:

   - rpc parameter set
     The IN or OUT parameter set for an Remote Procedure Call

     The application-name key is set to the rpc-method name.
     The optional version attribute is in the rpc-method name

   - application parameter set

     A data model parameter set for a particular application

     The application-name is the top-level node (at layer N)
     The parmset-name is the 2nd-level node (at layer N+1)
     The optional version attribute is in the parmset-name node.

   - child parameter set

     A data model parameter set for a particular application.
     Within an instance document, the application node generation 
     can be omitted because the <app> name is the same as the parent PSD
     The 'child PSD' properties are detected during parsing,
     and not specified in the PSD itself.

     In this case, the application-name is implied to be the value provided
     in the parent application parameter set. (at layer N)
     The psd-name is the 1st-level node (at layer N+m)
     The optional version attribute is in the psd-namenode.

     This type of PSD is intended to avoid an extra nest level
     in the instance documents.  However, the application-name
     must match, and a runtime error will occur if a child PSD
     for the wrong application is encountered.

  Values allowed in the <parm> type field
     
  - Typename

    A type name can be specified, which may be declared in this
    module or an imported module.

   - Parameter Set Definition Name

     Any data parameter set definition (other than the one being defined)
     can be specified. allowing nested definitions and internal 
     processing. 

   Special Types allowed in the <syntax> clause

  - 'any'

     This special flag indicates the parameter is the root
     placeholder for 1 (unspecified) node of any type.
     
  - 'anyps'

     This special flag indicates the parameter is the root
     placeholder for 1 (unspecified) application parmset,
     unless modified with an instance qualifier (?, +, *).
     Parmsets can be placed anywhere in a data structure, and
     they are encoded in XML instance documents in the following
     manner:
             - owner of the PS encoded in the NS of the top level el.
             - application name encoded in the top level element
             - PSD name encoded in the child
          
         Given node 'foo' of type 'anyps', the following is
         possible for PSD nc-transport in the 'ncxmain' application,
         which is owned by 'ncx':

            <foo>
              <ncxmain xmlns="uri-for-owner-ncx">
                <nc-transport>
                   .... 
                </nc-transport>
              </ncxmain>
              ** COULD BE MORE PS INSTTANCES HERE **
            </foo>

  - 'flag'

     This special data type is used to support flag type parameters
     such as the <ok> flag in NETCONF. Also, many CMDLINE params
     are declared to be TRUE if present and FALSE is not present.
     This data type resolves to 'boolean' in Canonical Config Format.
     All data models are supposed to be static representations of
     configuration parameters, but the flag is message dependent.

     By design, NCX data models are defined independent of any
     particular NETCONF or other RPC method that uses the data model.
     The max-access clause (and some algorithms) determine what
     protocol operation can be done to each bit of data. 
     Use of the flag data type tells the parser that this 
     is a boolean that needs special instance document handling.
     

  Data Types Allowed In Index Clauses
  -----------------------------------

  When the parser encounters the first token string in an
  index clause component (i.e., just after left bracket or comma)
  it tries to resolve the identifier in the following manner
  and in this order:

  A) - any of the following builtin types:
       (called an inline index definition)
       - boolean
       - ename
       - enum
       - int
       - long
       - uint
       - ulong
       - float
       - double
       - string
       - ostring

  B) - any named simple type which resolves to a base type in (A)
       (called a named index definition)

  C) - any named struct containing only members which conform to (A), (B),
       or (C) (called a named index definition)
    
  D) - any name of a top level member in the table being defined
       (called a local index type)

  E) If the string is a scoped-string (e.g., foo.bar.baz) then
     the current module and import path is searched for this
     as any named member of any exported symbol. In this example
     the module and then import path would look for the symbol 'foo'
     and if it contained a double-nested node called 'bar.baz',
     then the semantics for this node are assumed, and the syntax for 
     this object are used to validate the index.  A member called
     'foo.bar.baz' will be added to the top level of the table entry.

     Note that if a module qualified form is encountered, the module
     qualifer will not be present in the instance document as this
     is not needed and conflicts with XML namespace prefixes.

  F) If the string or scoped-string is a not found externally, it is 
     assumed to be a local index (or local scoped index) and is a
     forward reference to a member name that follows in the table
     definition.  This is validated after the table members are
     parsed, and if there is no match then an error is generated.

     If the unresolved token is a module-qualified identifier,
     then an error is returned, since this cannot be the name
     of a local member of the table.
     


NCX Module Syntax
------------------

# Basic Encoding Rules
#
# A comment is a hash mark to end-of-line, and is treated
# syntactically as a whitespace character.
# 
# Module and sub-sections follow the form
#   <construct> construct-name "{" 
#      <construct-contents>
#   "}"
#
# A simple clause ends in a semi-colon;
#
# Basic Rule:
#   If it starts with a left brace, it ends with a right brace
#   and not a semi-colon.
#
# Exceptions are:
#   - Index clause components are comma-terminated (except last)
#   - Notification objects components are comma-terminated (except last)
#
# These exceptions exist to align with current SMI and C conventions 
# for these clauses.  They can contain inline or named type
# declarations, object names, module-qualified names,
# or scoped object names.
#
# Whitespace is not significant unless specified as such.
# All whitespace within quoted strings is preserved.
# Unquoted strings end on the first whitespace, EOLN, or NCX token.
#
# User named types are allowed anywhere a base type name can be used.
# User named types must be defined using base types. They 
# cannot be defined using other named types.  This limitation
# simplifies module maintenance and is consistent with SMIv2.
#
# Metadata is translated to XML attributes in NETCONF PDUs.
# Types used in this clause are limited to a subset of the
# base types.  If a named type is used in a metadata item
# declaration, then any metadata defined in that named type
# is ignored (for metadata usage only).
#
# Unnamed instances are specified with the ABNF constructs
# for this purpose:
#  no qualifier:  1 instance
#  ? qualifier: 0-1 instances
#  + qualifier: 1 or more instances
#  * qualifier: 0 or more instances
#
# Named instances are specified using the 'table' construct.
# The [index] clause specifies the instance identifiers
# for the contents of the table.  Index components can
# be inline or named types, identifiers of type, parmset,
# or object constructs, or their child member names.
#
# The special index clause [*] indicates all the table
# members are part of the index (no duplicates allowed).
#
# The special index clause [] indicates none the table
# members are part of the index (duplicates allowed).
# This unnamed form of a table is equivalent to declaring
# a struct type with the '*' qualifier (0 or more instances).
#
# Scoped names are specified as in C, using field names
# separated by the dot char:  foo.bar.baz
# 
# Items listed explicitly or implicitly in the imports section
# can be used in the module as if they are defined there.
# Multiple definitions with the same name can be used if
# one of the module-qualified forms is used
#    simple form: fooModule:bar
#    scoped form: fooModule:bar.baz.bax
#
# The module name 'fooModule' must be listed in the imports section.
# If a module-qualified form is used, then the normal imports 
# processing order is ignored and only the specified module
# will be checked.
#
# Built-in Type Names
#
# any                  Any type
# anyps                Any parmset
# boolean              XSD boolean
# ename                element name string
# enum                 enumerated integer
# flag                 boolean flag element 
# int                  32 bit signed integer
# uint                 32 bit unsigned integer
# long                 64 bit signed integer
# ulong                64 bit unsigned integer
# string               64k signed char string
# ustring              64k unsigned char string
# list                 list of string
# ulist                list of ustring
# struct               container of anything
# choice               choose 1 of N of anything
# table                named or unnamed instances of anything
#
# These type names cannot be re-defined in any way.
# The base types are not associated with any owner
# or module, so they cannot be used in a 
# module-qualified identifier variant. NO 'fooModule:int'
#
# The header.owner, and header.application fields
# are very important in parmset instance documents.  
#
# The owner is used to construct the namespace of 
# the top-level element of parmset, unless the 
# header.namespace field is present to override the
# namespace default.  
#
# The application field is used to name the top-level
# node of a parmset instance.
#
# Note that this extra level of containment is not required
# by NETCONF, since the namespace of any node can define
# its origin, but this containment convention allows for:
#   - easy-to-understand/implement serialization conventions
#   - anyps parmset-placeholder data type
#   - proper operation even if all namespace decls are missing

# SYNTAX EXAMPLE (With Instance Qualifier Markup)
ncx-module ModuleName {
  header {
    description "Optional Module Description";?
    version ModuleVersionString;
    owner ModuleOwnerName;
    application DefaultApplicationName;
    copyright "Copyright String";?
    contact-info "Contact Info";?
    namespace OverrideDefaultNamespaceUri;?
  }
  imports {
    # 2 forms of the import clause
    import ModuleName { ItemName* };*
    import ModuleName;*
  }?
  definitions {
    # no defined order but no forward references allowed

    # Types are abstract data structure descriptors
    # associated with the owner, not the namespace.
    # They have no access control attributes.
    # All types imported into a module can be used
    # in the same namespace or same owner,
    # within the module and in XML instance documents.

    type TypeName {
      description "descriptionString";?
      syntax  {
        # elements defined here
        # all data types allowed in elements
        #  -- see ncx-syntax-contents ABNF -- 
      }
      metadata {   
        # attributes are called metadata
        # a subset of inline data type decls are allowed in metadata
        # named types resolving to this subset are also allowed
        # Named types which resolve to structs containing 
        # (structs containing) only these declarations are also allowed.
        # Such structs will be encoded in XML instance documents
        # using the data's scoped name for the attribute name (foo.bar.baz)
        #  -- see ncx-metadata ABNF --       
      }?
      default "value-string";?
    }*

    # Parameter Set Definitions contain writable parameters
    # They can also contain read-only and notify-only parameters
    # but this is not encouraged.
    # 
    # Parmsets are associated with an owner, application tuple
    # If the application field is missing then the default 
    # application specified in the header is used

    parmset PsdName {
      description "Optional PSD Description";?
      condition "Condition Expression";?
      application ApplicationName;?
      order OrderType;?       # strict or loose ordering
      parms {
        parm ParameterName {
          description "Description Clause";?
          condition "Condition Expression";?
          type ParameterTypeName;
          max-access AllowedAccessClause;?
          usage UsageType;?   # mandatory, optional, or conditional
          default "value-string";?   # overrides type default, if any
        }*

        # nested choices are not allowed
        # 3 choices, choose 1 of parm: p1, p2, p3 & p4
        choice {
          parm p1 ...

          parm p2 ...

          # nested brackets are not allowed
         [  parm p3 ...

            parm p4 ... ]
        }
      }  # end parms section
    }*   # end parmset

    # Monitor Set Definitions contain state data
    # They contain max-access read-only data
    #
    # Monitor Sets are associated with an owner, application tuple
    # If the application field is missing then the default 
    # application specified in the header is used

    monitor MonitorObjectGroupName {
      description "Optional Monitor Object Block Description";?
      condition "Condition Expression";?
      application ApplicationName;?
      objects {
        object ObjectName {
          description "Description Clause";?
          condition "Condition Expression";?
          type ObjectTypeName;
        }*

        # nested choices are not allowed
        # 3 choices, choose 1 of object: o1, o2, o3 & o4
        choice {
          object o1 ...

          object o2 ...

       # nested brackets are not allowed
       [  object o3 ...

          object o4 ... ]
       } 
      }
    }*

    # User-defined RPC method definition
    # The in-psd input parameter set is optional
    # The out-data output data is mandatory and can 
    # contain a type, parmset, or monitor name
    #
    # By default, RPC methods are associated with
    # the owner name, but if an application field is
    # present, then the RPC method will be associated 
    # with the owner, application tuple.
    #
    # If the application field is missing then the 
    # RPC method is a global method, not app-specific

    rpc RpcMethodName {
      description "Description Clause";?
      condition "Condition Expression";?
      application ApplicationName;?
      rpc-type RpcMethodType;
      in-psd InputPsdName;?
      out-data OutputDataName;
    }*


    # NCX Notification definition
    # The notif-data output data is optional
    #
    # By default, notification are associated with
    # the owner name, but if an application field is
    # present, then the notification will be associated 
    # with the owner, application tuple.
    #
    # If the application field is missing then the 
    # notification is global, not app-specific

    notif NotificationName {
      description "Description Clause";?
      condition "Condition Expression";?
      application ApplicationName;?
      notif-class NotificationClass;
      notif-type  NotificationtType;
      notif-data {
        # objects can be any identifier type
        # for any type, parmset, parmset.parm, 
        #   monitor, or monitor.object
        #
        # -- see notif-objects ABNF
      }?   # 0 or 1 objects section
    }*     # 0 or more notif sections
  }?       # 0 or 1 definitions section
}          # 1 ncx-module container



-------------------------------------------------------------------------
# NCX SYNTAX ABNF
# Not strict ABNF yet
# The quoted strings are supposed to be case-insensitive
# but in NCX they are always case-sensitive.
# Start symbol is 'ncx-module'

 ncx-module = ncx-module wspace name "{"
              ncx-header [ncx-imports] [ncx-definitions] "}"

 ncx-header =  "header" "{" header-contents "}"

 header-contents = [ncx-descr] hdr-version hdr-owner 
                   [hdr-copyright] [hdr-contact] [hdr-ns]
 
 hdr-version = "version" wspace ver-string ";"

 ver-string = string      # limited in size to  (1..63) chars

 hdr-owner = "owner" wspace name ";"

 ncx-application = "application" name ";"

 hdr-copyright = "copyright" wspace quoted-string ";"

 hdr-contact = "contact-info" wspace quoted-string ";"   

 ncx-descr = "description" wspace quoted-string ";"

 hdr-ns = "namespace" wspace quoted-string ";"

 ncx-imports = "imports" "{" 0*(ncx-import) "}"

 ncx-import = "import" wspace name [import-items] ";" 

 import-items = "{" 0*(name) "}"

 ncx-definitions = "definitions "{" 0*(ncx-definition) "}"

 ncx-definition = ncx-type / ncx-ps / ncx-mon /
                  ncx-rpc / ncx-notif

 ncx-type = "type" name "{" 
                 [ncx-descr] ncx-syntax 
                 [ncx-metadata] [ncx-default] "}"

 ncx-syntax = "syntax" "{" ncx-syntax-contents "}"

 ncx-metadata = "metadata" "{" 0*(ncx-metadata-decl) "}"

 ncx-metadata-decl = metatype-decl [inst-qual] ";"

 ncx-parmset = "parmset" wspace name "{" ncx-ps-contents "}"
 
 ncx-ps-contents = [ncx-descr] [ncx-condition] 
                   [ncx-application] [ncx-order] 
                   "parms" "{" 1*(ncx-pterm) "}"

 ncx-condition = "condition" wspace quoted-string ";"

 ncx-order = "order" wspace ncx-order-val ";"
 
 ncx-order-val = "loose" / "strict" 

 ncx-pterm = ncx-pchoice / ncx-parm

 # nested choices are not allowed but eventually at least 
 # one ncx-parm must be specified

 ncx-pchoice = "choice" "{" 1*(ncx-pchoice-member) "}"

 ncx-pchoice-member = ncx-pchoice-block / ncx-parm

 ncx-pchoice-block = "[" 1*(ncx-parm) "]"
 
 ncx-parm = "parm" name "{" ncx-parm-contents "}"

 ncx-parm-contents = [ncx-descr] [ncx-condition] 
               ncx-typname [ncx-ps-access] 
               [ncx-ps-usage] [ncx-default] 

 ncx-typname = "type" wspace mname ";"

 # if the default value has embedded NCX tokens then it must
 # be a quoted-string, otherwise it will be parsed as multiple
 # tokens instead of 1 string
 ncx-default = "default" wspace quoted-string ";"

 ncx-ps-usage = "usage" wspace ncx-ps-usage-val ";"

 ncx-ps-usage-val = "mandatory" / "optional" / "conditional"

 ncx-ps-access = "max-access" wspace ncx-ps-access-val ";"

 ncx-ps-access-val = "notify" / "read" / "write" / "create" /
                   "read-write" / read-create" / "all"

 ncx-mon = "monitor" wspace name "{" ncx-mon-contents "}"

 ncx-mon-contents = [ncx-descr] [ncx-condition] [ncx-application]
                    "objects" "{" 1*(ncx-oterm) "}"

 ncx-oterm = ncx-ochoice / ncx-object

 ncx-ochoice = "choice" "{" 1*(ncx-ochoice-member) "}"

 ncx-ochoice-member = ncx-ochoice-block / ncx-object

 ncx-ochoice-block = "[" 1*(ncx-object) "]"

 ncx-object = "object" wspace name "{" ncx-obj-contents "}"

 ncx-obj-contents = [ncx-descr] [ncx-condition] ncx-typname

 ncx-rpc = "rpc" wspace name "{" ncx-rpc-contents "}"

 ncx-rpc-contents = [ncx-descr] [ncx-condition] [ncx-application]
                    ncx-rpc-type [ncx-in-psd] ncx-out-data

 ncx-rpc-type = "rpc-type" wspace ncx-rpc-type-val ";"

 ncx-rpc-type-val = "other" / "config" / "exec" / 
                    "monitor" / "debug"

 ncx-in-psd = "in-psd" wspace mname ";"

 ncx-out-data = "out-data" wspace mname ";"

 ncx-notif = "notif" wspace name "{" ncx-notif-contents "}"

 ncx-notif-contents = [ncx-descr] [ncx-condition] [ncx-application]
                     ncx-notif-class ncx-notif-type [ncx-notif-data]

 ncx-notif-class = "notif-class" wspace string ";"

 ncx-notif-type = "notif-type" wspace string ";"

 ncx-notif-data = "notif-data" "{" [ncx-notif-objs] "}" 

 ncx-notif-objs = ncx-notif-obj 0*("," ncx-notif-obj)

 ncx-notif-obj = mname / scoped-name

 # <syntax> clause ABNF

 ncx-syntax-contents = simple-type / complex-type / full-named-type
 
 simple-type = sim-type [inst-qual] ";"

 sim-type = any-type / anyps-type / flag-type
               / num-type / ename-type
               / enum-type / string-type / list-type

 any-type = "any"

 anyps-type = "anyps"

 flag-type = "flag"

 num-type = ord-type / real-type

 ord-type = ord-type-val [ord-range]

 ord-type-val = "int" / "uint" / "long" / "ulong"

 real-type = real-type-val [real-range]

 real-type-val = "float" / "double"

 range = "(" range-spec 0*("|" range-spec) ")"

 range-spec = number / number-pair

 number-pair = number-pair-1 / number-pair-2 

 number-pair-1 = [number] ".." number 

 number-pair-2 = number ".." [number]

 ord-range = "(" ord-range-spec 0*("|" ord-range-spec) ")"

 ord-range-spec = ord-num / ord-num-pair

 ord-num-pair = ord-num-pair-1 / ord-num-pair-2

 ord-num-pair-1 = [ord-num] ".." ord-num

 ord-num-pair-2 = ord-num ".." [ord-num]

 uint-range = "(" uint-range-spec 0*("|" uint-range-spec) ")"

 uint-range-spec = uint-num / uint-num-pair 

 uint-num-pair = uint-num-pair-1 / uint-num-pair-2

 uint-num-pair-1 = [uint-num] ".." uint-num

 uint-num-pair-2 = uint-num ".." [uint-num]

 real-range = "(" real-range-spec 0*("|" real-range-spec) ")"

 real-range-spec = real-num / real-num-pair

 real-num-pair = real-num-pair-1 / real-num-pair-2

 real-num-pair-1 = [real-num] ".." real-num

 real-num-pair-2 = real-num ".." [real-num]

 ename-type = "ename" [string-restrictions]

 string-restrictions = string-restriction / string-set

 string-restriction = [uint-range] [string-val-restriction]

 string-val-restriction = string-pattern / string-regexp

 enum-type = "enum" enum-spec

 enum-spec = "{" 1*(enum-elem) "}"

 enum-elem = name ["=" int-num] 

 string-type = string-type-val [string-restrictions]

 string-set = "=" "{" 1*(string) "}"

 string = quoted-string / unquoted-string

 quoted-string = """ whitespace-allowed-string """

 unquoted-string = whitespace-not-allowed-string

 string-pattern = "pattern" "=" <quoted-string>

 string-regexp = "regexp" "=" <quoted-string>

 list-type = list-type-val [list-restrictions]

 list-type-val = "list" / "ulist"

 list-restrictions = list-restriction / list-set

 list-restriction = [uint-range] [list-val-restriction]

 list-val-restriction = list-pattern / list-regexp

 list-set = "{" 0*(list) "}"

 list = "{" 0*(string) "}"

 list-pattern = wspace "pattern" "=" list-set

 list-regexp = wspace "regexp" "=" list-set

 complex-type = complex-type-val  [inst-qual]

 complex-type-val = struct-type / choice-type / table-type

 struct-type =  "struct" "{" 1*(c-member) "}"

 choice-type =  "choice" "{" 1*(choice-member)  "}"

 choice-member = choice-block / c-member
 
 choice-block = "[" 1*(c-member) "]"

 table-type = "table" index-decl "{" 1*(c-member) "}"

 named-type =  name wspace name    # typename member-name

 full-named-type =  named-type ";"   

 index-decl = "[" [index-decl-val] "]"

 index-decl-val = index-components / "*"

 index-components = index-component 0*("," index-component)

 index-component = c-index-type> / scoped-name 
                  / name / named-type

 c-index-type = c-num-type / c-enum-type 
               / c-ename-type / c-string-type / c-list-type


 # Each name component (between the dots) is
 # limited in size to (1..63) + NCX name rules
 # No space allowed between the module qualifier and the string
 # limited in size (1..63) + NCX name rules
 # No space allowed between the module name and the colon char

 mod-qual = unquoted-string ":"

 name        = unquoted-string

 mname       = [mod-qual] unquoted-string    # IfMib:IfTable

 scoped-name = [mod-qual] unquoted-string    # name1.name2.name3 ...

 # inside complex type members
 # rules need to be replicated with an additional name field

 c-member = c-complex-member / c-simple-member

 c-complex-member = c-complex-type [inst-qual] 

 c-simple-member =  c-simple-member-val [inst-qual] ";"
 
 c-simple-member-val = c-simple-type / named-type

 c-complex-type = c-struct-type / c-choice-type / c-table-type

 c-struct-type =  "struct" wspace name "{" 1*(c-member) "}"

 c-choice-type =  "choice" wspace name "{" 1*(choice-member) "}"

 c-table-type = "table" wspace name index-decl "{" 1*(c-member) "}"

 # named type must resolve to one of the listed base types
 # or to a struct that contains (a struct that contains...)
 # a named or base type in the list below

 metatype-decl = c-boolean-type / c-num-type
               / c-enum-type / c-string-type / named-type

 c-simple-type = c-any-type / c-anyps-type
                 / c-boolean-type /c-flag-type
                 / c-num-type / c-ename-type
                 / c-enum-type / c-string-type / c-list-type

 c-any-type = "any" wspace name

 c-anyps-type = "anyps" wspace name

 c-boolean-type = "boolean" wspace name

 c-flag-type = flag wspace name

 # !!! redo with 3 different ranges from above
 c-num-type = c-num-type-val wspace name [range]

 c-num-type-val = "int" / "uint" / "long" / "ulong" / "float" / "double"

 c-ename-type = "ename" wspace name [string-restrictions]

 c-enum-type = "enum" wspace name enum-spec

 c-string-type = string-type-val wspace name [string-restrictions]

 c-list-type = list-type-val wspace name [list-restrictions]

 # RelaxNG Instance Occurance Qualifiers
 # ? == 0 or 1 
 # + == 1 or more
 # * == 0 or more

 inst-qual = "?" / "+" / "*" 

 number =  ord-num / real-num

 ord-num = int-num / hex-num

 int-num = [num-sign] 1*(dec-digit)

 num-sign = "+" / "-" 

 uint-num = 1*(dec-digit)

 hex-num =  "0X" 1*(hex-digit>)    # "0x" also here

 real-num =  [int-sign] 1*(dec-digit) [real-num-p2]

 real-num-p2 = "." 1*(dec-digit)

 dec-digit = "0" .. "9"

 hex-digit = dec-digit / "A" .. "F"  / "a" .. "f"

 wspace = space / htab / vtab / cr / lf / comment

 comment = first "#" (not in quoted string) to end of line




------------------------------------------------------------

                   NCX Syntax Clause Examples

syntax {
  int (0 | 5..127);

  # integer with value from 0 to 127
  # <foo>16</foo>
}

syntax {
  string (..255);

  # string with length from 0 to 255
  # <foo>barney rubble</foo>
}

syntax {
  string = { "fred flintstone" barney wilma };

  # string enum with 3 fixed values
  # <foo>wilma</foo>
}

syntax {
  string = { "fred flintstone" barney wilma };

  # string enum with 3 fixed values
  # <foo>wilma</foo>
}

syntax {
  string pattern = "w*";

  # string defined with XSD-compatible pattern
  # <foo>wilma</foo>
}

syntax {
  # Type: OID

  string pattern = "pattern.for.num.num";

  #
  #    <foo>1.3.6.4.2.6.2.1.1</foo>
}

syntax {
  anyps+;

  # this named type would be used for the rpc 'config' object
  # to indicate one or more parmset instances are expected
}

syntax {
  enum { fred barney wilma=20 last };

  # enum starts at zero and increment by one by default
  # enums must be in ascending order
  # optional number assignnment overrides default, can't go backwards
  # enum content in instance documents (3 forms):
  #   <foo>barney</foo>
  #   <foo>barney(1)<foo>
  #   <foo>1</foo>
}

syntax {
  list (1..64);

  # list as defined in XSD
  # Each element can be 1 to 64 characters long
  # <foo>wilma barney bam-bam "betty and pebbles"</foo>
}

syntax {
  list pattern = { "W*" "f*" };

  # list pattern as defined in XSD
  # There can only be two elements, and the first string must
  # start with a W and the 2nd string must start with an f
  # <foo>Wilma fred</foo>
}

syntax {
  list foo = { { barney wilma } { fred "bam bam" } };

  # list of 2 strings
  # string 1 is allowed to contain barney or wilma
  # string 2 is allowed to contain fred or bam bam
}

syntax {
  list foo (1..44);

  # list of N strings
  # each string is allowed to be from 1 to 44 bytes
}

syntax {
  list foo pattern = { "pattern1" "pattern2" "pattern3" };
  # list of 3 strings
  # each string has its own pattern
}

syntax {
  list foo regexp = { "regexp1" "regexp2" "regexp3" "*" };

  # list of 4 strings
  # each string has its own regular expression
  # string 4 is allowed to contain any value
}

syntax {
  list foo;
  # list of N strings, each with any value
}

syntax {
  # struct containing 3 simple types
  # <foo>
  #   <name>Wilma Flintstone</name>
  #   <address>123 Main St., Bedrock, NY</address>
  #   <phone>212-452-8845</phone>
  # </foo>

  struct {
     string name;
     string address;
     string phone;
  }
}

syntax {
  choice {
     OwnerInfo owner;
     RenterInfo renter;
  }

  # choice of 2 named complex types
  # choice of multiple content types within a simple types 
  # is not allowed
  # <foo>
  #   <owner>
  #     <owner-data>
  #       <foobar>data</foobar>
  #     </owner-data>
  #   </owner>
  # <foo>
  # OR
  # <foo>
  #   <renter>
  #      <blah>data</blah>
  #   </renter>
  # </foo>
  # 
}

syntax {

  # Type: Contacts
  table [int id (1..255)] {
     string name;
     string address;
     string phone?;
  }

  # table containing 3 simple types, indexed by an integer
  # named id that can be a value from 1 to 60
  # The 'phone' table member is optional (? == 0 or 1 instance).
  #
  # An Index component must resolve to a simple type
  # and cannot be zero-length.  As with all NCX identifiers,
  # all leading and trailing whitespace is ignored.
  # 
  # If the index component is not one of the table contents
  # top-level nodes, then it is placed within the table
  # contents, ahead of the nodes actually defined in the table.
  #
  # The index component names MUST NOT conflict with any
  # of the top-level nodes defined in the table contents.
  # The <imports> processing will determine where the
  # index component is defined and its namespace
  #
  # Table instances are not constructed within containers
  # but simply as multiple instances (maxOccurs="unbounded")
  #
  # <foo>
  #   <id>44</id>
  #   <name>Wilma</name>
  #   <address>123 Main St., Bedrock, NY</address>
  #   <phone>212-452-8845</phone>
  # </foo>
  # <foo>
  #   <id>63</id>
  #   <name>Wilma</name>
  #   <address>123 Main St., Bedrock, NY</address>
  #   <phone>212-452-8845</phone>
  # </foo>
}


syntax {

  table server [InetAddress addr] {
     string protocol;
     Port  port-num;
     MacAddress mac-addr;  
  }

  # 
  # To declare an table that uses one or more table content
  # members as index components, simply declare the index
  # component as a scoped-name or a name
  #
  # If a scoped-name (e.g., a.b.c) is used then all
  # the member names must match nested member names within
  # the table contents, and all those members must be either
  # struct, table, or simple type. (Anything but choice!)
  # 
  # SPECIAL CASE: Structs containing only (structs containing)
  # simple types can be specified as index components:
  #
  # <servers>
  #   <server>
  #      <addr>
  #         <type>ipv4</type>
  #         <address>192.168.0.1</address>
  #      </addr>
  #      <protocol>http</protocol>
  #      <port-num>80</port-num>
  #      <mac-addr>22:44:10:ef:00:00:40</mac-addr>
  #   </server>
  #   <server>
  #      <addr>
  #         <type>ipv4</type>
  #         <address>192.168.0.10</address>
  #      </addr>
  #      <protocol>ssh</protocol>
  #      <port-num>110</port-num>
  #      <mac-addr>22:44:aa:00:00:45:80</mac-addr>
  #   </server>
}


syntax {
  # Type: ContactList by reference
  #
  struct {
    Contact  node;
  }
}


syntax {
  # Type: ContactList Inline
  #
  struct {
    table node [int id = ( 3 5 7 }] {
      string name;
      string address;
      string phone;
    }
  }
}


syntax {

  # The following definitions are equivalent:

  table [] {
     Contact  contact;
  }
`
  struct {
     Contact  contact*;
  }

  # Type: Container of unnamed multiple instances of Contact
  # Duplicates are allowed. Since there is no naming, the
  # concept of a duplicate does not apply here.
  # 
  # An application can access the Nth entry, but
  # not any entry by name. Filter searchs for
  # these entries return all entries that match the filter
  # even if they are duplicates
  #
  # There is no sort order defined.
  # There is no deterministic merge order required.
  # It is suggested that indened tables be used instead
  # for deterministic sequences of the a particular type
  #
  # <foo>
  #   <contact>
  #     <name>Wilma</name>
  #     <address>123 Main St., Bedrock, NY</address>
  #     <phone>212-452-8845</phone>
  #   </contact>
  #   <contact>
  #     <name>Wilma</name>
  #     <address>123 Main St., Bedrock, NY</address>
  #     <phone>212-452-8845</phone>
  #   </contact>
  # </foo>
  #
}


syntax {
  #
  # <foo>
  #   <contact-id>12</contact-id>
  #   <contact>
  #     <name>Fred</name>
  #     <address>144 Elm St</address>
  #     <phone>555-1212</phone>
  #   </contact>
  #   <contact-history>
  #     <event>
  #       <contact-time>2005-10-15</contact-time>
  #       <handler>username</handler>
  #       <contact-type>phone</contact-type>
  #       <details>
  #         <brief>Called to order P43 printer</brief>
  #       </details>
  #     </event>
  #     <event>
  #       <contact-time>2005-11-02</contact-time>
  #       <handler>username</handler>
  #       <contact-type>phone</contact-type>
  #       <details>
  #         <brief>Called to cancel P43 printer</brief>
  #       </details>
  #     </event>
  #   </contact-history>
  # </foo>
  #

  table [positiveInteger contact-id] {
    #customer contact
    Contact contact;

    # contact history
    struct contact-history {
      table event [dateTime contact-time] {
        SalesRepId  handler;
        string contact-type (phone email in-person);
        choice details {
          string    brief;
          EventRec  full;
        }
      }
    }
  }
}
  



