
/* 

 * Copyright (c) 2009 - 2011, Andy Bierman
 * All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 1.15.1416M

    module device_test
    revision 2011-09-07

    namespace http://netconfcentral.org/ns/device_test

 */

extern "C" {
#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_rpc.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "rpc.h"
#include "ses.h"
#include "status.h"
#include "val.h"
#include "val_util.h"
#include "xml_util.h"
#include "device_test.h"
}

#include "test/support/callbacks/sil-callback-log.h"

/* module static variables */
static ncx_module_t *device_test_mod;
static obj_template_t *part1_obj;
static obj_template_t *xpo_obj;
static obj_template_t *get_resource_types_obj;
static obj_template_t *get_resource_capability_obj;
static obj_template_t *get_dictionary_obj;
static obj_template_t *get_dictionary_reference_obj;
static obj_template_t *copy_profile_obj;
static obj_template_t *copy_stream_obj;
static obj_template_t *modify_stream_config_obj;
static obj_template_t *modify_stream_alarm_config_obj;
static obj_template_t *modify_stream_status_config_obj;
static obj_template_t *get_status_obj;
static obj_template_t *get_time_obj;
static obj_template_t *set_time_obj;
static val_value_t *part1_val;
static val_value_t *xpo_val;

/* put your static variables here */


/********************************************************************
* FUNCTION y_device_test_part1_part1Version_packageVersion_get
* 
* Get database object callback
* Path: /part1/part1Version/packageVersion
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_part1Version_packageVersion_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *packageVersion;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_part1Version_packageVersion_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_part1Version_packageVersion_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the packageVersion var here, change EMPTY_STRING */
    packageVersion = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        packageVersion);

    return res;

} /* y_device_test_part1_part1Version_packageVersion_get */


/********************************************************************
* FUNCTION y_device_test_part1_part1Version_packageValid_get
* 
* Get database object callback
* Path: /part1/part1Version/packageValid
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_part1Version_packageValid_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    boolean packageValid;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_part1Version_packageValid_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_part1Version_packageValid_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the packageValid var here, change TRUE if needed */
    packageValid = TRUE;VAL_BOOL(dstval) = packageValid;

    return res;

} /* y_device_test_part1_part1Version_packageValid_get */


/********************************************************************
* FUNCTION y_device_test_part1_part1Version_mro
* 
* Make read-only child nodes
* Path: /part1/part1Version
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_part1Version_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_part1Version_mro";
    cbLog.addCallback("device_test", cbData);


    /* add /part1/part1Version/packageVersion */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_device_test_N_packageVersion,
        y_device_test_part1_part1Version_packageVersion_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /part1/part1Version/packageValid */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_device_test_N_packageValid,
        y_device_test_part1_part1Version_packageValid_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* y_device_test_part1_part1Version_mro */


/********************************************************************
* FUNCTION y_device_test_part1_permission1Information_permission1s_id_get
* 
* Get database object callback
* Path: /part1/permission1Information/permission1s/id
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_permission1Information_permission1s_id_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    uint32 id;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_permission1Information_permission1s_id_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_permission1Information_permission1s_id_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the id var here, change zero */
    id = 0;
    VAL_UINT(dstval) = id;

    return res;

} /* y_device_test_part1_permission1Information_permission1s_id_get */


/********************************************************************
* FUNCTION y_device_test_part1_permission1Information_permission1s_name_get
* 
* Get database object callback
* Path: /part1/permission1Information/permission1s/name
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_permission1Information_permission1s_name_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *name;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_permission1Information_permission1s_name_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_permission1Information_permission1s_name_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the name var here, change EMPTY_STRING */
    name = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        name);

    return res;

} /* y_device_test_part1_permission1Information_permission1s_name_get */


/********************************************************************
* FUNCTION y_device_test_part1_permission1Information_permission1s_quantity_get
* 
* Get database object callback
* Path: /part1/permission1Information/permission1s/quantity
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_permission1Information_permission1s_quantity_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    uint32 quantity;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_permission1Information_permission1s_quantity_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_permission1Information_permission1s_quantity_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the quantity var here, change zero */
    quantity = 0;
    VAL_UINT(dstval) = quantity;

    return res;

} /* y_device_test_part1_permission1Information_permission1s_quantity_get */


/********************************************************************
* FUNCTION y_device_test_part1_permission1Information_permission1s_typeOfPermission1_get
* 
* Get database object callback
* Path: /part1/permission1Information/permission1s/typeOfPermission1
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_permission1Information_permission1s_typeOfPermission1_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *typeOfPermission1;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_permission1Information_permission1s_typeOfPermission1_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_permission1Information_permission1s_typeOfPermission1_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the typeOfPermission1 var here, change enum */
    typeOfPermission1 = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        typeOfPermission1);

    return res;

} /* y_device_test_part1_permission1Information_permission1s_typeOfPermission1_get */


/********************************************************************
* FUNCTION y_device_test_part1_permission1Information_permission1s_timeUntilExpiry_get
* 
* Get database object callback
* Path: /part1/permission1Information/permission1s/timeUntilExpiry
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_permission1Information_permission1s_timeUntilExpiry_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    uint32 timeUntilExpiry;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_permission1Information_permission1s_timeUntilExpiry_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_permission1Information_permission1s_timeUntilExpiry_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the timeUntilExpiry var here, change zero */
    timeUntilExpiry = 0;
    VAL_UINT(dstval) = timeUntilExpiry;

    return res;

} /* y_device_test_part1_permission1Information_permission1s_timeUntilExpiry_get */


/********************************************************************
* FUNCTION y_device_test_part1_permission1Information_permission1s_permissionActive_get
* 
* Get database object callback
* Path: /part1/permission1Information/permission1s/permissionActive
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_permission1Information_permission1s_permissionActive_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    boolean permissionActive;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_permission1Information_permission1s_permissionActive_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_permission1Information_permission1s_permissionActive_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the permissionActive var here, change TRUE if needed */
    permissionActive = TRUE;VAL_BOOL(dstval) = permissionActive;

    return res;

} /* y_device_test_part1_permission1Information_permission1s_permissionActive_get */


/********************************************************************
* FUNCTION y_device_test_part1_permission1Information_mro
* 
* Make read-only child nodes
* Path: /part1/permission1Information
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_permission1Information_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_permission1Information_mro";
    cbLog.addCallback("device_test", cbData);

    /* container permission1Information not handled!!! */

    return res;

} /* y_device_test_part1_permission1Information_mro */


/********************************************************************
* FUNCTION y_device_test_part1_notificationListeners_statusListeners_edit
* 
* Edit database object callback
* Path: /part1/notificationListeners/statusListeners
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_notificationListeners_statusListeners_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_notificationListeners_statusListeners_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_notificationListeners_statusListeners_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_notificationListeners_statusListeners_edit */


/********************************************************************
* FUNCTION y_device_test_part1_notificationListeners_snmpTrapListeners_edit
* 
* Edit database object callback
* Path: /part1/notificationListeners/snmpTrapListeners
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_notificationListeners_snmpTrapListeners_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_notificationListeners_snmpTrapListeners_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_notificationListeners_snmpTrapListeners_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_notificationListeners_snmpTrapListeners_edit */


/********************************************************************
* FUNCTION y_device_test_part1_notificationListeners_redundantPart1_ipAddress_edit
* 
* Edit database object callback
* Path: /part1/notificationListeners/redundantPart1/ipAddress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_notificationListeners_redundantPart1_ipAddress_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_notificationListeners_redundantPart1_ipAddress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_notificationListeners_redundantPart1_ipAddress_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_notificationListeners_redundantPart1_ipAddress_edit */


/********************************************************************
* FUNCTION y_device_test_part1_notificationListeners_redundantPart1_destinationProfile_edit
* 
* Edit database object callback
* Path: /part1/notificationListeners/redundantPart1/destinationProfile
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_notificationListeners_redundantPart1_destinationProfile_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_notificationListeners_redundantPart1_destinationProfile_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_notificationListeners_redundantPart1_destinationProfile_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_notificationListeners_redundantPart1_destinationProfile_edit */


/********************************************************************
* FUNCTION y_device_test_part1_notificationListeners_redundantPart1_echoConfiguration_edit
* 
* Edit database object callback
* Path: /part1/notificationListeners/redundantPart1/echoConfiguration
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_notificationListeners_redundantPart1_echoConfiguration_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_notificationListeners_redundantPart1_echoConfiguration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_notificationListeners_redundantPart1_echoConfiguration_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_notificationListeners_redundantPart1_echoConfiguration_edit */


/********************************************************************
* FUNCTION y_device_test_part1_notificationListeners_redundantPart1_edit
* 
* Edit database object callback
* Path: /part1/notificationListeners/redundantPart1
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_notificationListeners_redundantPart1_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_notificationListeners_redundantPart1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_notificationListeners_redundantPart1_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_notificationListeners_redundantPart1_edit */


/********************************************************************
* FUNCTION y_device_test_part1_notificationListeners_edit
* 
* Edit database object callback
* Path: /part1/notificationListeners
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_notificationListeners_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_notificationListeners_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_notificationListeners_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_notificationListeners_edit */


/********************************************************************
* FUNCTION y_device_test_part1_resourceNode_id_edit
* 
* Edit database object callback
* Path: /part1/resourceNode/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_resourceNode_id_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_resourceNode_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_resourceNode_id_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_resourceNode_id_edit */


/********************************************************************
* FUNCTION y_device_test_part1_resourceNode_resourceType_edit
* 
* Edit database object callback
* Path: /part1/resourceNode/resourceType
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_resourceNode_resourceType_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_resourceNode_resourceType_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_resourceNode_resourceType_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_resourceNode_resourceType_edit */


/********************************************************************
* FUNCTION y_device_test_part1_resourceNode_configuration_edit
* 
* Edit database object callback
* Path: /part1/resourceNode/configuration
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_resourceNode_configuration_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_resourceNode_configuration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_resourceNode_configuration_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_resourceNode_configuration_edit */


/********************************************************************
* FUNCTION y_device_test_part1_resourceNode_statusConfig_edit
* 
* Edit database object callback
* Path: /part1/resourceNode/statusConfig
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_resourceNode_statusConfig_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_resourceNode_statusConfig_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_resourceNode_statusConfig_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_resourceNode_statusConfig_edit */


/********************************************************************
* FUNCTION y_device_test_part1_resourceNode_alarmConfig_edit
* 
* Edit database object callback
* Path: /part1/resourceNode/alarmConfig
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_resourceNode_alarmConfig_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_resourceNode_alarmConfig_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_resourceNode_alarmConfig_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_resourceNode_alarmConfig_edit */


/********************************************************************
* FUNCTION y_device_test_part1_resourceNode_physicalPath_edit
* 
* Edit database object callback
* Path: /part1/resourceNode/physicalPath
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_resourceNode_physicalPath_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_resourceNode_physicalPath_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_resourceNode_physicalPath_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_resourceNode_physicalPath_edit */


/********************************************************************
* FUNCTION y_device_test_part1_resourceNode_edit
* 
* Edit database object callback
* Path: /part1/resourceNode
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_resourceNode_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_resourceNode_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_resourceNode_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_resourceNode_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_id_edit
* 
* Edit database object callback
* Path: /part1/socket1/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_id_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_id_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_id_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_id_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/id
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_id_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    uint32 id;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_id_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_id_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the id var here, change zero */
    id = 0;
    VAL_UINT(dstval) = id;

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_id_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_name_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/name
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_name_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *name;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_name_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_name_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the name var here, change EMPTY_STRING */
    name = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        name);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_name_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_sNumber_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/sNumber
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_sNumber_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *sNumber;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_sNumber_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_sNumber_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the sNumber var here, change EMPTY_STRING */
    sNumber = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        sNumber);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_sNumber_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_packageVersion_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/packageVersion
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_packageVersion_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *packageVersion;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_packageVersion_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_packageVersion_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the packageVersion var here, change EMPTY_STRING */
    packageVersion = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        packageVersion);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_packageVersion_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_packageValid_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/packageValid
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_packageValid_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    boolean packageValid;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_packageValid_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_packageValid_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the packageValid var here, change TRUE if needed */
    packageValid = TRUE;VAL_BOOL(dstval) = packageValid;

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_packageValid_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_pcbModificationState_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/pcbModificationState
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_pcbModificationState_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *pcbModificationState;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_pcbModificationState_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_pcbModificationState_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the pcbModificationState var here, change EMPTY_STRING */
    pcbModificationState = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        pcbModificationState);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_pcbModificationState_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_serialNumber_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/serialNumber
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_serialNumber_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *serialNumber;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_serialNumber_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_serialNumber_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the serialNumber var here, change EMPTY_STRING */
    serialNumber = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        serialNumber);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_serialNumber_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_version_id_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/version/id
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_version_id_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    uint32 id;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_version_id_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_version_id_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the id var here, change zero */
    id = 0;
    VAL_UINT(dstval) = id;

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_version_id_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_version_itemDescription_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/version/itemDescription
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_version_itemDescription_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *itemDescription;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_version_itemDescription_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_version_itemDescription_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the itemDescription var here, change EMPTY_STRING */
    itemDescription = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        itemDescription);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_version_itemDescription_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_version_versionNumber_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/version/versionNumber
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_version_versionNumber_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *versionNumber;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_version_versionNumber_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_version_versionNumber_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the versionNumber var here, change EMPTY_STRING */
    versionNumber = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        versionNumber);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_version_versionNumber_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_version_itemType_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/version/itemType
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_version_itemType_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *itemType;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_version_itemType_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_version_itemType_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the itemType var here, change enum */
    itemType = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        itemType);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_version_itemType_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_version_valid_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/version/valid
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_version_valid_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    boolean valid;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_version_valid_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_version_valid_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the valid var here, change TRUE if needed */
    valid = TRUE;VAL_BOOL(dstval) = valid;

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_version_valid_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_id_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/id
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_id_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    uint32 id;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_id_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_id_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the id var here, change zero */
    id = 0;
    VAL_UINT(dstval) = id;

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_id_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_name_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/name
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_name_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *name;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_name_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_name_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the name var here, change EMPTY_STRING */
    name = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        name);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_name_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_sNumber_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/sNumber
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_sNumber_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *sNumber;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_sNumber_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_sNumber_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the sNumber var here, change EMPTY_STRING */
    sNumber = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        sNumber);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_sNumber_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageVersion_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/packageVersion
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageVersion_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *packageVersion;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageVersion_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageVersion_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the packageVersion var here, change EMPTY_STRING */
    packageVersion = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        packageVersion);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageVersion_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageValid_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/packageValid
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageValid_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    boolean packageValid;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageValid_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageValid_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the packageValid var here, change TRUE if needed */
    packageValid = TRUE;VAL_BOOL(dstval) = packageValid;

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_packageValid_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_pcbModificationState_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/pcbModificationState
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_pcbModificationState_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *pcbModificationState;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_pcbModificationState_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_pcbModificationState_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the pcbModificationState var here, change EMPTY_STRING */
    pcbModificationState = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        pcbModificationState);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_pcbModificationState_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_serialNumber_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/serialNumber
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_serialNumber_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *serialNumber;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_serialNumber_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_serialNumber_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the serialNumber var here, change EMPTY_STRING */
    serialNumber = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        serialNumber);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_serialNumber_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_id_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/version/id
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_id_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    uint32 id;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_id_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_id_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the id var here, change zero */
    id = 0;
    VAL_UINT(dstval) = id;

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_id_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemDescription_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/version/itemDescription
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemDescription_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *itemDescription;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemDescription_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemDescription_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the itemDescription var here, change EMPTY_STRING */
    itemDescription = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        itemDescription);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemDescription_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_versionNumber_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/version/versionNumber
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_versionNumber_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *versionNumber;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_versionNumber_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_versionNumber_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the versionNumber var here, change EMPTY_STRING */
    versionNumber = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        versionNumber);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_versionNumber_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemType_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/version/itemType
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemType_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    const xmlChar *itemType;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemType_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemType_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the itemType var here, change enum */
    itemType = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        itemType);

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_itemType_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_valid_get
* 
* Get database object callback
* Path: /part1/socket1/socket1Version/part2/daughterPart2/version/valid
* Fill in 'dstval' contents
* TBD: automatic get-callback registration
* FOR NOW: use agt_make_virtual_leaf to 
* register this get callback fn
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_valid_get (
        ses_cb_t *scb,
        getcb_mode_t cbmode,
        const val_value_t *virval,
        val_value_t *dstval)
{
    status_t res;
    boolean valid;

    res = NO_ERR;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_valid_get callback");
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_valid_get";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the valid var here, change TRUE if needed */
    valid = TRUE;VAL_BOOL(dstval) = valid;

    return res;

} /* y_device_test_part1_socket1_socket1Version_part2_daughterPart2_version_valid_get */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_socket1Version_mro
* 
* Make read-only child nodes
* Path: /part1/socket1/socket1Version
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_socket1Version_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_socket1Version_mro";
    cbLog.addCallback("device_test", cbData);

    /* container socket1Version not handled!!! */

    return res;

} /* y_device_test_part1_socket1_socket1Version_mro */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_resourceNode_id_edit
* 
* Edit database object callback
* Path: /part1/socket1/resourceNode/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_resourceNode_id_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_resourceNode_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_resourceNode_id_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_resourceNode_id_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_resourceNode_resourceType_edit
* 
* Edit database object callback
* Path: /part1/socket1/resourceNode/resourceType
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_resourceNode_resourceType_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_resourceNode_resourceType_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_resourceNode_resourceType_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_resourceNode_resourceType_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_resourceNode_configuration_edit
* 
* Edit database object callback
* Path: /part1/socket1/resourceNode/configuration
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_resourceNode_configuration_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_resourceNode_configuration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_resourceNode_configuration_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_resourceNode_configuration_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_resourceNode_statusConfig_edit
* 
* Edit database object callback
* Path: /part1/socket1/resourceNode/statusConfig
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_resourceNode_statusConfig_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_resourceNode_statusConfig_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_resourceNode_statusConfig_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_resourceNode_statusConfig_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_resourceNode_alarmConfig_edit
* 
* Edit database object callback
* Path: /part1/socket1/resourceNode/alarmConfig
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_resourceNode_alarmConfig_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_resourceNode_alarmConfig_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_resourceNode_alarmConfig_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_resourceNode_alarmConfig_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_resourceNode_physicalPath_edit
* 
* Edit database object callback
* Path: /part1/socket1/resourceNode/physicalPath
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_resourceNode_physicalPath_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_resourceNode_physicalPath_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_resourceNode_physicalPath_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_resourceNode_physicalPath_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_resourceNode_edit
* 
* Edit database object callback
* Path: /part1/socket1/resourceNode
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_resourceNode_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_resourceNode_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_resourceNode_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_resourceNode_edit */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_mro
* 
* Make read-only child nodes
* Path: /part1/socket1
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_mro";
    cbLog.addCallback("device_test", cbData);

    res = agt_add_container(
        y_device_test_M_device_test,
        y_device_test_N_socket1Version,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = y_device_test_part1_socket1_socket1Version_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* y_device_test_part1_socket1_mro */


/********************************************************************
* FUNCTION y_device_test_part1_socket1_edit
* 
* Edit database object callback
* Path: /part1/socket1
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_socket1_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_socket1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_socket1_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = y_device_test_part1_socket1_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_socket1_edit */


/********************************************************************
* FUNCTION y_device_test_part1_identification_unitLocation_edit
* 
* Edit database object callback
* Path: /part1/identification/unitLocation
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_identification_unitLocation_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_identification_unitLocation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_identification_unitLocation_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_identification_unitLocation_edit */


/********************************************************************
* FUNCTION y_device_test_part1_identification_unitName_edit
* 
* Edit database object callback
* Path: /part1/identification/unitName
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_identification_unitName_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_identification_unitName_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_identification_unitName_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_identification_unitName_edit */


/********************************************************************
* FUNCTION y_device_test_part1_identification_edit
* 
* Edit database object callback
* Path: /part1/identification
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_identification_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_identification_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_identification_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_identification_edit */


/********************************************************************
* FUNCTION y_device_test_part1_mro
* 
* Make read-only child nodes
* Path: /part1
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_mro";
    cbLog.addCallback("device_test", cbData);

    res = agt_add_container(
        y_device_test_M_device_test,
        y_device_test_N_part1Version,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = y_device_test_part1_part1Version_mro(childval);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_add_container(
        y_device_test_M_device_test,
        y_device_test_N_permission1Information,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = y_device_test_part1_permission1Information_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* y_device_test_part1_mro */


/********************************************************************
* FUNCTION y_device_test_part1_edit
* 
* Edit database object callback
* Path: /part1
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_part1_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_part1_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_part1_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }

        if (res == NO_ERR) {
            res = agt_check_cache(
                &part1_val,
                newval,
                curval,
                editop);
        }
        
        if (res == NO_ERR && curval == NULL) {
            res = y_device_test_part1_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_part1_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_activeProfile_edit
* 
* Edit database object callback
* Path: /xpo/activeProfile
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_activeProfile_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_activeProfile_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_activeProfile_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_activeProfile_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_id_edit
* 
* Edit database object callback
* Path: /xpo/profile/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_id_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_id_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_id_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_id_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_id_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_id_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_id_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_resourceNode_id_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/resourceNode/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_resourceNode_id_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_resourceNode_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_resourceNode_id_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_resourceNode_id_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_resourceNode_resourceType_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/resourceNode/resourceType
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_resourceNode_resourceType_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_resourceNode_resourceType_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_resourceNode_resourceType_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_resourceNode_resourceType_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_resourceNode_configuration_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/resourceNode/configuration
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_resourceNode_configuration_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_resourceNode_configuration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_resourceNode_configuration_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_resourceNode_configuration_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_resourceNode_statusConfig_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/resourceNode/statusConfig
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_resourceNode_statusConfig_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_resourceNode_statusConfig_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_resourceNode_statusConfig_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_resourceNode_statusConfig_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_resourceNode_alarmConfig_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/resourceNode/alarmConfig
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_resourceNode_alarmConfig_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_resourceNode_alarmConfig_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_resourceNode_alarmConfig_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_resourceNode_alarmConfig_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_resourceNode_physicalPath_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/resourceNode/physicalPath
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_resourceNode_physicalPath_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_resourceNode_physicalPath_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_resourceNode_physicalPath_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_resourceNode_physicalPath_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_resourceNode_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/resourceNode
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_resourceNode_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_resourceNode_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_resourceNode_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_resourceNode_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_connection_id_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/connection/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_connection_id_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_connection_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_connection_id_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_connection_id_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_connection_sourceId_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/connection/sourceId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_connection_sourceId_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_connection_sourceId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_connection_sourceId_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_connection_sourceId_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_connection_sourcePinId_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/connection/sourcePinId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_connection_sourcePinId_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_connection_sourcePinId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_connection_sourcePinId_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_connection_sourcePinId_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_connection_destinationId_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/connection/destinationId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_connection_destinationId_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_connection_destinationId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_connection_destinationId_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_connection_destinationId_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_connection_destinationPinId_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/connection/destinationPinId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_connection_destinationPinId_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_connection_destinationPinId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_connection_destinationPinId_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_connection_destinationPinId_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_connection_bitrate_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/connection/bitrate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_connection_bitrate_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_connection_bitrate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_connection_bitrate_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_connection_bitrate_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_connection_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream/connection
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_connection_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_connection_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_connection_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_connection_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_stream_edit
* 
* Edit database object callback
* Path: /xpo/profile/stream
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_stream_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_stream_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_stream_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_stream_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_streamConnection_id_edit
* 
* Edit database object callback
* Path: /xpo/profile/streamConnection/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_streamConnection_id_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_streamConnection_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_streamConnection_id_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_streamConnection_id_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_streamConnection_sourceId_edit
* 
* Edit database object callback
* Path: /xpo/profile/streamConnection/sourceId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_streamConnection_sourceId_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_streamConnection_sourceId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_streamConnection_sourceId_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_streamConnection_sourceId_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_streamConnection_sourcePinId_edit
* 
* Edit database object callback
* Path: /xpo/profile/streamConnection/sourcePinId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_streamConnection_sourcePinId_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_streamConnection_sourcePinId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_streamConnection_sourcePinId_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_streamConnection_sourcePinId_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_streamConnection_destinationId_edit
* 
* Edit database object callback
* Path: /xpo/profile/streamConnection/destinationId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_streamConnection_destinationId_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_streamConnection_destinationId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_streamConnection_destinationId_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_streamConnection_destinationId_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_streamConnection_destinationPinId_edit
* 
* Edit database object callback
* Path: /xpo/profile/streamConnection/destinationPinId
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_streamConnection_destinationPinId_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_streamConnection_destinationPinId_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_streamConnection_destinationPinId_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_streamConnection_destinationPinId_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_streamConnection_bitrate_edit
* 
* Edit database object callback
* Path: /xpo/profile/streamConnection/bitrate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_streamConnection_bitrate_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_streamConnection_bitrate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_streamConnection_bitrate_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_streamConnection_bitrate_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_streamConnection_edit
* 
* Edit database object callback
* Path: /xpo/profile/streamConnection
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_streamConnection_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_streamConnection_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_streamConnection_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_streamConnection_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_profile_edit
* 
* Edit database object callback
* Path: /xpo/profile
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_profile_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_profile_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    /* remove the next line if newval is used */
    (void)newval;

    /* remove the next line if curval is used */
    (void)curval;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_profile_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_profile_edit */


/********************************************************************
* FUNCTION y_device_test_xpo_edit
* 
* Edit database object callback
* Path: /xpo
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_xpo_edit (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        agt_cbtyp_t cbtyp,
        op_editop_t editop,
        val_value_t *newval,
        val_value_t *curval)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;
    if (LOGDEBUG) {
        log_debug("\nEnter y_device_test_xpo_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_xpo_edit";

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        cbData.cbType = "validate";
        cbLog.addCallback("device_test", cbData);
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        cbData.cbType = "apply";
        cbLog.addCallback("device_test", cbData);
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        cbData.cbType = "commit";
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            cbData.cbPhase = "load";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_MERGE:
            cbData.cbPhase = "merge";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_REPLACE:
            cbData.cbPhase = "replace";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_CREATE:
            cbData.cbPhase = "create";
            cbLog.addCallback("device_test", cbData);
            break;
        case OP_EDITOP_DELETE:
            cbData.cbPhase = "delete";
            cbLog.addCallback("device_test", cbData);
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }

        if (res == NO_ERR) {
            res = agt_check_cache(
                &xpo_val,
                newval,
                curval,
                editop);
        }
        
        break;
    case AGT_CB_ROLLBACK:
        cbData.cbType = "rollback";
        cbLog.addCallback("device_test", cbData);
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_xpo_edit */


/********************************************************************
* FUNCTION y_device_test_get_resource_types_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_resource_types_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_resource_types_validate";
    cbLog.addCallback("device_test", cbData);

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_get_resource_types_validate */


/********************************************************************
* FUNCTION y_device_test_get_resource_types_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_resource_types_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_resource_types_invoke";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if msg is used */
    (void)msg;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_get_resource_types_invoke */


/********************************************************************
* FUNCTION y_device_test_get_resource_capability_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_resource_capability_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *resource_type_val;
    uint32 resource_type;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_resource_capability_validate";
    cbLog.addCallback("device_test", cbData);

    resource_type_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_resource_type);
    if (resource_type_val != NULL && resource_type_val->res == NO_ERR) {
        resource_type = VAL_UINT(resource_type_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_get_resource_capability_validate */


/********************************************************************
* FUNCTION y_device_test_get_resource_capability_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_resource_capability_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *resource_type_val;
    uint32 resource_type;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_resource_capability_invoke";
    cbLog.addCallback("device_test", cbData);

    resource_type_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_resource_type);
    if (resource_type_val != NULL && resource_type_val->res == NO_ERR) {
        resource_type = VAL_UINT(resource_type_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_get_resource_capability_invoke */


/********************************************************************
* FUNCTION y_device_test_get_dictionary_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_dictionary_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *language_val;
    const xmlChar *language;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_dictionary_validate";
    cbLog.addCallback("device_test", cbData);

    language_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_language);
    if (language_val != NULL && language_val->res == NO_ERR) {
        language = VAL_STRING(language_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_get_dictionary_validate */


/********************************************************************
* FUNCTION y_device_test_get_dictionary_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_dictionary_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *language_val;
    const xmlChar *language;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_dictionary_invoke";
    cbLog.addCallback("device_test", cbData);

    language_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_language);
    if (language_val != NULL && language_val->res == NO_ERR) {
        language = VAL_STRING(language_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_get_dictionary_invoke */


/********************************************************************
* FUNCTION y_device_test_get_dictionary_reference_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_dictionary_reference_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *language_val;
    val_value_t *referenceId_val;
    const xmlChar *language;
    uint32 referenceId;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_dictionary_reference_validate";
    cbLog.addCallback("device_test", cbData);

    language_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_language);
    if (language_val != NULL && language_val->res == NO_ERR) {
        language = VAL_STRING(language_val);
    }

    referenceId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_referenceId);
    if (referenceId_val != NULL && referenceId_val->res == NO_ERR) {
        referenceId = VAL_UINT(referenceId_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_get_dictionary_reference_validate */


/********************************************************************
* FUNCTION y_device_test_get_dictionary_reference_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_dictionary_reference_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *language_val;
    val_value_t *referenceId_val;
    const xmlChar *language;
    uint32 referenceId;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_dictionary_reference_invoke";
    cbLog.addCallback("device_test", cbData);

    language_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_language);
    if (language_val != NULL && language_val->res == NO_ERR) {
        language = VAL_STRING(language_val);
    }

    referenceId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_referenceId);
    if (referenceId_val != NULL && referenceId_val->res == NO_ERR) {
        referenceId = VAL_UINT(referenceId_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_get_dictionary_reference_invoke */


/********************************************************************
* FUNCTION y_device_test_copy_profile_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_copy_profile_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *sourceProfileId_val;
    val_value_t *destinationProfileId_val;
    val_value_t *replaceExisting_val;
    uint32 sourceProfileId;
    uint32 destinationProfileId;
    boolean replaceExisting;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_copy_profile_validate";
    cbLog.addCallback("device_test", cbData);

    sourceProfileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_sourceProfileId);
    if (sourceProfileId_val != NULL && sourceProfileId_val->res == NO_ERR) {
        sourceProfileId = VAL_UINT(sourceProfileId_val);
    }

    destinationProfileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_destinationProfileId);
    if (destinationProfileId_val != NULL && destinationProfileId_val->res == NO_ERR) {
        destinationProfileId = VAL_UINT(destinationProfileId_val);
    }

    replaceExisting_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_replaceExisting);
    if (replaceExisting_val != NULL && replaceExisting_val->res == NO_ERR) {
        replaceExisting = VAL_BOOL(replaceExisting_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_copy_profile_validate */


/********************************************************************
* FUNCTION y_device_test_copy_profile_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_copy_profile_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *sourceProfileId_val;
    val_value_t *destinationProfileId_val;
    val_value_t *replaceExisting_val;
    uint32 sourceProfileId;
    uint32 destinationProfileId;
    boolean replaceExisting;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_copy_profile_invoke";
    cbLog.addCallback("device_test", cbData);

    sourceProfileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_sourceProfileId);
    if (sourceProfileId_val != NULL && sourceProfileId_val->res == NO_ERR) {
        sourceProfileId = VAL_UINT(sourceProfileId_val);
    }

    destinationProfileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_destinationProfileId);
    if (destinationProfileId_val != NULL && destinationProfileId_val->res == NO_ERR) {
        destinationProfileId = VAL_UINT(destinationProfileId_val);
    }

    replaceExisting_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_replaceExisting);
    if (replaceExisting_val != NULL && replaceExisting_val->res == NO_ERR) {
        replaceExisting = VAL_BOOL(replaceExisting_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_copy_profile_invoke */


/********************************************************************
* FUNCTION y_device_test_copy_stream_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_copy_stream_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *sourceProfileId_val;
    val_value_t *sourceStreamId_val;
    val_value_t *destinationProfileId_val;
    val_value_t *destintionStreamIdList_val;
    val_value_t *replaceExisting_val;
    uint32 sourceProfileId;
    uint32 sourceStreamId;
    uint32 destinationProfileId;
    uint32 destintionStreamIdList;
    boolean replaceExisting;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_copy_stream_validate";
    cbLog.addCallback("device_test", cbData);

    sourceProfileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_sourceProfileId);
    if (sourceProfileId_val != NULL && sourceProfileId_val->res == NO_ERR) {
        sourceProfileId = VAL_UINT(sourceProfileId_val);
    }

    sourceStreamId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_sourceStreamId);
    if (sourceStreamId_val != NULL && sourceStreamId_val->res == NO_ERR) {
        sourceStreamId = VAL_UINT(sourceStreamId_val);
    }

    destinationProfileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_destinationProfileId);
    if (destinationProfileId_val != NULL && destinationProfileId_val->res == NO_ERR) {
        destinationProfileId = VAL_UINT(destinationProfileId_val);
    }

    destintionStreamIdList_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_destintionStreamIdList);
    if (destintionStreamIdList_val != NULL && destintionStreamIdList_val->res == NO_ERR) {
        destintionStreamIdList = VAL_UINT(destintionStreamIdList_val);
    }

    replaceExisting_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_replaceExisting);
    if (replaceExisting_val != NULL && replaceExisting_val->res == NO_ERR) {
        replaceExisting = VAL_BOOL(replaceExisting_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_copy_stream_validate */


/********************************************************************
* FUNCTION y_device_test_copy_stream_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_copy_stream_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *sourceProfileId_val;
    val_value_t *sourceStreamId_val;
    val_value_t *destinationProfileId_val;
    val_value_t *destintionStreamIdList_val;
    val_value_t *replaceExisting_val;
    uint32 sourceProfileId;
    uint32 sourceStreamId;
    uint32 destinationProfileId;
    uint32 destintionStreamIdList;
    boolean replaceExisting;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_copy_stream_invoke";
    cbLog.addCallback("device_test", cbData);

    sourceProfileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_sourceProfileId);
    if (sourceProfileId_val != NULL && sourceProfileId_val->res == NO_ERR) {
        sourceProfileId = VAL_UINT(sourceProfileId_val);
    }

    sourceStreamId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_sourceStreamId);
    if (sourceStreamId_val != NULL && sourceStreamId_val->res == NO_ERR) {
        sourceStreamId = VAL_UINT(sourceStreamId_val);
    }

    destinationProfileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_destinationProfileId);
    if (destinationProfileId_val != NULL && destinationProfileId_val->res == NO_ERR) {
        destinationProfileId = VAL_UINT(destinationProfileId_val);
    }

    destintionStreamIdList_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_destintionStreamIdList);
    if (destintionStreamIdList_val != NULL && destintionStreamIdList_val->res == NO_ERR) {
        destintionStreamIdList = VAL_UINT(destintionStreamIdList_val);
    }

    replaceExisting_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_replaceExisting);
    if (replaceExisting_val != NULL && replaceExisting_val->res == NO_ERR) {
        replaceExisting = VAL_BOOL(replaceExisting_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_copy_stream_invoke */


/********************************************************************
* FUNCTION y_device_test_modify_stream_config_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_modify_stream_config_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *profileId_val;
    val_value_t *streamIdList_val;
    val_value_t *resourceNodeId_val;
    val_value_t *configBitMask_val;
    val_value_t *configuration_val;
    uint32 profileId;
    uint32 streamIdList;
    uint32 resourceNodeId;
    const xmlChar *configBitMask;
    const xmlChar *configuration;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_modify_stream_config_validate";
    cbLog.addCallback("device_test", cbData);

    profileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_profileId);
    if (profileId_val != NULL && profileId_val->res == NO_ERR) {
        profileId = VAL_UINT(profileId_val);
    }

    streamIdList_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_streamIdList);
    if (streamIdList_val != NULL && streamIdList_val->res == NO_ERR) {
        streamIdList = VAL_UINT(streamIdList_val);
    }

    resourceNodeId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_resourceNodeId);
    if (resourceNodeId_val != NULL && resourceNodeId_val->res == NO_ERR) {
        resourceNodeId = VAL_UINT(resourceNodeId_val);
    }

    configBitMask_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_configBitMask);
    if (configBitMask_val != NULL && configBitMask_val->res == NO_ERR) {
        configBitMask = VAL_BINARY(configBitMask_val);
    }

    configuration_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_configuration);
    if (configuration_val != NULL && configuration_val->res == NO_ERR) {
        configuration = VAL_BINARY(configuration_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_modify_stream_config_validate */


/********************************************************************
* FUNCTION y_device_test_modify_stream_config_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_modify_stream_config_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *profileId_val;
    val_value_t *streamIdList_val;
    val_value_t *resourceNodeId_val;
    val_value_t *configBitMask_val;
    val_value_t *configuration_val;
    uint32 profileId;
    uint32 streamIdList;
    uint32 resourceNodeId;
    const xmlChar *configBitMask;
    const xmlChar *configuration;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_modify_stream_config_invoke";
    cbLog.addCallback("device_test", cbData);

    profileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_profileId);
    if (profileId_val != NULL && profileId_val->res == NO_ERR) {
        profileId = VAL_UINT(profileId_val);
    }

    streamIdList_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_streamIdList);
    if (streamIdList_val != NULL && streamIdList_val->res == NO_ERR) {
        streamIdList = VAL_UINT(streamIdList_val);
    }

    resourceNodeId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_resourceNodeId);
    if (resourceNodeId_val != NULL && resourceNodeId_val->res == NO_ERR) {
        resourceNodeId = VAL_UINT(resourceNodeId_val);
    }

    configBitMask_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_configBitMask);
    if (configBitMask_val != NULL && configBitMask_val->res == NO_ERR) {
        configBitMask = VAL_BINARY(configBitMask_val);
    }

    configuration_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_configuration);
    if (configuration_val != NULL && configuration_val->res == NO_ERR) {
        configuration = VAL_BINARY(configuration_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_modify_stream_config_invoke */


/********************************************************************
* FUNCTION y_device_test_modify_stream_alarm_config_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_modify_stream_alarm_config_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *profileId_val;
    val_value_t *streamIdList_val;
    val_value_t *resourceNodeId_val;
    val_value_t *alarmConfigBitMask_val;
    val_value_t *alarmConfig_val;
    uint32 profileId;
    uint32 streamIdList;
    uint32 resourceNodeId;
    const xmlChar *alarmConfigBitMask;
    const xmlChar *alarmConfig;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_modify_stream_alarm_config_validate";
    cbLog.addCallback("device_test", cbData);

    profileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_profileId);
    if (profileId_val != NULL && profileId_val->res == NO_ERR) {
        profileId = VAL_UINT(profileId_val);
    }

    streamIdList_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_streamIdList);
    if (streamIdList_val != NULL && streamIdList_val->res == NO_ERR) {
        streamIdList = VAL_UINT(streamIdList_val);
    }

    resourceNodeId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_resourceNodeId);
    if (resourceNodeId_val != NULL && resourceNodeId_val->res == NO_ERR) {
        resourceNodeId = VAL_UINT(resourceNodeId_val);
    }

    alarmConfigBitMask_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_alarmConfigBitMask);
    if (alarmConfigBitMask_val != NULL && alarmConfigBitMask_val->res == NO_ERR) {
        alarmConfigBitMask = VAL_BINARY(alarmConfigBitMask_val);
    }

    alarmConfig_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_alarmConfig);
    if (alarmConfig_val != NULL && alarmConfig_val->res == NO_ERR) {
        alarmConfig = VAL_BINARY(alarmConfig_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_modify_stream_alarm_config_validate */


/********************************************************************
* FUNCTION y_device_test_modify_stream_alarm_config_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_modify_stream_alarm_config_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *profileId_val;
    val_value_t *streamIdList_val;
    val_value_t *resourceNodeId_val;
    val_value_t *alarmConfigBitMask_val;
    val_value_t *alarmConfig_val;
    uint32 profileId;
    uint32 streamIdList;
    uint32 resourceNodeId;
    const xmlChar *alarmConfigBitMask;
    const xmlChar *alarmConfig;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_modify_stream_alarm_config_invoke";
    cbLog.addCallback("device_test", cbData);

    profileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_profileId);
    if (profileId_val != NULL && profileId_val->res == NO_ERR) {
        profileId = VAL_UINT(profileId_val);
    }

    streamIdList_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_streamIdList);
    if (streamIdList_val != NULL && streamIdList_val->res == NO_ERR) {
        streamIdList = VAL_UINT(streamIdList_val);
    }

    resourceNodeId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_resourceNodeId);
    if (resourceNodeId_val != NULL && resourceNodeId_val->res == NO_ERR) {
        resourceNodeId = VAL_UINT(resourceNodeId_val);
    }

    alarmConfigBitMask_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_alarmConfigBitMask);
    if (alarmConfigBitMask_val != NULL && alarmConfigBitMask_val->res == NO_ERR) {
        alarmConfigBitMask = VAL_BINARY(alarmConfigBitMask_val);
    }

    alarmConfig_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_alarmConfig);
    if (alarmConfig_val != NULL && alarmConfig_val->res == NO_ERR) {
        alarmConfig = VAL_BINARY(alarmConfig_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_modify_stream_alarm_config_invoke */


/********************************************************************
* FUNCTION y_device_test_modify_stream_status_config_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_modify_stream_status_config_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *profileId_val;
    val_value_t *streamIdList_val;
    val_value_t *resourceNodeId_val;
    val_value_t *statusConfigBitMask_val;
    val_value_t *statusConfig_val;
    uint32 profileId;
    uint32 streamIdList;
    uint32 resourceNodeId;
    const xmlChar *statusConfigBitMask;
    const xmlChar *statusConfig;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_modify_stream_status_config_validate";
    cbLog.addCallback("device_test", cbData);

    profileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_profileId);
    if (profileId_val != NULL && profileId_val->res == NO_ERR) {
        profileId = VAL_UINT(profileId_val);
    }

    streamIdList_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_streamIdList);
    if (streamIdList_val != NULL && streamIdList_val->res == NO_ERR) {
        streamIdList = VAL_UINT(streamIdList_val);
    }

    resourceNodeId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_resourceNodeId);
    if (resourceNodeId_val != NULL && resourceNodeId_val->res == NO_ERR) {
        resourceNodeId = VAL_UINT(resourceNodeId_val);
    }

    statusConfigBitMask_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_statusConfigBitMask);
    if (statusConfigBitMask_val != NULL && statusConfigBitMask_val->res == NO_ERR) {
        statusConfigBitMask = VAL_BINARY(statusConfigBitMask_val);
    }

    statusConfig_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_statusConfig);
    if (statusConfig_val != NULL && statusConfig_val->res == NO_ERR) {
        statusConfig = VAL_BINARY(statusConfig_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_modify_stream_status_config_validate */


/********************************************************************
* FUNCTION y_device_test_modify_stream_status_config_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_modify_stream_status_config_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *profileId_val;
    val_value_t *streamIdList_val;
    val_value_t *resourceNodeId_val;
    val_value_t *statusConfigBitMask_val;
    val_value_t *statusConfig_val;
    uint32 profileId;
    uint32 streamIdList;
    uint32 resourceNodeId;
    const xmlChar *statusConfigBitMask;
    const xmlChar *statusConfig;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_modify_stream_status_config_invoke";
    cbLog.addCallback("device_test", cbData);

    profileId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_profileId);
    if (profileId_val != NULL && profileId_val->res == NO_ERR) {
        profileId = VAL_UINT(profileId_val);
    }

    streamIdList_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_streamIdList);
    if (streamIdList_val != NULL && streamIdList_val->res == NO_ERR) {
        streamIdList = VAL_UINT(streamIdList_val);
    }

    resourceNodeId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_resourceNodeId);
    if (resourceNodeId_val != NULL && resourceNodeId_val->res == NO_ERR) {
        resourceNodeId = VAL_UINT(resourceNodeId_val);
    }

    statusConfigBitMask_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_statusConfigBitMask);
    if (statusConfigBitMask_val != NULL && statusConfigBitMask_val->res == NO_ERR) {
        statusConfigBitMask = VAL_BINARY(statusConfigBitMask_val);
    }

    statusConfig_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_statusConfig);
    if (statusConfig_val != NULL && statusConfig_val->res == NO_ERR) {
        statusConfig = VAL_BINARY(statusConfig_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_modify_stream_status_config_invoke */


/********************************************************************
* FUNCTION y_device_test_get_status_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_status_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *streamId_val;
    val_value_t *virtualResourceId_val;
    val_value_t *statusId_val;
    uint32 streamId;
    uint32 virtualResourceId;
    uint32 statusId;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_status_validate";
    cbLog.addCallback("device_test", cbData);

    streamId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_streamId);
    if (streamId_val != NULL && streamId_val->res == NO_ERR) {
        streamId = VAL_UINT(streamId_val);
    }

    virtualResourceId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_virtualResourceId);
    if (virtualResourceId_val != NULL && virtualResourceId_val->res == NO_ERR) {
        virtualResourceId = VAL_UINT(virtualResourceId_val);
    }

    statusId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_statusId);
    if (statusId_val != NULL && statusId_val->res == NO_ERR) {
        statusId = VAL_UINT(statusId_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_get_status_validate */


/********************************************************************
* FUNCTION y_device_test_get_status_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_status_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *streamId_val;
    val_value_t *virtualResourceId_val;
    val_value_t *statusId_val;
    uint32 streamId;
    uint32 virtualResourceId;
    uint32 statusId;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_status_invoke";
    cbLog.addCallback("device_test", cbData);

    streamId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_streamId);
    if (streamId_val != NULL && streamId_val->res == NO_ERR) {
        streamId = VAL_UINT(streamId_val);
    }

    virtualResourceId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_virtualResourceId);
    if (virtualResourceId_val != NULL && virtualResourceId_val->res == NO_ERR) {
        virtualResourceId = VAL_UINT(virtualResourceId_val);
    }

    statusId_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_statusId);
    if (statusId_val != NULL && statusId_val->res == NO_ERR) {
        statusId = VAL_UINT(statusId_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_get_status_invoke */


/********************************************************************
* FUNCTION y_device_test_get_time_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_time_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_time_validate";
    cbLog.addCallback("device_test", cbData);

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_get_time_validate */


/********************************************************************
* FUNCTION y_device_test_get_time_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_get_time_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_get_time_invoke";
    cbLog.addCallback("device_test", cbData);

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if msg is used */
    (void)msg;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_get_time_invoke */


/********************************************************************
* FUNCTION y_device_test_set_time_validate
* 
* RPC validation phase
* All YANG constraints have passed at this point.
* Add description-stmt checks in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_set_time_validate (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *errorval;
    const xmlChar *errorstr;
    val_value_t *time_val;
    const xmlChar *time;

    res = NO_ERR;
    errorval = NULL;
    errorstr = NULL;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_set_time_validate";
    cbLog.addCallback("device_test", cbData);

    time_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_time);
    if (time_val != NULL && time_val->res == NO_ERR) {
        time = VAL_STRING(time_val);
    }

    /* if error: set the res, errorstr, and errorval parms */
    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_OPERATION,
            res,
            methnode,
            NCX_NT_STRING,
            errorstr,
            NCX_NT_VAL,
            errorval);
    }
    
    return res;

} /* y_device_test_set_time_validate */


/********************************************************************
* FUNCTION y_device_test_set_time_invoke
* 
* RPC invocation phase
* All constraints have passed at this point.
* Call device instrumentation code in this function.
* 
* INPUTS:
*     see agt/agt_rpc.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    y_device_test_set_time_invoke (
        ses_cb_t *scb,
        rpc_msg_t *msg,
        xml_node_t *methnode)
{
    status_t res;
    val_value_t *time_val;
    const xmlChar *time;

    res = NO_ERR;

    YumaTest::SILCallbackLog& cbLog = YumaTest::SILCallbackLog::getInstance();
    YumaTest::SILCallbackLog::CallbackInfo cbData;
    cbData.cbName = "y_device_test_set_time_invoke";
    cbLog.addCallback("device_test", cbData);

    time_val = val_find_child(
        msg->rpc_input,
        y_device_test_M_device_test,
        y_device_test_N_time);
    if (time_val != NULL && time_val->res == NO_ERR) {
        time = VAL_STRING(time_val);
    }

    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if methnode is used */
    (void)methnode;

    /* invoke your device instrumentation code here */
    
    return res;

} /* y_device_test_set_time_invoke */


/********************************************************************
* FUNCTION y_device_test_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void
    y_device_test_init_static_vars (void)
{
    device_test_mod = NULL;
    part1_obj = NULL;
    xpo_obj = NULL;
    get_resource_types_obj = NULL;
    get_resource_capability_obj = NULL;
    get_dictionary_obj = NULL;
    get_dictionary_reference_obj = NULL;
    copy_profile_obj = NULL;
    copy_stream_obj = NULL;
    modify_stream_config_obj = NULL;
    modify_stream_alarm_config_obj = NULL;
    modify_stream_status_config_obj = NULL;
    get_status_obj = NULL;
    get_time_obj = NULL;
    set_time_obj = NULL;
    part1_val = NULL;
    xpo_val = NULL;

    /* init your static variables here */

} /* y_device_test_init_static_vars */


/********************************************************************
* FUNCTION y_device_test_init
* 
* initialize the device_test server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t
    y_device_test_init (
        const xmlChar *modname,
        const xmlChar *revision)
{
    agt_profile_t *agt_profile;
    status_t res;

    y_device_test_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_device_test_M_device_test)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_device_test_R_device_test)) {
        return ERR_NCX_WRONG_VERSION;
    }

    agt_profile = agt_get_profile();

    res = ncxmod_load_module(
        y_device_test_M_device_test,
        y_device_test_R_device_test,
        &agt_profile->agt_savedevQ,
        &device_test_mod);
    if (res != NO_ERR) {
        return res;
    }

    part1_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_part1);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    xpo_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_xpo);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    get_resource_types_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_get_resource_types);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    get_resource_capability_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_get_resource_capability);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    get_dictionary_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_get_dictionary);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    get_dictionary_reference_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_get_dictionary_reference);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    copy_profile_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_copy_profile);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    copy_stream_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_copy_stream);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    modify_stream_config_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_modify_stream_config);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    modify_stream_alarm_config_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_modify_stream_alarm_config);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    modify_stream_status_config_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_modify_stream_status_config);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    get_status_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_get_status);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    get_time_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_get_time);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    set_time_obj = ncx_find_object(
        device_test_mod,
        y_device_test_N_set_time);
    if (device_test_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    
    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_resource_types,
        AGT_RPC_PH_VALIDATE,
        y_device_test_get_resource_types_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_resource_types,
        AGT_RPC_PH_INVOKE,
        y_device_test_get_resource_types_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_resource_capability,
        AGT_RPC_PH_VALIDATE,
        y_device_test_get_resource_capability_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_resource_capability,
        AGT_RPC_PH_INVOKE,
        y_device_test_get_resource_capability_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_dictionary,
        AGT_RPC_PH_VALIDATE,
        y_device_test_get_dictionary_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_dictionary,
        AGT_RPC_PH_INVOKE,
        y_device_test_get_dictionary_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_dictionary_reference,
        AGT_RPC_PH_VALIDATE,
        y_device_test_get_dictionary_reference_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_dictionary_reference,
        AGT_RPC_PH_INVOKE,
        y_device_test_get_dictionary_reference_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_copy_profile,
        AGT_RPC_PH_VALIDATE,
        y_device_test_copy_profile_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_copy_profile,
        AGT_RPC_PH_INVOKE,
        y_device_test_copy_profile_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_copy_stream,
        AGT_RPC_PH_VALIDATE,
        y_device_test_copy_stream_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_copy_stream,
        AGT_RPC_PH_INVOKE,
        y_device_test_copy_stream_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_config,
        AGT_RPC_PH_VALIDATE,
        y_device_test_modify_stream_config_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_config,
        AGT_RPC_PH_INVOKE,
        y_device_test_modify_stream_config_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_alarm_config,
        AGT_RPC_PH_VALIDATE,
        y_device_test_modify_stream_alarm_config_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_alarm_config,
        AGT_RPC_PH_INVOKE,
        y_device_test_modify_stream_alarm_config_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_status_config,
        AGT_RPC_PH_VALIDATE,
        y_device_test_modify_stream_status_config_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_status_config,
        AGT_RPC_PH_INVOKE,
        y_device_test_modify_stream_status_config_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_status,
        AGT_RPC_PH_VALIDATE,
        y_device_test_get_status_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_status,
        AGT_RPC_PH_INVOKE,
        y_device_test_get_status_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_time,
        AGT_RPC_PH_VALIDATE,
        y_device_test_get_time_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_get_time,
        AGT_RPC_PH_INVOKE,
        y_device_test_get_time_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_set_time,
        AGT_RPC_PH_VALIDATE,
        y_device_test_set_time_validate);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_rpc_register_method(
        y_device_test_M_device_test,
        y_device_test_N_set_time,
        AGT_RPC_PH_INVOKE,
        y_device_test_set_time_invoke);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/identification",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_identification_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/identification/unitLocation",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_identification_unitLocation_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/identification/unitName",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_identification_unitName_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_notificationListeners_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/redundantPart1",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_notificationListeners_redundantPart1_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/redundantPart1/destinationProfile",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_notificationListeners_redundantPart1_destinationProfile_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/redundantPart1/echoConfiguration",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_notificationListeners_redundantPart1_echoConfiguration_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/redundantPart1/ipAddress",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_notificationListeners_redundantPart1_ipAddress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/snmpTrapListeners",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_notificationListeners_snmpTrapListeners_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/statusListeners",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_notificationListeners_statusListeners_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_resourceNode_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/alarmConfig",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_resourceNode_alarmConfig_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/configuration",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_resourceNode_configuration_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/id",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_resourceNode_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/physicalPath",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_resourceNode_physicalPath_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/resourceType",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_resourceNode_resourceType_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/statusConfig",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_resourceNode_statusConfig_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/id",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_resourceNode_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/alarmConfig",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_resourceNode_alarmConfig_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/configuration",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_resourceNode_configuration_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/id",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_resourceNode_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/physicalPath",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_resourceNode_physicalPath_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/resourceType",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_resourceNode_resourceType_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/statusConfig",
        (const xmlChar *)"2011-09-07",
        y_device_test_part1_socket1_resourceNode_statusConfig_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/activeProfile",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_activeProfile_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/id",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_streamConnection_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/bitrate",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_streamConnection_bitrate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/destinationId",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_streamConnection_destinationId_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/destinationPinId",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_streamConnection_destinationPinId_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/id",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_streamConnection_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/sourceId",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_streamConnection_sourceId_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/sourcePinId",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_streamConnection_sourcePinId_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_connection_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/bitrate",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_connection_bitrate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/destinationId",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_connection_destinationId_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/destinationPinId",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_connection_destinationPinId_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/id",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_connection_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/sourceId",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_connection_sourceId_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/sourcePinId",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_connection_sourcePinId_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/id",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_resourceNode_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/alarmConfig",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_resourceNode_alarmConfig_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/configuration",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_resourceNode_configuration_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/id",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_resourceNode_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/physicalPath",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_resourceNode_physicalPath_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/resourceType",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_resourceNode_resourceType_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/statusConfig",
        (const xmlChar *)"2011-09-07",
        y_device_test_xpo_profile_stream_resourceNode_statusConfig_edit);
    if (res != NO_ERR) {
        return res;
    }

    /* put your module initialization code here */
    
    return res;
} /* y_device_test_init */


/********************************************************************
* FUNCTION y_device_test_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t
    y_device_test_init2 (void)
{
    status_t res = NO_ERR;

    part1_val = agt_init_cache(
        y_device_test_M_device_test,
        y_device_test_N_part1,
        &res);
    if (res != NO_ERR) {
        return res;
    }

    xpo_val = agt_init_cache(
        y_device_test_M_device_test,
        y_device_test_N_xpo,
        &res);
    if (res != NO_ERR) {
        return res;
    }

    /* put your init2 code here */

    return res;
} /* y_device_test_init2 */


/********************************************************************
* FUNCTION y_device_test_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void
    y_device_test_cleanup (void)
{
    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_get_resource_types);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_get_resource_capability);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_get_dictionary);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_get_dictionary_reference);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_copy_profile);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_copy_stream);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_config);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_alarm_config);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_modify_stream_status_config);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_get_status);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_get_time);

    agt_rpc_unregister_method(
        y_device_test_M_device_test,
        y_device_test_N_set_time);

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/identification");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/identification/unitLocation");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/identification/unitName");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/redundantPart1");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/redundantPart1/destinationProfile");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/redundantPart1/echoConfiguration");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/redundantPart1/ipAddress");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/snmpTrapListeners");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/notificationListeners/statusListeners");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/alarmConfig");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/configuration");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/id");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/physicalPath");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/resourceType");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/resourceNode/statusConfig");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/id");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/alarmConfig");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/configuration");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/id");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/physicalPath");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/resourceType");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/part1/socket1/resourceNode/statusConfig");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/activeProfile");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/id");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/bitrate");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/destinationId");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/destinationPinId");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/id");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/sourceId");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/streamConnection/sourcePinId");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/bitrate");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/destinationId");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/destinationPinId");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/id");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/sourceId");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/connection/sourcePinId");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/id");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/alarmConfig");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/configuration");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/id");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/physicalPath");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/resourceType");

    agt_cb_unregister_callbacks(
        y_device_test_M_device_test,
        (const xmlChar *)"/xpo/profile/stream/resourceNode/statusConfig");

    /* put your cleanup code here */
    
} /* y_device_test_cleanup */

/* END device_test.c */
