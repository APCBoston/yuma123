<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
    <!ENTITY rfc2578 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2578.xml'>
    <!ENTITY rfc4741 PUBLIC '' 
      'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4741.xml'>

]>

<rfc category="std" docName="draft-bierman-ncx-smi-00" ipr="full3978">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc strict="yes"?>
<?rfc comments="no" ?>
<?rfc inline="no" ?>
<?rfc editing="no" ?>
<?rfc toc="yes"?>
<?rfc tocompact="no"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="no"?>
<?rfc iprnotified="no"?>

 <front>
  <title abbrev="NCX-SMI">Network Configuration Extensions : 
      Structure of Management Information
  </title>
  <author fullname="Andy Bierman" initials="A.B."
            surname="Bierman">
   <organization>netconfcentral.org</organization>
   <address>
    <postal>
     <street></street>
     <city>Simi Valley</city>
     <region>CA</region>
     <code></code>
     <country>USA</country>
    </postal>
    <email>ietf@andybierman.com</email>
   </address>
  </author>

  <date month="August" year="2007" />
  <area>Management</area>
  <workgroup>Internet Engineering Task Force</workgroup>
  <keyword>NETCONF</keyword>
  <keyword>NCX</keyword>
  <keyword>SMI</keyword>
  <keyword>XML</keyword>
  <abstract>
   <t>
    The standardization of network configuration interfaces for use 
    with the NETCONF protocol 
    requires a structured data modeling environment
    which promotes human usability, multi-vendor interoperability, and reuse
    of existing IETF data models written in SMIv2.  The Network Configuration
    Extensions (NCX) are a set of specifications intended to address
    NETCONF data modeling issues.  This document defines
    a Structure of Management Information (SMI) suitable for use with the NETCONF protocol,
    intended to promote a more consistent, manageable,
    and interoperable infra-structure for ongoing development
    of NETCONF-based management interfaces.
   </t>
  </abstract>
 </front>

 <middle>
  <section title="Introduction">
   <t>
    The standardization of network configuration interfaces for use 
    with the <xref target="RFC4741">NETCONF</xref> protocol 
    requires a structured data modeling environment
    which promotes human usability, multi-vendor interoperability, and reuse
    of existing IETF data models written in 
    <xref target="RFC2578">SMIv2</xref>.  This document defines
    a Structure of Management Information suitable for use with the NETCONF protocol,
    in order to help promote a more consistent, manageable,
    and interoperable infra-structure for ongoing development
    of NETCONF-based management interfaces.
   </t>

   <t>
    The Network Configuration Protocol defines an XML-based protocol for
    managing network device configuration databases.  However, there is no
    specifications for the inter-operable organization of a 
    conceptual 
    NETCONF configuration database,
    and precisely how the standard NETCONF
    protocol operations behave on the configuration database.
   </t>

   <t>
    This document discusses the following concepts:
    <list style="symbols">
     <t>NCX Framework</t>
     <t>NCX Naming Conventions</t>
     <t>NCX Agent Security Requirements</t>
     <t>NETCONF Interoperability Guidelines</t>
    </list>
   </t>

   <section title="Terminology">
    <section title="Requirements Notation">
     <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
      and "OPTIONAL" in this document are to be interpreted as
      described in <xref target="RFC2119"/>.
     </t>
    </section>

    <section title="NETCONF Terms">
     <t>
      The following terms are defined in RFC 4741 and are not redefined here:
      <list style="symbols">
       <t>agent</t>
       <t>client</t>
       <t>manager</t>
       <t>operation</t>
       <t>RPC</t>
       <t>RPC method</t>
       <t>server</t>
       <t>session</t>
       <t>user</t>
      </list>
     </t>
    </section>

    <section title="Terms">    
     <t>
      The following terms are used throughout this documentation:
      <list style="hanging">
       <t hangText="application:">
        A set of functionally-related, owner-specific, conceptual
        data modeling interfaces.
       </t>

       <t hangText="data model:">
        Formal representation of the application and protocol specific components
        of a conceptual network management programmatic interface.
       </t>

       <t hangText="data model module:">
        Container of definitions pertaining to some portion of one or more data models.
       </t>

       <t hangText="object:">
        A definition within a data model module that
        represents conceptual management data, which can be accessed
        by a manager via a network
        management protocol. 
        The data contained within an object should be functionally related
        in some manner.
       </t>

       <t hangText="notification:">
        A definition within a data model module that
        represents a conceptual notification message construct.
       </t>

       <t hangText="method:">
        A definition within a data model module that
        represents a conceptual remote procedure call (RPC) construct.
       </t>

       <t hangText="owner:">
        The naming authority for a data model definition.
        All owner names must be globally unique,
        maintained in a registry by IANA.
        All data model definition names within the scope
        of a single owner must be unique.
       </t>

       <t hangText="NETCONF base:">
        This term usually refers to the namespace URI value assigned
        to the NETCONF base schema in RFC 4741.  It has also been used
        to refer to the core set of operations mandated by the advertisement
        of the capability URI for the NETCONF 'base', or the capability itself.
       </t>

       <t hangText="NETCONF data model:">
        The high-level organization and framework which encompasses
        all protocol operations, conceptual data definitions,
        and instances of those definitions.
       </t>

       <t hangText="object identifier:">
         A string which identifies a particular object.
       </t>

       <t hangText="instance identifier:">
         A string which identifies a particular instance of an object.
       </t>
      </list>
     </t>
    </section>
   </section>

   <section title="Problem Statement">
    <t>
     Network operators and network equipment (NE) software developers
     need a lot of expertise, and spend a lot of time, to configure,
     control, and monitor network devices.
    </t>

    <t>
     Network configuration has traditionally been very proprietary
     in nature, and based on screen-scraping
     Command Line Interface (CLI) commands
     that can be stored in a textual file.  Configuration management
     is usually done manually, and is prone to human-introduced error.
     Often, scripts or applications which use the CLI as a programmatic interface
     are developed ad-hoc to automate and simplify some repetitive management tasks.
    </t>

    <t>
     Programmatic interfaces
     built on top of the CLI are insufficient for the following reasons:
 
     <list style="symbols">
       <t>
        CLI is proprietary, requiring extra effort by operators
        to learn and manage different CLIs for different equipment.
       </t>
       <t>
        CLI lacks a formal description language to completely
        define all properties of the programmatic interface
       </t>
       <t>
        CLI lacks any structured error responses, and very little
        information about specific errors is available to applications
       </t>
       <t>
        CLI lacks any sort of formalized transaction mechanism,
        to safely lock, alter, and unlock configuration databases in
        a multi-application environment.
       </t>
      </list>
    </t>

    <t>
     NETCONF (by design) separates the application-specific
     content within a network management operation from the operation itself.
     There is currently no standard data model content defined for NETCONF.
     Since it uses XML encoding, any data modeling language
     that describe XML instance documents can be used to define
     management definitions for use with the NETCONF protocol.
    </t>

    <t>
     Typically, XML Schema Definition (XSD) is used to describe
     valid XML instance documents for a particular XML application.
     However, XSD is rather difficult for humans to work with efficiently.
     It is verbose and complex, difficult to read and write, but is
     still an excellent formal description mechanism for applications
     to use.
    </t>

    <t>
     Because XSD is so difficult for humans to understand and
     define without errors, moving from CLI to XML based 
     configuration management is not that easy.  An application
     cannot really use an XSD schema to manage a network device
     until the data model definitions accurately reflect the
     native programmatic interface available from the NETCONF agent.
    </t>

    <t>
     This 'human usability' problem is especially important
     in the area of network management because increased
     complexity increases the risk that something will break
     in an unexpected way. Network operators and protocol
     developers need to fully understand that the XML data model
     correctly reflects the normative specification found in text.
     This has proved difficult when using XSD to define the XML syntax.
    </t>

    <t>
     Just as important as the human usability problems is the fact
     that XSD is designed and intended for use as a generalized
     formal definition of the content of XML instance documents.
    </t>

    <t>
     XSD does not address network management problems that
     have long been recognized and partially solved:
     <list style="symbols">
      <t>extensible modularity</t>
      <t>definition and module lifecycle</t>
      <t>change control guidelines</t>
      <t>user documentation</t>
      <t>implementation conformance</t>
      <t>maximum protocol access</t>
      <t>integration with existing SNMP-based data structures</t>
      <t>agent implementation conformance</t>
      <t>conditional presence tests based on referential integrity
          or protocol functionality</t>
      <t>user-defined RPC methods</t>
      <t>user-defined notifications</t>
      <t>protocol operation dependent schema</t>
      <t>conditional definitions based on platform capabilities</t>
      <t>data model conformance requirements</t>
     </list>
    </t>

    <t>
     Although it is possible to
     arbitrarily extend the &lt;appinfo&gt; element,
     this XSD mechanism is by definition non-standard,
     and 'off-the-shelf' XSD-based applications will not
     be able to do anything useful with information encoded
     in this manner.
    </t>

    <t>
     In addition to the many aspects of standards-based data
     model definition and maintenance that are not directly
     addressed by XSD. The NETCONF protocol uses data model
     schema differently, depending on the protocol operation
     mode.
    </t>
          
    <t>
     There are four different usage-based representations, 
     which would each require its own XSD schema, that are
     conceptually and simultaneously supported by a NETCONF Data Model:

     <list style="hanging">
      <t hangText="full:">
       Conceptualization of all
       objects and all possible instances. 
       This is the canonical representation
       that is defined as the combined contents of all data
       model modules used within all managed systems. The data
       properties represent the syntax, semantics, and requirements
       of a data model, independent of all protocol operations.
      </t>
      <t hangText="concise:">
       Conceptualization of all
       object instances within a managed system.
       Only the writable object values which have actually been 
       configured to non-default values by a management application are 
       within this representation. This is also called
       the no-defaults representation.
      </t>
      <t hangText="filter">
       Conceptualization of all permutations
       of all valid subtree filter expressions which are possible
       for a particular object.  An XSD would
       need to treat every element and every attribute as optional
       in order to support this representation.  In addition,
       unknown namespaces, elements and attributes are not
       errors, but rather valid filter components which simply 
       produce no matching output from the underlying data model
       instances within the agent. This is also called the
       subtree filter representation.
      </t>
      <t hangText="edit-config">
       Conceptualization of all permutations
       of all valid data model instances which are possible
       for a particular object, which permit
       the NETCONF edit-mode 'operation' attribute (for 
       the edit-config protocol operation) to be present.
       An XSD would need to include this XML attribute
       in every XML element within the conceptual 
       configuration data model to represent this mode. 
      </t>
     </list>
    </t> 
   </section>

   <section title="Solution Requirements">
    <t>
     There is a need for a comprehensive management framework for
     the NETCONF protocol which provides the following features:
     <list style="symbols">
      <t>
       An extensible and interoperable conceptual model of the correct
       behavior of a NETCONF agent must be defined.
      </t>
      <t>
       A framework completely compatible with the multiple configuration
       database architecture defined in the NETCONF protocol.
      </t>
      <t>
       A mechanism to classify objects wrt/ the
       NETCONF protocol operations (e.g., 'config' vs. 'state') must be supported. 
      </t>
      <t>
       A mechanism to identify session-specific and/or transient
       (i.e., not NV-stored) configuration data is needed.
      </t>
      <t>
       Multiple owners must be able to define and maintain data model
       interfaces within a single management framework.
      </t>
      <t>
       Support for user-defined RPC methods and notifications must be supported.
      </t>
      <t>
       Data model lifecycle mechanisms to evolve management interfaces over time
       must be supported.
      </t>
      <t>
       One set of data model naming conventions must be defined.
      </t>
      <t>
       Mechanisms for modular data definitions (such as found 
       in SMIv2) must be supported.
      </t>
      <t>
       Mechanisms for arbitrarily complex indexed, tabular data,
       must be supported.
      </t>
      <t>
       All data types found in XSD must be supported.
      </t>
      <t>
       All data types found in SMIv2 must be supported.
      </t>
      <t>
       The data naming scheme must be compatible with NETCONF Xpath
       filter 'select' and 'error-path' strings.
      </t>
      <t>
       A conceptual framework for standardized, interoperable application
       of the NETCONF 'edit-config' protocol operation 
       on arbitrary data models must be specified.
      </t>
      <t>
       A conceptual framework for standardized, interoperable enforcement
       of user-configured access control mechanisms on arbitrary data models must be
       defined.
      </t>
      <t>
       A conceptual framework for standardized, interoperable identification
       of NETCONF notification message content must be defined.
      </t>
      <t>
       Mechanisms to reuse SMIv2-defined network management data and
       agent instrumentation must be defined.
      </t>
      <t>
       Mechanisms to translate SMIv2 MIB object definitions into conceptual
       NETCONF MIB objects must be defined.
      </t>
      <t>
       Mechanisms for augmentation of conceptual data structures must be
       provided, such that any owner can extend any object definition
       in a easy-to-use and interoperable manner.
      </t>
     </list>
    </t>
   </section>
  </section>

  <section title="NCX Framework">
   <t>
    This section discusses the following concepts
    related to the NCX framework:
    <list style="symbols">
     <t>Owners</t>
     <t>Namespaces</t>
     <t>Capabilities</t>
     <t>Data Types</t>
     <t>Applications</t>
     <t>Configuration Databases</t>
     <t>RPC Methods</t>
     <t>Objects</t>
     <t>Notifications</t>
     <t>Non-Volatile Configuration Storage</t>
     <t>Agent Conformance Requirements</t>
     <t>Definition Change Control Guidelines</t>
    </list>
   </t>

   <section title="Framework Overview"> 
    <t>
     The NCX framework imposes some clarifying language restrictions upon
     the XML usage within the contents of a configuration database.
     This is done to help promote a more consistent, manageable,
     and interoperable infra-structure for ongoing development
     of NETCONF-based management interfaces.
    </t>

    <t>
     Not every possible construct
     available in XML is utilized in the framework.  
     Instead, a user-friendly,
     yet comprehensive subset of all well-formed XML is defined,
     providing data modeling constructs compatible with SMIv2, 
     XSD, and XPath.
    </t>

    <t>
     The NCX framework is designed to be independent of the
     particular data modeling language one might use to
     describe schema for valid instances of the data model
     conceptual data structures. The XML structure itself is 
     discussed instead.
    </t>

    <t>
     The basic data organization of the conceptual NETCONF MIB
     (as utilized within an NCX agent) is shown in the diagram below:
    </t>

    <figure anchor="NCX_framework_top">
     <artwork>
<![CDATA[

                              NCX agent
                            +------------+
                            | conceptual |
                            |    root    |
                            |  <config>  |
                            +- - - - - --+
                                  |
          +------------------------+--------------------+
          V                       V                     V
    +-------------+         +-----------+         +-----------+
    | <candidate> |         | <running> |         | <startup> |
    |   config    | ------> |  config   | ------> | config    |
    +-------------+         +-----------+         +-----------+
                                  |
          +-----------------------+----------------------+
          V                       V                      V
    +-------------+         +-----------+         +---------------+
    |   'acme'    |         |  'ietf'   |         | 'enterpriseN' |
    |    owner    |         |   owner   |       > |    owner      |
    +-------------+         +-----------+         +---------------+
          |                        |                    |
          |                        |                    |
          V                        V                    V
    +-----------+           +-----------+         +---------+
    |   <foo>   |           | <netconf> |         | <bar>   |
    |  app hdr  |           |  app hdr  |         | app hdr |
    |  node     |           |  node     |         | node    |
    +-----------+           +-----------+         +---------+
                                   |
          +--------------------+---+
          V                    V
    +----------------+   +-----------+
    | <eventStreams> |   | <monitor> |
    |  data model    |   |   data    |
    |   object       |   | model obj |
    +----------------+   +-----------+
                               | 
      +------------------------+----------------------+
      V                        V                      V 
  {Additional layers, e.g., child nodes and nested objects)

]]>
     </artwork>
    </figure>


    <t>
     An NCX agent is a NETCONF agent that has the following properties:
    </t>

    <t>
     <list style="symbols">
      <t>
       An agent consists of one or more configuration databases,
       which can be accessed with the NETCONF protocol, and likely
       other protocols.
      </t>

      <t>
       A configuration database is a conceptual construct.
       It must be administered as if there is only one of them.
       The contents of a configuration database be remain 
       conceptually identical, regardless of the particular configuration
       database being used for any protocol operation.
      </t>

      <t>
       The &lt;running&gt; configuration is
       a special (mandatory) conceptual database containing all the current configuration
       and state parameters in affect at the moment.
      </t>

      <t>
       An NCX agent must support the &lt;running&gt; configuration,
       even if it is only used to support the &lt;get&gt; operation.
       The responses for NETCONF retrieval operations must return 
       data from this configuration database in XML encoding.
      </t>

      <t>
       An NCX agent may optionally support the global &lt;candidate&gt; configuration,
       but it must be implemented exactly as defined in RFC 4741.
       A separate capability and different configuration
       database must be defined if a different model is needed instead 
       (e.g., multiple per-session candidate configurations).
       This configuration database must be encoded in XML.
      </t>

      <t>
       An NCX agent may optionally support the global &lt;startup&gt; configuration,
       but it must be implemented exactly as defined in RFC 4741.
       The standard &lt;copy-config&gt; operation must be supported to
       update the contents of non-volatile storage, even if other
       mechanisms are made available as well.  The '#distinct-startup'
       capability must be advertised in the capability list.
      </t>

      <t>
       The actual output format of the &lt;startup&gt; configuration
       is not required to be XML, like the other configuration databases.
       An agent is not required to support any protocol operations for
       this database at all, except as the target of a &lt;copy-config&gt;
       operation.
      </t>

      <t>
       The &lt;candidate&gt; configuration is
       a special (optional) conceptual database containing all the pending modifications
       to the &lt;running&gt; configuration database.  It is part of
       the standard ':candidate' capability, which allows configuration
       changes to be gathered in multiple steps, and applied to
       the device all at once, using the &lt;commit&gt; operation.
      </t>

      <t>
       The &lt;startup&gt; configuration is
       a special (optional) conceptual database containing all the configuration
       parameters which should be used upon the next reboot of the device.
      </t>

      <t>
       If this configuration database is present, 
       then an explicit &lt;copy-config&gt; operation by the manager
       is required to store the contents of the &lt;running&gt; configuration
       database to non-volatile storage.
      </t>

      <t>
       If this configuration database is not present, then the agent is responsible for keeping
       the contents of the &lt;running&gt; configuration
       database in synch with non-volatile storage.
      </t>

      <t>
       Each application header node contains zero or more data objects,
       which can use the syntax of any valid XML data type,
       and contain simple or complex content.
      </t>
     </list>
    </t>

    <t>
     The following diagram shows the basic conceptual system components
     and how they relate to each other within the context of
     the NETCONF protocol messages, or PDUs.  The framework
     does not consider any additional management infra-structures
     which are not supported by the NETCONF protocol.
     For example, proxy, tiered, multi-manager-to-agent, and manager-to-multi-agent
     network management architectures are outside the scope of this document.
    </t>

    <t>
      <figure anchor="NCX_framework_components">
       <artwork>
<![CDATA[

   +-----------+                          +-----------+
   |           |                          |           |
   | NETCONF   | <rpc> request            | NETCONF   |
   | Manager   | ---------------------->  | Agent     |
   |           |                          |           |
   | schema    | <rpc-reply> response     | <running> |
   | apps      | <---------------------   | configs   |
   | databases |                          | apps      |
   |           | <notification> message   |  objects  |
   |           | <---------------------   |  methods  |
   |           |                          |  events   |
   +-----------+                          +-----------+

]]>
       </artwork>
      </figure>
     </t>
   </section>

   <section title="Owners">
    <t>
     All NCX definitions are specified within the scope of one owner,
     indicated by a globally unique owner name string.
     It is expected that the IANA registration service will 
     be used to maintain the registry owner name strings.
    </t>

    <t>
     Ownership of a data model definition implies publication and change control
     responsibility for the entire data model.  It does not 
     imply any restrictions on use or interoperability
     of XML instance documents utilizing those data model definitions,
     within a NETCONF session.
    </t>

    <t>
     There are two reserved owner string names at this time:
    </t>

    <t>
     <list style="hanging"> 
      <t hangText="ietf">
       Owner of all standards-track, NETCONF-related 
       protocol definitions, SMI definitions,
       and IETF defined textual conventions and data models.
      </t>
      <t hangText="ncx">
       Owner of the data definitions associated with NCX itself.
      </t>
     </list>
    </t>

    <t>
     There are also reserved owner name strings that correspond
     to Enterprise Identifiers in IANA, which are used in SMIv2
     to provide a subtree within the entire MIB for vendor-specific
     definitions.
    </t>

    <t>
     The following URL identifies the Enterprise numbers already
     in use:
    </t>
    <t>
     http://www.iana.org/assignments/enterprise-numbers
    </t>

    <t>
     The special string 'enterprise' concatenated with the Enterprise
     Identifier value (with no leading zeros) is the default
     owner string for the organization that owns the specific Id
     assignment in IANA.  For example, the owner string value
     'enterprise9' would indicate Enterprise number nine,
     which is registered to 'ciscoSystems'.
    </t>
    <t>
     The owner name 'enterprise0' is reserved, and identifies the
     owner named 'ietf'.
    </t>
   </section>

   <section title="Namespaces">
    <t>
     All definitions 
     are specified within a particular XML Namespace.  This is a globally
     unique URI string value.  It is expected that a registration
     process such as IANA will be used to register namespace URI
     values and their meaning.
    </t>

    <section title="Reserved Namespaces">
     <t>
      There are three reserved namespace URI string values at this time.
     </t>
 
     <t>
      <list style="numbers">
       <t hangText="NETCONF base:">
        urn:ietf:params:xml:ns:netconf:base:1.0
       </t>
       <t hangText="xmlns attribute:">
        http://www.w3.org/2000/xmlns
       </t>
       <t hangText="NCX extensions:">
        http://netconfcentral.org/ncx/1.0
       </t>
      </list>
     </t>
    </section>

    <section title="User-Defined Namespaces">
     <t>
      It is expected that many additional namespaces will be defined
      as more data models are created.  Some conventions to manage
      these namespace assignments are needed to encourage
      robust interoperable implementations.
     </t>

     <t>
      It is strongly suggested that namespace URIs do not contain
      module version information, which is likely to change
      several times over the lifetime of the module containing
      definitions within that namespace.
     </t>
      
     <t>
      Instead, the schema document file names, and or meta-data
      within the file itself should be used to identify the various
      versions (of the module) over time.
     </t>

     <t>
      If XSD is used to specify the schema, then the 'version'
      attribute within the &lt;schema&gt; element should be
      updated appropriately each time the published version
      of the document is changed.
     </t>
    </section>
   </section>

   <section title="Capabilities">
    <t>
     NETCONF capabilities are an important part of the NETCONF protocol.
     However, agent vendors should use this tool carefully.
     Capabilities should be used only as a last resort, or if the capability
     represents some physical aspect of the managed device
     (e.g., card type 'foo' is present).
    </t>
    <t>
     There are no restrictions on what can be advertised in 
     a &lt;capability&gt; element within a NETCONF &lt;hello&gt;
     message.
    </t>
    <t>
     An agent must advertise a 'NETCONF base' capability for
     every version of the protocol it supports.  An agent must
     support version 1.0, as specified in RFC 4741.
    </t>
    <t>
     An agent may choose to advertise the modules or namespaces or
     schema it supports in the &lt;hello&gt; message, but this
     must be done in a non-standard way at this time.
    </t>
    <t>
     By convention, a capability contains version information,
     since it is just a string, and cannot contain meta-data,
     such as a 'version' attribute.
    </t>
    <t>
     Capabilities cannot be changed once they are published.
     The 'contract' established by the defined agent behavior
     associated with the capability must never change.
     I different capability string must be used for each variant of
     the capability.
    </t>
    <t>
     Capability definitions must not contradict or negate any specified behavior
     in any other concurrently advertised capability definition.
    </t>
    <t>
     A capability may extend the behavior of another capability in some fashion,
     such as the '#confirmed-commit' capability which extends the
     behavior of the &lt;commit&gt; operation, which is defined by
     the '#candidate' capability.
    </t>
   </section>

   <section title="Data Types">
    <t>
     Data type definitions are considered to be abstract constructs
     that cannot be accessed by any protocol mechanism.
     They are purely conceptual, like a TEXTUAL-CONVENTION
     macro in SMIv2.
    </t>
    <t>
     High level conceptual data types should be 
     defined in a reusable manner whenever possible.
    </t>
    <t>
     All the conceptual base data types defines in XSD and SMIv2 should be
     supported by an agent, but the actual data models present will
     determine which data types are actually supported.
    </t>    
   </section>

   <section title="Applications">
    <t>
     All definitions 
     are specified within the context of a particular NCX Application.
     This is owner-unique string value, which follows 
     the NCX Name syntax and semantics.
    </t>
 
    <t>
     An application has significance within XML.
     Each application has its own namespace, and all
     accessible objects for the application are defined
     in this namespace.  [A future version of NCX may allow
     unique namespace assignments for application-independent
     objects.]
    </t>

    <t>
     Protocol-accessible constructs (e.g., RPC methods, 
     objects, and notifications) must be associated 
     with a single application.
    </t>
 
    <t>
     Conceptually, NCX data type definitions do not need a namespace assignment,
     since only objects are accessible via protocol operations,
     but they are assigned one anyway for XSD translation purposes.
    </t>
 
    <t>
     The special application name types is used (by convention)
     in modules which contain only reusable data types and no accessible 
     objects.
    </t>
 
    <t>
     Application names should be unique within the scope of
     a single owner, and must be unique within the scope of a
     single XML namespace.
    </t>
 
    <section title="Application Header Nodes">
     <t>
      An application header node is the top-level container for
      object instances, for a specific application.
      All application header nodes are child nodes of the conceptual
      configuration root.
     </t>

     <t>
      An application header node is a top-level element within
      the NETCONF MIB.  It must be defined within a globally
      unique namespace.  The name of the application must match
      the name of the element.  There is a 1:1 static relationship between 
      the namespace URI for an application header node and the 
      element name.
     </t>

     <t>
      This node serves as the one and only 'root' for all data model
      objects defined within the application.  This restriction
      makes it easier for humans to remember the MIB structure
      and make filtering simpler, especially subtree filtering,
      which cannot be used to discover the elements present in
      a single namespace.
     </t>

     <t>
      There are no restrictions on the namespaces used for
      objects (which are child nodes of the
      application header node).  It is suggested that
      the application namespace be used if possible,
      to simplify namespace usage, but the selection
      of target namespace for a particular object
      is up to the data model publisher.
     </t>

     <t>
      Application header nodes should be defined with an XSD,
      in a manner that allows substitution group replacement
      and extensible addition of objects to the application over time.
     </t>

     <t>
      An application header node should be defined as an
      extension to the 'configInlineType', found in the XSD
      in RFC 4741.
     </t>

     <t>
      The following XSD fragment example shows how an
      application header node and an object within it
      could be defined using XSD:
 
      <figure anchor="NCX_container_XSD_example">
       <artwork>
<![CDATA[

   <!--
     Type for 'foo' element, child of 'config' element
    -->
   <xs:complexType name="fooAppType">
     <xs:complexContent>
       <xs:extension base="nc:configInlineType">
        <xs:sequence>
         <xs:element ref="fooObject" minOccurs="0" 
           maxOccurs="unbounded"/>
        </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!--
     Type for abstract child of 'foo' element
    -->
   <xs:complexType name="fooObjectType">
     <xs:complexContent>
       <xs:extension base="fooAppType"/>
     </xs:complexContent>
   </xs:complexType>

   <!--
     Element for the 'foo' application header node element
    -->
   <xs:element name="foo" type="fooAppType" />

   <!--
     Element for abstract child of 'foo' element
    -->
   <xs:element name="fooObject" type="fooObjectType" abstract="true"/>

   <!--
     Type for a concrete object 'contact' for the 'foo' application
    -->
   <xs:complexType name="Contact">
     <xs:complexContent>
       <xs:extension base="fooObjectType">
         <xs:sequence>
           <xs:element name="name" type="xs:string"/>
           <xs:element address"address" type="xs:string"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!--
     Element for a concrete object 'contact' for the 'foo' application
    -->
   <xs:element name="contact" type="Contact" />

]]>
       </artwork>
      </figure>
     </t>

     <t>
      The following XML fragment example shows an instance document
      for the object and application from the previous example.
 
      <figure anchor="NCX_container_XML_example">
       <artwork>
<![CDATA[

   <config xmlns="NEXCONF-base">
     <foo xmlns="foo-app-NS">
       <contact>
         <name>Fred Flintstone</name>
         <address>17 Pebble Lane, Bedrock</address>
       </contact>
     </foo>
   </config>
   
]]>
       </artwork>
      </figure>
     </t>
    </section>
 
    <section title="Application Independent Definitions">
     <t>
      All conceptual data types are application-independent.
      They are considered to be abstractions, similar to
      a TEXTUAL-CONVENTION in SMIv2.
     </t>
 
     <t>
      Other definitions, such as owner names and namespace URIs,
      are also used independent of any particular application.
     </t>
    </section>
 
    <section title="Application Specific Definitions">
     <t>
      XSD schema or NCX data model modules are used to specify 
      management definitions for use with the NETCONF protocol.
      Mechanisms to specify the following constructs should be
      provided:
 
      <list style="symbols">
       <t>Configuration Database Data Objects</t>
       <t>Event Notification Messages</t>
       <t>RPC Method Definitions</t>
      </list>
     </t>
 
     <t>
      Every NCX module must represent definitions for exactly
      one owner.  Any number of modules can
      be used to contain the definitions for an application,
      which all share the same owner-specific naming scope
      and application-specific XML namespace.
     </t>
  
     <t>
      Data type definitions are owner-specific, and can
      be used by any owner or any application.
     </t>
    </section>
   </section>
 
   <section title="Configuration Databases">
    <t>
     A NETCONF configuration database is a conceptual collection
     of network management information, which can be manipulated
     and retrieved with standard protocol operations and user-defined
     operations.
    </t>
 
    <t>
     The &lt;running&gt; configuration database is the central component
     of a NETCONF-managed agent. It is a mandatory database, which represents
     the current configuration and state of the entire managed device.
     All NCX configuration databases contain only 
     applications and their associated objects, except the special
     &lt;running&gt; configuration, which can contain configuration
     and other state-related data, such as statistics.
    </t>
   
    <t>
     Configuration databases are defined in detail in RFC 4741,
     and are used in NCX exactly as defined in that RFC, except
     that the conceptual database is considered to contain
     a collection of application header nodes, as supported
     by a particular agent.  Each application node in turn will
     contain the modeling data associated with that application.
    </t>
 
    <t>
     An XML instance documentation or XML PDU representation of a configuration
     database must use a top-node element to contain all of the application header
     nodes.  For example, the &lt;filter&gt;
     element within the &lt;get&gt; or &lt;get-config&gt; operations.
    </t>
 
    <t>
     When generating &lt;copy-config&gt; output, the &lt;config&gt;
     element from the NETCONF base namespace should be used to
     contain all the application header nodes.
    </t>
 
    <section title="Configuration Root">
     <t>
      One of the basic components of the NCX Data Model is the concept
      of the configuration root.
      This is a conceptual container, which represents the root
      of all contents of a NETCONF configuration database.
     </t>
 
     <t>
      A configuration root is not bound to a specific configuration database.
      The contents (i.e., child nodes) can conceptually be copied
      or moved between configuration databases (e.g., 
      copy &lt;running&gt; to &lt;startup&gt;).
     </t>
 
     <t>
      All configuration databases have a configuration root,
      represented in Xpath with the instance identifier value '/';
     </t>
    </section>
 
    <section title="Configuration Data Classification">
     <t>
      All NCX data model content accessible via a protocol operation
      must specify a configuration data classification value,
      and conform to its particular semantics.
     </t>
 
     <t>
      There are three classifications defined at this time:
     </t>
 
     <t>
      <list style="hanging">
       <t hangText="config:">
        All objects using the data type are considered to 
        be configuration data, and will be affected by protocol 
        operations which alter non-volatile configuration storage.
        Objects with this classification will be saved
        in non-volatile configuration storage, and also be returned
        when retrieved with the &lt;get-config&gt; protocol operation.
       </t>
       <t hangText="tconfig:">
        All objects using the data type are considered to 
        be transient configuration data, and will not be 
        affected by protocol operations which alter non-volatile
        configuration storage.
        Objects with this classification will not be saved
        in non-volatile configuration storage, but will be returned
        when retrieved with the &lt;get-config&gt; protocol operation.
       </t>
       <t hangText="state:">
        All objects using the data type are considered to 
        be state data, and will not be affected by protocol 
        operations which alter non-volatile configuration storage.
        Objects with this classification will not be saved
        in non-volatile configuration storage, and will not be returned
        (i.e., filtered-out) when retrieved with the &lt;get-config&gt; 
        protocol operation.
       </t>
      </list>
     </t>
    </section>

    <section title="Configuration Locking">
     <t>
      NETCONF locking mechanisms provide a way to restrict write
      access to the specified configuration database to the
      NETCONF session that requested the lock.  This lock
      will be in affect until the &lt;unlock&gt; operation
      is invoked by the manager (on that session).
     </t>

     <t>
      A lock must be dropped if the session that hold the session
      is terminated,
     </t>

     <t>
      If an agent discovers an session in a non-recoverable error
      condition, it should immediately terminate that session 
      and release any configuration locks it holds.
     </t>

     <t>
      All NCX agent implementations must support the global
      configuration database locking mechanism defined in the 
      NETCONF protocol.
     </t>

     <t>
      An agent may optionally support a partial database locking
      capability, in which only a static subset of the entire
      database is locked.
     </t>

     <t>
      A global configuration lock must apply to all access to
      the database, nut just by the NETCONF protocol.
      The agent must use locking mechanisms outside the
      scope of this document to ensure this requirement is met.
     </t>

     <t>
      If a NETCONF-specific partial lock is held by a session,
      and external access mechanisms (e.g., SNMP protocol)
      cannot correctly lock the exact subset of data, then
      the agent must ensure that the database is globally
      locked wrt/ these external access mechanisms.
     </t>

     <t>
      A manager should lock the configuration databases within a session
      as short a time period as possible.
     </t>

     <t>
      An agent should support some form of configuration change event 
      notification, if NETCONF Notifications are supported, and generate
      a configuration change event in a timely manner, when changes to
      the &lt;running&gt; configuration are detected. The agent 
      may choose not to generate more than one such event within
      a given time interval (e.g., 1 minute) in order to save
      system resources.
     </t>
    </section>
   </section>
 
   <section title="RPC Methods">
    <t>
     The top-level interface in NCX (and NETCONF) is the remote procedure call.
     All management requests are made using an &lt;rpc&gt; element,
     and all corresponding management responses are made using
     an &lt;rpc-reply&gt; element, as defined in the NETCONF standard.
    </t>
 
    <section title="RPC Classification">
     <t>
      All RPC methods must be classified by the data model writer
      according to the main purpose of the RPC method.  This is
      a general classification and is not intended to be used
      as a robust filtering mechanism.  Instead, it is intended
      to provide a simple mandatory classification mechanism to help
      enforce access control rules during RPC method invocation.
     </t>
 
     <t>
      The following classifications are defined:
      <list style="hanging">
       <t hangText="other">
        The RPC method is some unknown type, defined outside the scope
        of the NCX data model framework.
       </t>
       <t hangText="config">       
        The RPC method is related to configuration management,
        and may modify and/or retrieve configuration database
        content in some manner.
       </t>
       <t hangText="exec">
        The RPC method is related to some sort of executable procedure,
        such as a ping operation.  The operation should not
        modify any configuration databases.
       </t>
       <t hangText="monitor">
        The RPC method is related to some sort of monitoring procedure,
        such as statistics retrieval, or retrieval of configuration data.
        The operation must not modify any configuration databases.
       </t>
       <t hangText="debug">
        The RPC method is related to some sort of debugging procedure,
        and may enable, modify, or disable some sort of debugging or logging
        service on the agent. The operation must not modify any
        configuration databases.
       </t>
      </list>
     </t>

     <t>
      Combinations of these classification values are discouraged
      within a single RPC method.  They are not supported within 
      the NCX data model framework at this time.  Data model designers
      should avoid changing the RPC method classification based
      on different values of RPC parameters, determined at RPC invocation time.
     </t>
    </section>

    <section title="Reserved RPC Methods">
     <t>
      There are several standard RPC methods, owned by 'ietf',
      that are defined within the NETCONF protocol, The RPC
      classification for each operation is also shown:
     </t>
 
     <t>
      <list style="symbols">
       <t>get-config (monitor)</t>
       <t>edit-config (config)</t>
       <t>copy-config (config)</t>
       <t>delete-config (config)</t>
       <t>get (monitor)</t>
       <t>lock (config)</t>
       <t>unlock (config)</t>
       <t>validate (monitor)</t>
       <t>commit (config)</t>
       <t>discard-changes (config)</t>
       <t>close-session (exec)</t>
       <t>kill-session (exec)</t>
       <t>create-subscription (config)</t>
      </list>
     </t>
 
     <t>
      It is strongly suggested that these RPC method names never be used
      in user-defined data models, regardless of the namespace specified.
     </t>
    </section>
 
    <section title="User-Defined RPC Methods">
     <t>
      User-defined RPC methods are associated with a specific
      namespace and application.  Any number of input and output parameters
      can be specified, as long as the &lt;rpc&gt; and &lt;rpc-reply&gt;
      elements conform to the definition in RFC 4741.
     </t>
 
     <t>
      All user-defined RPC methods must be appropriately
      classified somehow, such that the agent and manager
      can identify potential security risks resulting from
      side effects of an RPC method invocation.
     </t>
    </section>
   </section>

   <section title="Objects">
    <t>
     Objects are application-specific
     conceptual data structures located within a configuration database.
     They are similar to MIB objects in SNMP, and can be directly
     accessed or manipulated with standard or user-defined RPC methods.
    </t>
 
    <t>
     Every object has the following basic properties:
    </t>
 
    <t>
     <list style="hanging">
      <t hangText="namespace:">
       An globally unique namespace assignment.
       This should not change over the lifetime of the object.
      </t>
      <t hangText="identifier">
       A globally unique identifier string associated with the object.
       It must be complete and unambiguous.
      </t>
      <t hangText="semantics">
       Each object has specific semantics associated with it,
       defined with some sort of data modeling language, such as XSD.
      </t>
      <t hangText="syntax">
       Each object has a specific syntax, which must be 
       well-formed XML, must not contain any DTDs, and should 
       not include any mixed-mode XML.  The syntax is defined
       with a data modeling language such as XSD.
      </t>
     </list>  
    </t>

    <t>
     An NCX agent must follow a more restrictive set of
     naming guidelines than XML permits.
     <list style="symbols">
      <t>
       Every object must be defined within a namespace.
      </t>
      <t>
       Every object name within the same namespace must be unique,
       (as specified in XML).
      </t>
      <t>
       Every object name for sibling child nodes of same application
       header node must be unique, regardless of the namespace used.
      </t>
      <t>
       Every application header node name defined by the same owner
       must be unique, regardless of namespace used.
      </t>
     </list>
    </t>

    <t>
     Objects can be nested within other objects.
     There are some guidelines, but no strict rules, for
     placement of an object within the subtree of its
     application header node. A simple scalar object
     or complex, nested tabular object can be defined to be
     located as a direct child of the application header node.
    </t>
 
    <t>
     NETCONF protocol error processing is affected by the conceptual
     containment boundary implied by an object's contents.
     The object boundary represents the fate-sharing boundary for 
     a single invocation of any configuration database edit operation.
    </t>
 
    <t>
     If the 'continue-on-error' option
     in the &lt;edit-config&gt; operation is used, then errors
     detected within the a particular conceptual object will
     not impact execution of the edit operation on other 
     objects (if any).
    </t>
   </section>
 
   <section title="Notifications">
    <t>
     The &lt;notification&gt; element is generated by a NETCONF agent
     if notification delivery is configured for a particular session.
     A notification message can contain an arbitrary amount of 
     data from the &lt;running&gt; (or other) configuration.
     There are no restrictions on the data placed within notification
     messages, however, care should be taken to secure the
     transfer of sensitive data.
    </t>
 
    <t>
     Every NCX notification has shares the same basic structure,
     and should support these basic properties:
    </t>
 
    <t>
     <list style="hanging">
      <t hangText="event type:">
       The event type is a owner-unique name string (QName) used to identify
       a particular event notification message type.  This string
       value is used to define the name of the child element
       of the &lt;notification&gt; element.  The namespace for
       this element is specified by the data model writer,
      </t>
      <t hangText="event class:">
       Each event notification should be associated with one
       event classification type, defined in the next section.
       this functional classification can be used for filtering
       and access control purposes.
      </t>
      <t hangText="event data:">
       Each event notification may optionally include
       an arbitrary amount of XML-encoded data, within
       the XML element associated with the event type.
       Only complex data (i.e., no mixed mode data)
       should be included in this part of a notification message.
       Care must be taken to ensure that a notification which
       contains restricted data (for a particular session) not
       be delivered to that unauthorized session.
      </t>
     </list>
    </t>
     
    <section title="Notification Event Classes">
     <t>
      The event classification mechanism uses 
      a set of generalized enumeration value to
      assist a manager configure filtering or access control
      mechanisms, to control the delivery of notifications
      to a NETCONF session.
     </t>
  
     <t>
      It is expected that the IETF will standardize specific values
      and semantics for this generalized classification string.  At this time,
      the format of this string is limited to any valid UTF-8 string
      between 1 and 1024 characters in length.
     </t>
 
     <t>
      It is expected that vendors will develop additional, more complex,
      event classification mechanisms which could be used in addition to this
      mandatory but generalized event classification mechanism.
     </t>
    </section>
   </section>
 
   <section title="Non-Volatile Configuration Storage">
    <t>
     The data representation capabilities of every configuration
     database may not be the same within an agent.  For example,
     it is not required in the NETCONF protocol to allow edit
     operations on the &lt;startup&gt; configuration.  Some
     implementations store configurations in non-volatile
     memory in a different format than XML.  This is a common
     practice an routers and switches.
    </t>
 
    <t>
     Although the NETCONF protocol does not prohibit alternate
     formats for configuration storage, it does not support it either.
     Therefore, the 'with-defaults' extension has been added 
     to suppress the output of configuration data
     instances which contain the default value for that parameter.
    </t>
 
    <t>
     By default, an NCX configuration database is saved in XML format,
     using a top-level (root) element named &lt;config&gt;, in the
     NETCONF base namespace.
    </t>
 
    <t>
     The 'with-defaults='false' option produces the smallest 
     possible output for NV-storage (or &lt;get-config&gt; retrieval), 
     but assumes the default value will never change.  Care must
     be taken by an agent, such that a newer 
     software release does not change the default value defined
     for a particular configuration parameter.
    </t>
 
    <t>
     By default, configurations are saved as XML instance documents,
     in which the top-level element is called &lt;config&gt;.
     The following example shows an XML configuration file.
     The XML directive on the first line should
     be present to identify the content and its encoding.
    </t>
 
    <t>
     The following example shows a top-level 'config' container
     with application header nodes for the 'nc-agent' and 'security',
     containing some data object values.  The 'nc-agent' application
     shows an 'nc-transport' object configured, and the 'security'
     application contains an 'ncx-access'
    </t>
 
    <t>
     <figure anchor="NV_config_sample">
      <artwork>
  
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
     &lt;config&gt;
       &lt;nc-agent xmlns="http://example.com/xsd/nc-agent"&gt;
         &lt;nc-transport&gt;
           &lt;bindings&gt;
             &lt;binding&gt;
               &lt;id&gt;1&lt;/id&gt;
               &lt;protocol&gt;ssh&lt;/protocol&gt;
               &lt;port&gt;830&lt;/port&gt;
             &lt;/binding&gt;
             &lt;binding&gt;
               &lt;id&gt;2&lt;/id&gt;
               &lt;protocol&gt;ssh&lt;/protocol&gt;
               &lt;port&gt;22&lt;/port&gt;
             &lt;/binding&gt;
           &lt;/bindings&gt;
         &lt;/nc-transport&gt;
       &lt;/nc-agent&gt;
       &lt;security xmlns="http://example.com/xsd/security"&gt;
         &lt;ncx-access&gt;
           &lt;mode&gt;strict&lt;/mode&gt;
           &lt;groups&gt;
             &lt;group&gt;
               &lt;name&gt;control-staff&lt;/name&gt;
               &lt;users&gt;
                 &lt;user&gt;andy&lt;/user&gt;
                 &lt;user&gt;fred&lt;/user&gt;
               &lt;/users&gt;
             &lt;/group&gt;
             &lt;group&gt;
               &lt;name&gt;monitor-staff&lt;/name&gt;
               &lt;users&gt;
                 &lt;user&gt;wilma&lt;/user&gt;
                 &lt;user&gt;barney&lt;/user&gt;
               &lt;/users&gt;
             &lt;/group&gt;
           &lt;/groups&gt;
           &lt;rpc-type-acls&gt;
             &lt;rpc-type-acl&gt;
               &lt;group&gt;control-staff&lt;/group&gt;
               &lt;rpc-types&gt;config monitor debug exec other&lt;/rpc-types&gt;
             &lt;/rpc-type-acl&gt;
             &lt;rpc-type-acl&gt;
               &lt;group&gt;monitor-staff&lt;/group&gt;
               &lt;rpc-types&gt;monitor debug&lt;/rpc-types&gt;
             &lt;/rpc-type-acl&gt;
           &lt;/rpc-type-acls&gt;
         &lt;/ncx-access&gt;
       &lt;/security&gt;
     &lt;/config&gt;
 
      </artwork>
     </figure>
    </t>
   </section>
  </section>

  <section title="NCX Naming Conventions">

   <t>
    This section discusses the following concepts
    related to the NCX naming conventions:
    <list style="symbols">
     <t>Definition Identifiers</t>
     <t>Object Identifiers</t>
     <t>Instance Identifiers</t>
    </list>
   </t>

   <t>
    In NCX, a name is just a language token.
    There is no concept of uniqueness for a name.
   </t>

   <t>
    An Identifier is used to attach a name
    to a conceptual entity, and is required to be unique
    within the scope of the entire NETCONF MIB.
   </t>

   <section title="Names">
    <t>
     An NCX name has the following properties:

     <list style="symbols">
      <t>
       NCX name strings are fields used within identifiers in some fashion.
      </t>
      <t>
       An NCX name string can be 1 to 1023 characters in length,
       but must not exceed 64 characters in length if SMIv2 compatibility
       is required.
      </t>
      <t>
        All names are case-sensitive.
      </t>
      <t>
       The first character must be a letter ('a'..'z' or 'A'..'Z')
      </t>
      <t>
       The rest of the characters in an NCX name can be any of:

       <list style="symbols">
        <t>letter ('a'..'z' or 'A'..'Z')</t>
        <t>number ('0'..'9')</t>
        <t>underscore ('_')</t>
        <t>dash ('-')</t>
       </list>
      </t>
     </list>
    </t>
   </section>

   <section title="Identifiers">
    <t>
     There are three types of identifiers:

     <list style="hanging">
      <t hangText="Definition Identifier>:">
       Used to identify an object definition 
       within a schema module.
      </t>
      <t hangText="Object Identifier:">
       Used to identify conceptual object definitions.
      </t>
      <t hangText="Instance Identifier">
       Used to identify conceptual instances of an object.
      </t>
     </list>
    </t>

    <section title="Definition Identifiers">
     <t>
      A definition identifier is used within an data model module
      to reuse a pre-defined user type within other constructs,
      and to specify index clause components. Other uses are also
      possible as well.
     </t>
    </section>

    <section title="Object Identifiers">
     <t>
      If an NCX object identifier is used within an XML 
      instance document (e.g., NETCONF PDU), it is 
      represented as an XPath Absolute Path
      Expression, which is used to specify a particular
      conceptual node within the NETCONF MIB.  It is similar
      to an OBJECT IDENTIFIER in SMIv2.
     </t>

     <t>
      An object identifier (within a PDU) begins with a forward slash,
      and is followed by zero or more node identifiers.
      A node identifier consists of a node-name (Name or QName)
      followed by a forward-slash, except the last identifier,
      which contains just a node-name.
     </t>

     <t>
      Although the syntax for XPath allows any element name (Name)
      or qualified element name (QName), in practice, the
      element names are constrained by the NCX 'name' syntax.
      Whitespace is not allowed within an object identifier.
     </t>

     <t>
      The following ABNF defines the object identifier syntax,
      as it used within an XML instance document:
     </t>

     <figure anchor="NCX_object_identifier">
      <artwork>
<![CDATA[

    ncx-obj-id = "/" [ncx-obj-id-nodes]
 
    ncx-obj-id-nodes = 0*(ncx-obj-id-namepair) name

    ncx-obj-id-namepair = name "/"

    name = Name / QName
]]>
      </artwork>
     </figure>

     <t>
      The following examples show some object identifiers
      that might appear in &lt;error-path:gt; elements
      or other data model content.
     </t>

     <figure anchor="NCX_object_identifier_examples">
      <artwork>
<![CDATA[

    ncx-obj-id = "/" [ncx-obj-id-nodes]
 
    ncx-obj-id-nodes = 0*(ncx-obj-id-namepair) name

    ncx-obj-id-namepair = name "/"

    name = Name / QName
       
   # Always use fixed root form for <error-path> content

   # The default namespace is set to NETCONF Base

   # The NCX module named 'ifexamples.ncx' contains the 
   # data model definition used in these examples
   http://www.netconfcentral.org/ncx/ncx-modules/ifexamples.ncx

   # The XSD corresponding to the NCX module is named 'ifexamples.xsd'.
   http://www.netconfcentral.org/ncx/xsd/ncx/ifexamples.xsd

   # 'itf' is the prefix for the 'ifdata' application namespace ID

   # an error-option is invalid or not supported
   /rpc/edit-config/error-option

   # a non-specific error occurred with the <config> element
   /rpc/edit-config/config

   # reset-interface RPC operation
   /rpc/itf:reset-interface

   # name parameter for the reset-interface RPC operation
   /rpc/itf:reset-interface/name

   # reset-mode parameter for the reset-interface RPC operation
   /rpc/itf:reset-interface/reset-mode

]]>
      </artwork>
     </figure>
    </section>

    <section title="Instance Identifiers">
     <t>
      Instance identifiers are used to uniquely identify conceptual
      object instances.
      For &lt;error-path&gt;
      purposes, it might also identify a particular node within
      the input parameter set for a specific RPC operation.
     </t>

     <t>
      An NCX instance identifier is represented with an 
      Absolute Xpath Expression.  The Xpath Specification 
      defines the allowable syntax for a valid XPath expression.  
      The NCX language imposes the following constraints and procedures
      for an NCX instance identifier:

      <list style="symbols">
       <t>
        An instance identifier must represent a single
        conceptual instance of a object.
       </t>
       <t>
        An instance identifier (like an object identifier)
        can be namespace qualified by using a namespace prefix,
        previously defined within the XML instance document.
       </t>
       <t>
        If no namespace prefix is encountered, starting after
        the first forward slash ('/'), then the current namespace in effect
        is used. If none, then the instance identifier is invalid.
       </t>
       <t>
        If the namespace for the first node is valid,
        then that namespace remains in affect until explicitly
        changed.  A subsequent node without a prefix is not
        assumed to be in the default namespace.
       </t>
       <t>
        Instance identifiers have a common fixed root, 
        i.e., starting with the &lt;rpc&gt; element for NETCONF 
        methods and data. This fixed root form is used when a 
        instance identifier is included
        in the &lt;error-path&gt; element within an RPC error response.
       </t>
       <t>
        Instance identifiers for conceptual data within a
        configuration database can also be used, 
        using a conceptual relative root for database.
        This is represented by the special Xpath expression '/'.
        Within an actual PDU, this relative root will actually be 
        an RPC parameter node, 
        such as &lt;config&gt; or &lt;data&gt; or &lt;filter&gt;.
       </t>
       <t>
        There is no default namespace associated with the root, so
        it must be specified within the PDU with appropriate 'xmlns' 
        directives, so the prefixes used within the Xpath expression
        can be resolved.
       </t>
       <t>
        RPC methods are identified by their path from the absolute root.
        Instance identifiers used within &lt;error-path&gt; elements must
        identify the entire path, starting with the &lt;rpc&gt; element.
       </t>
      </list>
     </t>

     <t>
      Simple Instance Identifier Examples:
     </t>

     <figure anchor="NCX_simple_instance_ids">
      <artwork>
<![CDATA[

   # the entire set of interface entries
   /itf:ifdata/interfaces

   # interface for 'eth0', fixed root version
   /rpc/edit-config/config/itf:ifdata/interfaces/interface[name='eth0']

   # interface for 'eth0', relative root version
   # relative root applies only to data object
   /itf:ifdata/interfaces/interface[name='eth0']

   # ifMtu node for the 'eth0' interface, relative root version
   /itf:ifdata/interfaces/interface[name='eth0']/ifMtu

]]>
      </artwork>
     </figure>

     <t>
      The following assumptions are made regarding the 
      NCX instance identifiers in the following examples:

      <list style="symbols">
       <t>
        An absolute Xpath expression containing sub-clauses for
        all relevant conceptual index (key) components represents 
        an instance of conceptual data.
       </t>
       <t>
        Index component expressions are simple equality expressions,
        concatenated to form a logical 'AND' expression,
        in which all the terms must be true for the expression to be true.
       </t>
       <t>
        The order of components within a conceptual index is not
        significant within Xpath.
       </t>
       <t>
        By convention, the leftmost index component is called 
        the 'major' index.
       </t>
       <t>
        By convention, Each 'minor' index in succession (if any) is 
        listed left to right, after the major index, in the order the index 
        is defined within the conceptual data model.
       </t>
      </list>
     </t>

     <figure anchor="NCX_complex_instance_ids">
      <artwork>
<![CDATA[

 # In this example, the data models for 'Parmset1' and 'Parmset2'
 # from the module 'test.ncx' are used.
 http://www.netconfcentral.org/ncx/ncx-modules/test.ncx

 # The XSD corresponding to the NCX module is named 'test.ncx'.
 http://www.netconfcentral.org/ncx/ncx-modules/test.ncx

 # The XSD corresponding to the NCX module is named 'test.xsd'.
 http://www.netconfcentral.org/xsd/ncx/test.xsd

 # The 'ts' prefix represents the namespace for the 
 # 'test' application namespace.

 # All examples are shown in relative root form

 # row 'foo' of table in parm 'p1', defined in 'Container1'
 /ts:test/Parmset1/p1/testrow[str1='foo']

 # 'name' field for row 'bar' in parm 'p5', defined in 'Table1'
 /ts:test/Parmset1/p5[str1='bar']/name

 # field 'y' of row '3' of 'childtable', within row 'bar'
 # in parm 'p5', defined in 'Table1'
 /ts:test/Parmset1/p5[str1='bar']/childtable[x=3]/y

 # entire row ('testing one two',-42) for parm 'p6'
 # defined in 'Table1a'
 /ts:test/Parmset2/p6[name='testing one two'][num=-42]

 # 'str1' field within row ('testing 3 4',27) of parm 'p2'
 # defined in 'Table1a'
 /ts:test/Parmset2/p6[name='testing 3 4'][num=27]/str1

 # entire row ('fred', 'baz') for 'testrow',
 # within the 'testrows' container,
 # which is part of row (17) for parm 'p8'
 # defined in 'Table2'
 /ts:test/Parmset2/p8[x=17]/testrows/testrow[name='fred'][str1='baz']

 # field 'bytes' within the row described above
 /ts:test/Parmset2/p8[x=2]/testrows/testrow[name='jo'][str1='baz']/bytes

]]>
      </artwork>
     </figure>

     <t>
      Instances of unnamed data (e.g. maxOccurs="unbounded" and 
      no 'key' defined) are identified by their position, relative to 
      other instances of the same element.
     </t>
     <t>
      The short form of the 'position()' function in Xpath (e.g., foo[3]
      for the third instance of the 'foo' element) 
      is used to identify unnamed data instances in this case.
     </t>
     <t>
      The first occurrence of an unnamed instance is identified with the 
      position value '1'.
     </t>
     <t>
      Unnamed instances are only identified by their integer position,
      and can only be accessed by this position within a configuration 
      database.
     </t>
     <t>
      Named instances are only identified by their associated 'index' 
      clause (i.e. key), and should not be accessed by their position
      instead of the defined key for the data structure.
     </t>
     <t>
      Instance identifiers are used as &lt;error-path&gt; element values
      within the &lt;rpc-error&gt; field in NETCONF RPC replies.  They
      (of course) can also used as the value of the 'select' attribute
      in the &lt;filter&gt; parameter for the NETCONF &lt;get&gt; operation.
     </t>
    </section>
   </section>
  </section>
  
  <section title="NCX Agent Security Requirements">
   <t>
    The security requirements for NCX pertain mostly to the content layer
    within the protocol stack.  These are in addition to the 
    security requirements for NETCONF agents defined in RFC 4741.
   </t> 

   <t>
    There is a hard-wired set of resources that can be secured
    within a NETCONF agent. The lack of flexibility allows
    a very simple data model to be used to
    configure access control mechanisms on a device.
   </t>

   <section title="Configuration Database Security">
    <t>
     Operators and agent developers must take precautions to
     ensure that the contents of the configuration
     databases within an agent are not exposed inadvertently,
     or insecurely, via some protocol other than NETCONF.
    </t>
    <t>
     An agent must provide some distinction between a super-user
     account (e.g., 'root'), an administrator account
     (e.g., 'admin'), and optionally other types of login accounts.
    </t>
     
    <t>
     An agent should provide access control for every database
     that can be accessed with the &lt;edit-config&gt;,
     &lt;get-config&gt;, or &lt;get&gt; operations.
    </t>
   </section>

   <section title="NETCONF Session Security"> 
    <t>
     The following requirements are defined for NCX agent session behavior:
     <list style="symbols">
      <t>
       An agent must allow NETCONF session establishment
       service for the mandatory transport, which is
       NETCONF over SSH, on port 830.
      </t>
 
      <t>
       An agent must not allow session establishment if the 'netconf'
       subsystem is not used during SSH session establishment.
      </t>
 
      <t>
       An agent may provide additional transport mappings as configured
       by the manager or hard-wired into the agent.
      </t>
 
      <t>
       Once a session has been properly established, and the 
       NETCONF &lt;hello&gt; exchange successfully completed,
       the agent may assume that the manager identity has been 
       authenticated and access to the agent is authorized.
       The agent is in its idle mode, waiting for &lt;rpc&gt;
       requests from the manager.
      </t>
 
      <t>
       The NETCONF protocol does not provide for any distinction
       between sessions wrt/ use of the &lt;kill-session&gt;
       operation.  An agent may choose not to allow a session
       associated with 'super-user' privileges not to be terminated
       by an 'administrator' or other type of login account.
      </t>
 
      <t>
       Agent access rights are granted to a particular session,
       associated (during session establishment) with a 'group',
       identified by a name string.  Membership to a group 
       is outside the scope of this document, but user name strings
       should be supported, and address strings may be supported
       as well.  A special group called 'root' is reserved
       and an agent should not redefine the default access rights
       associated with this group.
      </t>
     </list>
    </t>
   </section>
 
   <section title="RPC Security"> 
    <t> 
     The following requirements are defined for NCX RPC processing behavior:
     <list style="symbols"> 
      <t>
       When an &lt;rpc&gt; request is received, and it has been
       validated as a well-formed message, the agent must determine
       if the associated group has permission to invoke
       the specified RPC method.
      </t>
 
      <t>
       If the group has permission to invoke the RPC method,
       then the general protocol operation is checked further,
       if it accesses any part of a configuration database.
       Otherwise, the security check is complete for the RPC request,
       and it is processed by the agent.
      </t>
 
      <t>
       If the RPC method accesses any configuration database,
       then the agent must verify that the group has the
       appropriate access rights to perform the requested operation.
      </t>
     </list>
    </t>
   </section>

   <section title="Data Model Access Control">
    <t>
     Access rights are determined by the NETCONF protocol:
     <list style="symbols">
      <t>merge</t>
      <t>replace</t>
      <t>create</t>
      <t>delete</t>
      <t>read</t>
     </list>
    </t>
 
    <t>
     Data access is granted to a group within a particular session
     based on the maximum allowed access configured for the
     objects (and perhaps object instances). If the
     general operation type is permitted for the group,
     then the RPC method is processed by the agent.  Otherwise
     an 'access-denied' &lt;rpc-error&gt; is returned to the
     manager instead of processing the RPC request further.
    </t>
 
    <t>
     After the RPC method processing is complete, and an &lt;rpc-reply&gt;
     message is generated to be sent to the manager, the response
     should be checked for any unauthorized data within it.
     If the response contains any unauthorized data, then the
     agent must remove all of it before sending the reply.
    </t>
 
    <t>
     Agent security procedures for generating the &lt;notification&gt; message
     for a particular session is essentially the same as for the
     &lt;data&gt; element within an &lt;rpc-reply&gt;, with one exception.
     Instead of pruning data from the reply, as done for &lt;get-config&gt;
     or  &lt;get&gt; operation responses, the entire notification is
     dropped for that session.
    </t>
 
    <t>
     If an agent supports NETCONF notifications, it should generate 
     some sort of a 'agent-shutdown' event all all active sessions,
     whenever it is resetting or shutting down in an anticipated fashion.
    </t>
 
    <t>
     If an agent supports NETCONF notifications, it may wish to generate 
     some sort of a 'session-started' event whenever a new NETCONF 
     session is activated.
    </t>
 
    <t>
     If an agent supports NETCONF notifications, it should generate some
     sort of a 'session-terminated' event whenever a session 
     is terminated unexpectedly.
    </t>
 
    <t>
     If an agent supports NETCONF notifications, it may choose to generate some
     sort of a 'session-terminated' event whenever a session 
     is terminated in normal protocol fashion.
    </t>
   </section>
  </section>

  <section title="NETCONF Interoperability Guidelines">
   <t>
    This section addresses data modeling practices which are deemed to
    impact multi-vendor or even simple manager/agent interoperability.
    The following recommendations deal with NETCONF protocol usage
    and XML design considerations.
   </t>

   <section title="NETCONF Protocol Operation Usage Guidelines">
    <t>
     This section contains guidelines for defining data models
     for use with the NETCONF protocol, within the NCX framework:
    </t>

    <t>
     <list style="symbols">
      <t>
       All configuration data must be defined within the appropriate namespace,
       and all NETCONF protocol operations should use the correct namespace
       for each element in an &lt;rpc&gt; request.
      </t>

      <t>
       An agent may determine the correct namespace for a given element
       if none is provided, in a manner outside the scope of this document.
       However, this is not strictly correct XML usage.
      </t>
 
      <t>
       A manager and agent should only send the &lt;hello&gt; message
       once during session establishment.
      </t>
 
      <t>
       The 'operation' attribute within the &lt;config&gt; element for
       the &lt;edit-config&gt; operation should only be used once within
       a given XML sub-tree.
      </t>
 
      <t>
       A 'key' construct (e.g., INDEX clause in SMIv2) should be used for
       all data contained within a configuration.  Unnamed data should
       not be used within the definition of objects.
      </t>
 
      <t>
       XML attributes should only be used for meta-data.
       The 'operation' attribute (as defined in NETCONF) can only be applied to
       an XML subtree, not an individual XML attribute.
      </t>
 
      <t>
       XML elements should be used for configuration data values.
       The 'operation' attribute can only be applied to
       an XML element or subtree.  Agent-supplied XML attributes
       representing meta-data such as a 'last-changed' timestamp, 
       cannot be defined other XML attributes.
      </t>
 
      <t>
       Indexed data should be located within a container, especially
       if access is likely to be relevant for that data.
       Typically, a container only contains zero or more instances
       of the same child data object node.
      </t>
 
      <t>
       This container convention allows for easier support
       for SMIv2 type of tabular data within a NETCONF configuration
       database.
      </t>
 
      <t>
       The following example shows a container naming example:
 
       <figure anchor="NCX_container_example">
        <artwork>
<![CDATA[

    <config xmlns="NETCONF-base">
     <fooApp xmlns="fooAppNS">
      <widgets>
       <widget>
        ...
       </widget>
       <widget>
        ...
       </widget>
       <widget>
        ...
       </widget>
      </widgets>
     </fooApp>
    </config>

]]>
        </artwork>
       </figure>
      </t>

      <t>
       The 'anyType' XSD data type should not be used within a
       NETCONF configuration database.  If it is, then the
       edit-config sub-operations (e.g., create, merge) are
       not interoperable across agent implementations, if they
       appear within any of the child nodes of the node content.
      </t>

      <t>
       If the agent supports the '#notification' capability, then
       it should generate some sort of 'configuration change'
       event notification when the &lt;running&gt; and/or &lt;startup&gt; 
       configuration is modified by any mechanism, even if it is
       external to the NETCONF protocol.
      </t>

      <t>
       When generating &lt;copy-config&gt; operation output,
       the same access control procedures are applied as
       for the &lt;edit-config&gt;, as if the manager was 'replacing'
       the entire contents of the &lt;config&gt; element.
      </t>

      <t>
       The agent may provide a list of supported data models
       during the &lt;hello&gt; exchange. However,
       an operator should be aware that sensitive
       information may be revealed by including the list of supported
       data models within this message.  There is no mandatory 
       access control in effect until the session is ready to
       process &lt;rpc&gt; requests.
      </t>

      <t>
       The agent should provide a data model which can be retrieved with 
       the &lt;get&gt; operation, which indicates the data models and their
       versions, to a manager.
      </t>

      <t>
       When closing a NETCONF session, a manager should always
       use the &lt;close-session&gt; operation, if the agent
       should be accepting &lt;rpc&gt; requests at the time.
      </t>

      <t>
       When closing a NETCONF session, and the agent is currently sending
       notifications, a manager should always
       use the &lt;kill-session&gt; operation (from a different
       session).
      </t>

      <t>
       A manager should avoid terminating a NETCONF session by simply
       closing the transport connection.
      </t>

      <t>
       Exception might occur if the agent is not responding, or the
       agent is not sending well-formed XML, or if
       the manager receives a &lt;hello&gt; message from the agent
       that it does not understand or support.
      </t>
     </list>
    </t>
   </section>

   <section title="Agent Conformance Requirements">
    <t>
     The following requirements apply to NETCONF capabilities:
     <list style="symbols">
      <t>
       An agent must implement all of the required functionality
       associated with a capability in order to advertise it in
       a &lt;hello&gt; message.
      </t>
      <t>
       Capabilities must represent behavior which applies to the entire
       agent, not to some sub-agent or subset of the configuration database.
      </t>
      <t>
       Capabilities values should not change dynamically during normal operation
       of the agent.
      </t>
      <t>
       The capabilities returned by the agent in a &lt;hello&gt; message, 
       should remain in effect for the lifetime of the session.  If this is
       not possible, the agent should terminate the session instead
       of processing new &lt;rpc&gt; requests for the session.
      </t>
     </list>
    </t>
    <t>
     [More requirements TBD.]
    </t>
   </section> 
 
   <section title="Definition Change Control Guidelines">
    <t>
     There are some guidelines for ensuring that different versions
     of the same object are backward-compatible across
     different versions of an agent implementation.
    </t>
    <t>
     The following types of definitions must never be changed,
     once they are published and implemented by the agent:
     <list style="symbols">
      <t>owner names</t>
      <t>application header node names</t>
      <t>XML element names</t>
      <t>XML attribute names</t>
      <t>object names</t>
      <t>RPC method names</t>
      <t>RPC method parameter names</t>
      <t>notification event type names</t>
      <t>Basic XML syntax of an object</t>
      <t>
       Basic conceptual semantics of an object, RPC method
       or its existing parameters, or a notification.
      </t>
     </list>
    </t>
 
    <t>
     The following types of definitions should not be changed,
     once they are published and implemented by the agent:
 
     <list style="symbols">
      <t>data object default values</t>
      <t>RPC method classification values</t>
      <t>configuration object classification values</t>
      <t>notification event classification values</t>
     </list>
    </t>
 
    <t>
     A data model (module) version identifier should be updated 
     to a previously unused value whenever any part of it
     is modified by the data model publisher.
    </t>
 
    <t>
     Several type of data model extensions are permitted, except
     that the version identifier should be updated appropriately
     when the modified schema definition is published.
 
     <list style="symbols">
      <t>
       Add any new objects, RPC methods, and/or notifications.
      </t>
      <t>
       Add new parameters to an RPC method.
      </t>
      <t>
       Add new child nodes to objects.
      </t>
      <t>
       Change, add, or remove a range definition.
      </t>
      <t>
       Change, add, or remove a range definition, or other such
       data type restrictions.
      </t>
      <t>
       Change, add, or remove the access control semantics for
       an object.
      </t>
      <t>
       Change, add, or remove any data object content 
       within an event notification message.
      </t>
     </list>
    </t>
   </section>
  </section>

  <section anchor="Acknowledgements" title="Acknowledgements">
   <t>
    The author wishes to thank Keith McCloghrie for review comments
    and Martin Bjorklund for help on the Instance Identifier details.
   </t>
  </section>

   <!-- Possibly a 'Contributors' section ... -->

  <section anchor="IANA" title="IANA Considerations">
   <t>
    There are three registries that need to be maintained by IANA
    to simplify XML usage within the NETCONF protocol.
    <list style="numbers">
     <t>owner strings</t>
     <t>application header nodes</t>
     <t>data model schema locations</t>
    </list> 
   </t>
   <section title="Owner Registry">
    <t>
     A registry is needed for short name strings that uniquely identify
     an NCX owner name. 
    </t>
    <t>
     Each owner string should be associated with the
     organization name and some contact information, similar
     to the Enterprise numbers registry.
    </t>
    <t>
     Each registry entry will include:
     <list style="symbols">
      <t>the owner name string</t>
      <t>organization name</t>
      <t>contact info</t>
      <t>enterpriseN owner name (if any)</t>
     </list>
    </t>

    <t>
     The initial registry will contain an entry for the 'ietf' owner:

     <figure anchor="Owner_registry_entry">
      <artwork>
<![CDATA[

    Owner name: ietf
    Organization name: Internet Engineering Task Force
    Contact Info: (TBD) netconf@ops.ietf.org
    Enterprise ID: enterprise0

]]>
      </artwork>
     </figure>
    </t>


    <t>
     In addition to 'ietf', reserved entries for each Enterprise number
     are also implicitly defined.  Therefore, no
     assignments of the form 'enterpriseN' are allowed,
     where N is any non-negative integer.
    </t>
    <t>
     [open issue: owner string format: US-ASCII or UTF-8?]
    </t>
    <t>
     [open issue: owner string length restrictions?]
    </t>
   </section>

   <section title="Application Header Node Registry">
    <t>
     A registry is needed for the QName assignments (namespace URI and
     element name) for each application header node in the standard
     NETCONF MIB.  It is also desirable for vendors to register
     their own application header nodes as needed.
    </t>
    <t>
     Each registry entry will include:
     <list style="symbols">
      <t>the owner name associated with the application</t>
      <t>the application element name</t>
      <t>the application element namespace URI</t>
      <t>the URL for the schema containing the application element definition</t>
      <t>A short description of the application purpose.</t>
     </list>
    </t>
    <t>
     The initial registry will be empty.
    </t>
   </section>

   <section title="Data Model Schema Location Registry">
    <t>
     A registry is needed for information related to the
     various (standard or proprietary) data models potentially
     available for use with the NETCONF protocol.
    </t>
    <t>
     Each registry entry will include:
     <list style="symbols">
      <t>the owner name associated with the data model</t>
      <t>the application name (if any) associated with the data model</t>
      <t>the data model version string</t>
      <t>the data model target namespace URI</t>
      <t>the data model schema location URL</t>
      <t>the data model top-level object element name(s)</t>   
      <t>A short description of the data model's purpose.</t>
     </list>
    </t>
    <t>
     The initial registry will be empty.
    </t>
   </section>
  </section>

  <section anchor="Security" title="Security Considerations">
   <t>
    This entire document discusses
    guidelines for organizing NETCONF configuration data,
    and improving NETCONF protocol operational security.
    Some NETCONF agent security and deployment guidelines
    are discussed as well.
   </t>

   <t>
    However, this document does not define
    any new protocol mechanisms or extensions.  It does not
    contradict or alter any of the security requirements
    defined for NETCONF in RFC 4741.  This document does not
    define any data models as well.
   </t>

   <t>
    [Real security considerations section TBD.]
   </t>
  </section>

 </middle>

  <!--  ***** BACK MATTER ***** -->
 <back>
  <references title="Normative References">
    &rfc2119;
    &rfc4741;
  </references>

  <references title="Informative References">
    &rfc2578;
  </references>
 </back>

</rfc>

