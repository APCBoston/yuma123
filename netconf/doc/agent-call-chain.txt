
RPC PDU Callback Path
---------------------

Note that <rpc-error> generation can occur throughout this 
sequence, but that call path is not shown. Refer to documentation
on the 'agt_record_error' and 'agt_record_attr_error' functions
for details on PDU error handling.

1) session gets incoming PDU

   - Uses Session Control Block (scb) to stream input to agent

2) top_dispatch_msg(scb)

   - Receives the top level element in the PDU 
   - Determines the owner of the namespace (if any)
   - Dispatches element to one of its registered nodes 
     by (owner, elname), or generates an error if no
     'top' callback is registered for the node

3) rpc_agt_dispatch(scb, top)

   - receives 'top' (== <rpc>) element and saves all attributes
   - creates an rpc_msg_t (msg) and initializes it
   - looks for NCX group-id attribute
   - looks for NETCONF message-id attribute
   - parses method name node (startnode)
   - finds corresponding callback function for that method node
   - (ACL) checks if user is allowed to invoke this RPC method (psd)
   - SETUP PHASE:
     - check if a RPC_AGT_PH_SETUP callback is installed, and
       invoke it if there is one
   - PSD PHASE: psd_state: 
     calls user parse function if registered or ps_parse_nc if not
     (It would be very rare to override the parmset parse callback).
     The callback is expected to fill in a malloced parmset (ps).
    
4) ps_parse_nc(scb, msg, psd, startnode, ps)
  
   - loops through all parameters until 'startnode' end node is reached

     - consumes a child start node and matches it against the parameters 
       in 'psd'.  (parmtop)
     - Strict or loose parm order is enforced, based on the PSD.
     - new ps_parm containing a val_value_t (val) is malloced and 
       initialized.
     - val_parse_nc is called and is expected to read the contents
       of this parameter and fill in the 'val' data struct.
       Val may become a tree if this is a complex type, or be filled
       in if this is a simple type.

5) val_parse_nc(scb, msg, psd, val)
   
   - parse_btype_nc()
     recursive function to dispatch to specific parse functions
     based on the data type.  If a complex type is encountered
     (struct, choice, table, contable) then this function will
     be called recursively to dispatch the child node.  This
     continues all the way to the leaf nodes.

     a) each node first parses metadata (XML attributes)
     b) data type content is parsed and any restrictions
        patterns, or regular expressions are checked
     c) metadata instance counts are validated
     d) instance qualifiers for each metadata are checked
        and considered in the instance count check
     

6) [return to ps_parse_nc]
   - Any errors at this point will cause the parameter to be
     marked with an error (ps).
   - If there are no errors, the parm value is saved
   - If any more parms, goto step 4, else step 7
     
7) [return to rpc_agt_dispatch:psd_state]
   - check for extra input after the <rpc> element
   - post_psd_state:
     - add default values to the RPC parmset as needed;
       Do not add defaults for parms within a 'choice' construct;
       This will cause an error if multiple choice arms have defaults.
     - Validate any 'choice' constructs in the parmset:
       a) at least one choice must be made
       b) if the choice made is part of a block, then all parameters
          in the block must be present.  Defaults are applied if
          available for any missing parms within a block.
     - Validate that the proper number of instances are present
       for each parameter.  This takes into account the data type
       and any instance qualifiers specified for the data type.

8) [return to rpc_agt_dispatch]
   VALIDATE PHASE:
   - Check if a user validate callback is installed for this
     RPC method, and call it if so (Usually there is only a
     validate callback to check locks, related parameters,
     current context, etc.)
 
9) edit_config_validate
   - check the target config exists and ok to write
   - get edit-config options and save them
   - call agt_ps_validate_write for <config> parameter

10) agt_ps_validate_write
    - validate_write_val
      - check nested edit operation and convert it based on 
        cur/new heuristic
      - if editop okay, then invoke agt_val_invoke_callback    

11) agt_val_invoke_callback
    - invoke_btype_cb
      - invoke_anyps_cb
        - for each parmset in each app node
          - find parmset def (PSD) for the parmset
          - check access control
          - 
    
 
    - if edit-config and continue-on-error, the return NO_ERR
      no matter what
     
12) [return to rpc_agt_dispatch]
    
    INVOKE PHASE

   - if no errors and an invoke callback exists for this RPC,
     then execute it.  Since the 'rpc' definitions are loaded
     before the callbacks are loaded, it is theoretically 
     possible to pass through a vendor RPC call with flying colors
     and it is really a NO-OP, because no callbacks are loaded
     yet.  It is TBD to fully support this sub-mode as a
     pre-provisioning feature.
   
13) edit_config_invoke
    - retrieve parameters stored in rpc msg
    

14) agt_ps_apply_write
    - top node is expected to be a config root (type anyps)
    - for each app node, for each parmset in each appnode :
       - manipulate config layer data structures
       - invoke user callback (if any) for this parmset
       - (TBD) add a config audit record as needed

15) [return to rpc_agt_dispatch]

    - TBD: Need to handle roolback-on-error at this point
    - TBD: need to check for a partial operation, and if so
      generate the proper rpc_err_rec_t struct for this complex 
      error report

    PRE-REPLY PHASE
    - check if an RPC_AGT_PH_PRERPY callback exists and invoke
      it if so. (This is for agent post-config-cleanup, etc.)

16) REPLY PHASE
    - check if an RPC_AGT_PH_RPY callback exists and invoke
      it if so. (This is for agent-specific reply generation, 
      which is not expected to be used.
    - if no user callback, then invoke send_rpc_reply instead.
      This is the normal case.

17) send_rpc_reply
    - check msg->res, the rpc_errQ, and the reply data structure
      to see what needs to be generated.
   - build a namespace prefix map from the <rpc> element, in order
     to use the same xmlns decls as the request.
   - generate all elements and attributes on the fly as much as possible.
     No NETCONF layer buffers are used for <rpc-reply> output.
   - generate the <rpc-error> elements in the order the rpc_err_rec_t
     structs appear in the rpc_errQ, if any.
   - check if there is a user response callback specified in the reply.
     If so, then invoke the user callback to generate the response data
   - If no user callback, then check if any static data is present in
     the rpc_msg_t instead. If so, generate the output.  Otherwise
     an empty <data> element might be generated (if data expected
     and no errors indicated).

