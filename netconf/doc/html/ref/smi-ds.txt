






Internet Draft                                             Andy Bierman
                                                     Cisco Systems, Inc.
                                                           15 June 2002


                  Structure of Management Information:
                            Data Structures


                      <draft-ietf-sming-ds-01.txt>





Status of this Memo

This document is an Internet-Draft and is in full conformance with all
provisions of Section 10 of RFC2026 [RFC2026].

Internet-Drafts are working documents of the Internet Engineering Task
Force (IETF), its areas, and its working groups.  Note that other groups
may also distribute working documents as Internet-Drafts.

Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any
time.  It is inappropriate to use Internet-Drafts as reference material
or to cite them other than as "work in progress".

The list of current Internet-Drafts can be accessed at
http://www.ietf.org/ietf/1id-abstracts.txt

The list of Internet-Draft Shadow Directories can be accessed at
http://www.ietf.org/shadow.html.

Distribution of this document is unlimited. Please send comments to the
SMIng WG mailing list <sming@ops.ietf.org>.

1.  Copyright Notice

Copyright (C) The Internet Society (2002).  All Rights Reserved.















Internet Draft             SMI Data Structures             June 15, 2002


2.  Abstract

This memo defines a portion of the Structure of Management Information
(SMI) for use with network management protocols in the Internet
community.  In particular, it describes a new structure and naming
scheme for network management information, allowing the specification of
arbitrarily complex hierarchical data structures.

3.  Table of Contents

replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC
replace with TOC





Expires December 15, 2002                                       [Page 2]





Internet Draft             SMI Data Structures             June 15, 2002


4.  The SNMP Network Management Framework

   The SNMP Management Framework presently consists of five major
   components:

    o   An overall architecture, described in RFC 2571 [RFC2571].

    o   Mechanisms for describing and naming objects and events for the
        purpose of management. The first version of this Structure of
        Management Information (SMI) is called SMIv1 and described in
        RFC 1155 [RFC1155], RFC 1212 [RFC1212] and RFC 1215 [RFC1215].
        The second version, called SMIv2, is described in RFC 2578
        [RFC2578], RFC 2579 [RFC2579] and RFC 2580 [RFC2580].

    o   Message protocols for transferring management information. The
        first version of the SNMP message protocol is called SNMPv1 and
        described in RFC 1157 [RFC1157]. A second version of the SNMP
        message protocol, which is not an Internet standards track
        protocol, is called SNMPv2c and described in RFC 1901 [RFC1901]
        and RFC 1906 [RFC1906].  The third version of the message
        protocol is called SNMPv3 and described in RFC 1906 [RFC1906],
        RFC 2572 [RFC2572] and RFC 2574 [RFC2574].

    o   Protocol operations for accessing management information. The
        first set of protocol operations and associated PDU formats is
        described in RFC 1157 [RFC1157]. A second set of protocol
        operations and associated PDU formats is described in RFC 1905
        [RFC1905].

    o   A set of fundamental applications described in RFC 2573
        [RFC2573] and the view-based access control mechanism described
        in RFC 2575 [RFC2575].

   A more detailed introduction to the current SNMP Management Framework
   can be found in RFC 2570 [RFC2570].

   Managed objects are accessed via a virtual information store, termed
   the Management Information Base or MIB.  Objects in the MIB are
   defined using the mechanisms defined in the SMI.

   This memo does not specify a MIB module.









Expires December 15, 2002                                       [Page 3]





Internet Draft             SMI Data Structures             June 15, 2002


5.  Overview

There is a need for a standardized way of defining aggregated data
structures for the representation of management information, which can
be utilized with existing and future versions of SNMP. The SMIv2 data
model is based on groups of rectangular tables, which are related
because they share one or more INDEX clause components. This model
provides a single containment layer per table, because all the objects
in a conceptual row must be simple types (e.g., Integer32,
SnmpAdminString, Counter64).

The practice of spreading a multi-layer data structure across several
rectangular tables causes MIB modules to be much too verbose, hard to
understand, and even harder to implement.  The containment relationships
between tables are usually described in INDEX clauses and various
DESCRIPTION clauses.

This practice has a negative impact on agent implementations, which are
harder to implement and test, due to row creation and row activation
ordering issues.  This practice adds complexity to management
application development as well.

Software development and human readability would benefit from a data
definition language which more closely represents the basic data
structures that exist in almost all programming languages.

[ed. - This revision is intended to introduce the SMI Data Structure
concepts and is not yet defined in sufficient detail to be suitable as a
formal specification.]

5.1.  Terms

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119. [RFC2119]

This document uses some terms that need introduction:

Aggregated Data Object
     This term refers to any data object which provides some sort of
     containment for other data objects, which is any variable construct
     other than SCALAR (e.g., ARRAY, UNION, or STRUCT).

Data Object
     This term refers to any SMI Data Structure variable declaration, at





Expires December 15, 2002                                       [Page 4]





Internet Draft             SMI Data Structures             June 15, 2002


     any level of containment.

MIB Object
     This term generically refers to a SMIv2 OBJECT-TYPE macro
     definition.  It may also refer to an SMI Data Structure definition.

OID  This is a shorthand term for 'OBJECT IDENTIFIER'.

SCALAR
     This term refers to any accessible data object with a syntax that
     resolves to a SMI base type.

SMI Data Structure (SMI-DS)
     This term refers to the concepts and definitions defined in this
     document.

5.2.  Design Objectives

The working group objectives for this work are detailed in the SMIng
Objectives document [RFC3216].  (Refer to Appendix D for a detailed
discussion of each accepted objective.)

The primary high-level design goals of this work are:

   - Significantly enhance the usefulness of the SMI as a network
     management data definition language, by creating a modern
     programming language like data model supporting aggregated
     containment.

   - Enhance SMI object instance naming to support aggregated
     hierarchical data structures, while remaining backwardly-compatible
     with SMIv2 naming.

   - Improve readability by enhancing reusability and removing as much
     redundant text as possible. The SMI should be as easy to use as
     possible, for the largest number of people. Therefore, a priority
     hierarchy can be established, starting with MIB readers, then MIB
     writers, management software developers, and MIB compiler writers.

   - Maintain 100% forward and backward translation compatibility with
     SMIv2.  It must be possible to convert all valid SMIv2 constructs
     to SMI-DS constructs without loss of semantics (i.e., forward
     compatibility). It should also be possible to translate any SMI-DS
     construct to one or more SMIv2 constructs, if the associated
     feature(s) exist in SMIv2.  Refer to Appendix A for details on





Expires December 15, 2002                                       [Page 5]





Internet Draft             SMI Data Structures             June 15, 2002


     SMIv2 <--> SMI-DS translations.

   - Preserve as many of the SMIv2 mechanisms and 'installed knowledge-
     base' as possible.  There will a transition period lasting several
     years, in which SMIv2 MIBs will be converted to SMIv3 format.  It
     is important that MIB readers and writers be able to understand
     both SMI syntaxes during this period, and so it will be beneficial
     to keep them as close as possible.  Clauses that have not changed
     at all in semantics between SMI versions should maintain the same
     syntax.

   - Make sure accessible data objects (i.e., SCALAR objects) can be
     used with existing versions of SNMP.

There are some relevant topics which not design objectives addressed by
this draft:

   - Compatibility with any version of ASN.1.

   - Equally weighted importance for support of COPS-PR and SNMP.  There
     is a huge disparity in deployment of applications utilizing these
     protocols. The solution space is biased in favor of SNMP because
     that will benefit the largest number of people.

  -  Idiot proof MIB design. Data structures can help better organize
     the information found in a MIB, but they cannot prevent bad design
     choices or badly written DESCRIPTION clauses.

5.3.  Data Structure Constructs

There are four basic constructs available in the SMI-DS language for the
definition of data objects.

SCALAR
     This construct is conceptually equivalent to an OBJECT-TYPE macro
     definition for an accessible MIB object in SMIv2, except a SCALAR
     can be defined at any level of containment. A SCALAR type
     definition or variable declaration resolves to any SMIng base type.
     In SMI-DS, all other constructs must eventually resolve to some
     number of these objects, and only SCALAR data objects are actually
     accessible via SNMP.

ARRAY
     This construct provides a multi-dimensional array structure,
     similar to the SEQUENCE construct in SMIv2.  However, instead of





Expires December 15, 2002                                       [Page 6]





Internet Draft             SMI Data Structures             June 15, 2002


     one flat 'row' consisting of only accessible base-type MIB objects,
     an ARRAY can consist of an arbitrary mix of any of the four types
     of data object constructs.  Only base type data objects can be used
     in an ARRAY INDEX clause (the same ones as in SMIv2), and the rules
     for encoding INDEX clause base types in OIDs are the same as for
     SMIv2.

UNION
     This construct provides a mechanism to conceptually allow a single
     object definition to contain one of potentially several different
     construct definitions.  Only one of these constructs is actually
     instantiated at any time by the agent. Unlike a union in the C
     language, the unused union members cannot be accessed at all (no
     'cast' operator in SMI).

STRUCT
     This construct provides a mechanism to group an arbitrary number of
     data constructs (of any type), allowing a theoretically unlimited
     number of data containment layers.  It is similar to the ARRAY
     construct, except there is no INDEX clause.

5.4.  Relationship to SMIv2

Whenever possible, existing SMIv2 macros or clauses have been used
without modification.  Two exceptions are the TEXTUAL-CONVENTION and
OBJECT-TYPE macros. In order to reinforce and support a data model more
aligned with popular programming concepts and practices, these macros
have been replaced by the TYPE and VAR macros (respectively).  Strong
emphasis is placed on the separation of potentially reusable type
definitions and variable declarations. The ASN.1 tabular data model is
replaced with a 'hierarchical containment' data model, which is more
similar to the 'native' data representation used by the managed device.

The type of declarations that can be made in an SMI-DS module do not
really change at all, but some constructs have changed. The major
differences between an SMIv2 construct and the equivalent SMI-DS
construct are listed in the table below:

          SMIv2                     SMI-DS
   ---------------------     ---------------------
   TEXTUAL-CONVENTION        TYPE SCALAR
   scalar OBJECT-TYPE        VAR SCALAR
   tabular OBJECT-TYPE       VAR ARRAY
   NOTIFICATION-TYPE         NOTIFICATION






Expires December 15, 2002                                       [Page 7]





Internet Draft             SMI Data Structures             June 15, 2002


Notification semantics have not changed at all, although the syntax has
changed slightly to make them more consistent with the TYPE and VAR
macros.  The ASN.1 specific SEQUENCE macro, and the 'FooTable' and
'FooEntry' OBJECT-TYPE definitions that start every SMIv2 table are
removed.  The basic SYNTAX clause has not changed at all, except that a
new variant is provided to specify a typed OID pointer (see section
5.8).

Many constructs do not change at all, such as the IMPORTS, MODULE-
IDENTITY, MAX-ACCESS, STATUS, DESCRIPTION, REFERENCE, DEFVAL, OBJECTS,
and MODULE-COMPLIANCE macros.

5.5.  Hierarchical Instance Naming

In order to fully utilize the capabilities of arbitrary containment, a
new way of naming object instances is needed, which is designed for
hierarchical data structures instead of tables, without changing the OID
values for any existing SMIv2 objects which are converted to the SMI-DS
object naming format.

Since it is possible for accessible objects to exist in the same
containment structure as non-accessible objects, it is not possible to
name SMI-DS objects with a 'flat' model. SMIv2 assumes all accessible
objects in the same containment structure have the same number of object
identifier components, and the exact same format for all instance
identifier components.  This assumption cannot be made for SMI-DS object
naming.

This new naming scheme can help reduce implementation complexity for
agent and application developers for SNMP Set operations.  Currently,
associated attributes can be spread across multiple tables, (possibly
sharing major indexes) each with their own RowStatus and set of 'SNMP
callback' functions. This design approach can get relatively
complicated, especially if 'createAndWait' and 'notInService' RowStatus
values are supported.  By allowing aggregated containment instead of
unfolding data structures into tables, implementation of high-level Set
operations can be simplified for both agent and application developers.

The basic format of an OID for an SMI-DS data object is not changed from
SMIv2. OIDs are constructed left to right. The left fragment contains
static OID values which indicate the name of a node in the MIB tree.
The right fragment contains potentially dynamic OID values which
represent the instance identifier for the node specified by the left
fragment.






Expires December 15, 2002                                       [Page 8]





Internet Draft             SMI Data Structures             June 15, 2002


Non-Aggregate Data Object Naming
--------------------------------

   A non-aggregate variable declaration is named as follows:

      <oidBase>.0

    where:

      <oidBase> is a well-formed OID base fragment.


Aggregate Data Object Naming
----------------------------

   An Aggregated Data Object variable declaration is named
   as follows:

      <oidBase>.<compatNode>.<childNode>
           [.<childNode> ...] [.<indexNode> ...]

    where:

      <oidBase> is a well-formed OID base fragment,
          (also called the left anchor).

      <compatNode> contains the value 1.

      <childNode> is the data object child node identifier, which
          must be an INTEGER between 1 and 4294967295. (Similar
          to a column identifier in an SMIv2 table.)

      <indexNode> is present only if the variable declaration
          resolves to a type that contains any ARRAY constructs,
          and MUST be an INTEGER between 0 and 4294967295.
          (Similar to an instance identifier in an SMIv2 table.)

SMI-DS OID Construction
-----------------------

OIDs are constructed in an iterative manner, using two conceptual
buffers:

base buffer
     used for building the static portion of an OID, left to right.





Expires December 15, 2002                                       [Page 9]





Internet Draft             SMI Data Structures             June 15, 2002


     This buffer contains the <oidBase>, <compatNode>, and all
     <childNode> identifiers.

index buffer
     used for building a sequence of ARRAY indexes, (left to right),
     similar to the instance identifier portion of an SMIv2 OID for a
     tabular object. This buffer contains all the <indexNode>
     identifiers.

The expansion algorithm for <childNode> is repeated if it represents an
aggregated data object. If it represents an ARRAY construct, then all
<indexNode> components for this array type are appended to index buffer.

The algorithm terminates when a SCALAR data object is encountered.  The
index buffer is then appended to the base buffer, to form the complete
instance identifier for a specific variable declaration.

5.6.  SMI-DS Data Object Usage Examples

The following sections introduce some examples of simple data structures
that are currently achieved with relatively verbose text in TEXTUAL-
CONVENTION and OBJECT-TYPE DESCRIPTION clauses using SMIv2.  Refer to
Appendix B for an example of a (somewhat) complete SMI-DS module.

5.6.1.  InetAddress Example

The Internet Address textual conventions defined in the "Textual
Conventions for Internet Network Addresses" MIB module [RFC2851] defines
several variants of an Internet address (InetAddress), and a control
object (InetAddressType) to distinguish which variant is actually
present in an InetAddress object instance.  This construct may be more
concisely and properly represented in SMI-DS by a structure containing
the control object and a union of all the address variants.

-- a union of all the InetAddress types

TYPE UNION InetAddressUnion {
    DESCRIPTION
       "Internet address in 4 different representations."

    ATTRIBUTE SCALAR ipUnknown {
       SYNTAX      OCTET STRING (SIZE (0..65535))
       MAX-ACCESS  read-create
       DESCRIPTION
           "Represents an Internet address using an externally





Expires December 15, 2002                                      [Page 10]





Internet Draft             SMI Data Structures             June 15, 2002


            defined format. The associated InetAddressType
            object value is 'unknown(0)'."
    } = 1

    ATTRIBUTE SCALAR ipv4Addr {
       SYNTAX      InetAddressIPv4
       MAX-ACCESS  read-create
       DESCRIPTION
           "Represents an IPv4 Internet address. The
            associated InetAddressType object value
            is 'ipv4(1)'."
    } = 2

    ATTRIBUTE SCALAR ipv6Addr {
       SYNTAX      InetAddressIPv6
       MAX-ACCESS  read-create
       DESCRIPTION
           "Represents an IPv6 Internet address. The
            associated InetAddressType object value
            is 'ipv6(2)'."
    } = 3

    ATTRIBUTE SCALAR ipDnsAddr {
       SYNTAX      InetAddressDNS
       MAX-ACCESS  read-create
       DESCRIPTION
           "Represents an DNS domain name.  The associated
            InetAddressType object value is 'dns(16)'."
    } = 4
}

TYPE STRUCT HostInetAddress {
    DESCRIPTION
       "Internet address for an end-station host, adhering
        to the SMIv2 'associated objects' design approach."

    ATTRIBUTE SCALAR addrType {
       SYNTAX      InetAddressType
       MAX-ACCESS  read-create
       DESCRIPTION
           "The type of Internet address."
    } = 1

    ATTRIBUTE UNION addr {
       SYNTAX      InetAddressUnion





Expires December 15, 2002                                      [Page 11]





Internet Draft             SMI Data Structures             June 15, 2002


       STATUS      current
       DESCRIPTION
           "The Internet address."
    } = 2
}

VAR STRUCT myAddress {
    SYNTAX      HostInetAddress
    MAX-ACCESS  read-only
    DESCRIPTION
        "Internet address of this host."
} ::= { someBase 1 }

VAR UNION newAddress {
    SYNTAX      InetAddressUnion
    MAX-ACCESS  read-write
    DESCRIPTION
        "Example of the new way to represent a union variable,
         without the use of an associated InetAddressType object."
} ::= { someBase 2 }

Note 1) The accessible object instances defined within this structure
(addrType, ipUnknown, ipv4Addr, ipv6Addr, etc.)  have different lengths:

  myAddress                ::= { someBase 1 }
  myAddress.addrType       ::= { myAddress 1 1 }
  myAddress.addr           ::= { myAddress 1 2 }
  myAddress.addr.ipUnknown ::= { myAddress 1 2 1 }
  myAddress.addr.ipv4Addr  ::= { myAddress 1 2 2 }
  myAddress.addr.ipv6Addr  ::= { myAddress 1 2 3 }
  myAddress.addr.dnsAddr   ::= { myAddress 1 2 4 }

  newAddress               ::= { someBase 2 }
  newAddress.ipUnknown     ::= { newAddress 1 1 }
  newAddress.ipv4Addr      ::= { newAddress 1 2 }
  newAddress.ipv6Addr      ::= { newAddress 1 3 }
  newAddress.dnsAddr       ::= { newAddress 1 4 }


Note 2) The mandatory MAX-ACCESS clause within a SCALAR construct in a
TYPE macro is used to specify the maximum access level that is possible
via a management protocol.  The optional MAX-ACCESS clause within a VAR
macro is used to specify the constrained maximum access level for that
specific variable declaration, and must not specify a higher access than
declared within a TYPE macro. (E.g., myAddress is a read-only variable





Expires December 15, 2002                                      [Page 12]





Internet Draft             SMI Data Structures             June 15, 2002


even though the SCALAR nodes in the HostInetAddress TYPE are read-
create. The same SCALAR nodes used within the newAddress variable
declaration are read-write.)  If an overall MAX-ACCESS clause is not
present in the VAR macro, then the values specified in the SCALAR nodes
are used.

Note 3) The addrType field is not actually needed for simple variable
declarations, because UNION constructs are instantiated with at most one
accessible member.  In the example above, a GetNext Request for
'myAddress.addr' or 'newAddress' will return only one type of
InetAddress string from the InetAddressUnion.  The associated
InetAddressType variable is needed only when used together with the
InetAddress (generic string form) as INDEX components in an ARRAY.

Note 4) Just like a TEXTUAL-CONVENTION in SMIv2, a TYPE has no instances
associated with it and therefore no MIB root assigned.  It is only when
a a variable of a particular type is declared (and therefore assigned a
MIB root) that the full OID for a data object is known.

5.6.2.  Generic High Capacity Counter Example

There are many MIBs that contain up to the three OBJECT-TYPE macro
definitions for every high capacity counter, in order to accommodate
SNMPv1 implementations without support for Counter64 and 32-bit
implementations without any high capacity support at all.

A type definition (GenericCounter) for a union that contains an object
for each of the three scenarios would better represent the intended
semantics of this design, and use less text within data structure
definitions than an SMIv2 version. Note that a discriminator object is
not needed for a union, because the agent (or management application)
will instantiate at most one of the variants.

TYPE UNION GenericCounter {
    DESCRIPTION
       "Generic counter for all versions of SNMP."

    ATTRIBUTE SCALAR c32 {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       DESCRIPTION
           "The Counter32 representation of the counter."
    } = 1

    ATTRIBUTE SCALAR c64 {





Expires December 15, 2002                                      [Page 13]





Internet Draft             SMI Data Structures             June 15, 2002


       SYNTAX      Counter64
       MAX-ACCESS  read-only
       DESCRIPTION
           "The Counter64 representation of the counter."
    } = 2

    ATTRIBUTE STRUCT c32pair {
        DESCRIPTION
            "Pair of Counter32 objects to represent a 64-bit
             counter."

        ATTRIBUTE SCALAR c32low {
            SYNTAX      Counter32
            MAX-ACCESS  read-only
            STATUS      deprecated
            DESCRIPTION
                "The lower 32 bits of a 64 bit counter."
        } = 1

        ATTRIBUTE SCALAR c32hi {
            SYNTAX      Counter32
            MAX-ACCESS  read-only
            STATUS      deprecated
            DESCRIPTION
                "The upper 32 bits of a 64 bit counter."
        } = 2
    } = 3
}

VAR UNION myCounter {
    SYNTAX      GenericCounter
    DESCRIPTION
       "An example generic counter variable."
} ::= { someBase 3 }

Note 1) Inline vs. external type definition: The 'c32pair' STRUCT could
have been defined as a separate type and a STRUCT declared with a SYNTAX
clause that referenced that type (e.g.,  <struct-ref-type-decl> form of
the STRUCT declaration).  The instance numbering works out the same
either way.

The following OIDs would be possible for the 'myCounter' variable
declaration:

   myCounter                ::= { someBase 3 }





Expires December 15, 2002                                      [Page 14]





Internet Draft             SMI Data Structures             June 15, 2002


   myCounter.c32            ::= { myCounter 1 1 }
   myCounter.c64            ::= { myCounter 1 2 }
   myCounter.c32pair        ::= { myCounter 1 3 }
   myCounter.c32pair.c32low ::= { myCounter 1 3 1 }
   myCounter.c32pair.c32hi  ::= { myCounter 1 3 2 }

Note 2) Even though only one node of a UNION can be instantiated at any
given time, a GetNext Request for a UNION which contains other
aggregated data objects can cause multiple instances to be returned from
that sub-tree, as with the 'c32low' and 'c32hi' SCALAR objects in the
example above.

Note 3) Only the STATUS clauses for SCALAR data object definitions are
relevant for compliance section usage.  However, the above example
raises issues regarding an aggregated data object which contains a
mixture of current, deprecated, and obsolete SCALAR objects. (Is the
STATUS of the GenericCounter UNION itself current or deprecated?)

5.6.3.  Converted SMIv2 TABLE Example

The following example shows how two objects from the ifTable [RFC2863]
would be defined in SMI-DS syntax.  Note that in in this example, the
interface table is modeled directly as a variable declaration, without
using a TYPE.  This practice is discouraged for new MIB definitions.

-- this is modeled as an ARRAY variable, rather than
-- an ARRAY containing a TYPE'ed structure, to preserve
-- compatibility with SMIv2

TYPE ARRAY IfEntry {

    DESCRIPTION
        "A list of interface entries.  The number of entries
         is given by the value of ifNumber."

    INDEX { ifIndex }

    ATTRIBUTE SCALAR ifIndex {
        SYNTAX  InterfaceIndex
        MAX-ACCESS  read-only
        DESCRIPTION
            "A unique value, greater than zero, for each
             interface.  It is recommended that values are assigned
             contiguously starting from 1.  The value for each
             interface sub-layer must remain constant at least from





Expires December 15, 2002                                      [Page 15]





Internet Draft             SMI Data Structures             June 15, 2002


             one re-initialization of the entity's network
             management system to the next re-initialization."
    } = 1

    ATTRIBUTE SCALAR ifDescr {
        SYNTAX      DisplayString (SIZE (0..255))
        MAX-ACCESS  read-only
        DESCRIPTION
            "A textual string containing information about the
             interface.  This string should include the name of the
             manufacturer, the product name and the version of the
             interface hardware/software."
    } = 2

    ATTRIBUTE SCALAR ifType {
        SYNTAX      IANAifType
        MAX-ACCESS  read-only
        DESCRIPTION
            "The type of interface.  Additional values for ifType
             are assigned by the Internet Assigned Numbers
             Authority (IANA), through updating the syntax of the
             IANAifType textual convention."
    } = 3

    -- rest of ifTable SCALAR objects would follow
}

VAR ARRAY ifTable {
    SYNTAX      IfEntry
    DESCRIPTION
       "An array of interface entries."
} ::= { interfaces 2 }

Note 1) The object naming and semantics are identical to the SMIv2
version. The OIDs for instance number '17' are shown:

  ifTable                  ::= { interfaces 2 }
  ifTable[17]              ::= Not Available
  ifTable[17].ifIndex      ::= { ifTable 1 1 17 }
  ifTable[17].ifDescr      ::= { ifTable 1 2 17 }
  ifTable[17].ifType       ::= { ifTable 1 3 17 }









Expires December 15, 2002                                      [Page 16]





Internet Draft             SMI Data Structures             June 15, 2002


5.7.  Data Structure Augmentations

SMIv2 allows for MIB tables to be conceptually extended over time,
without modifying the original MIB table definition, using the AUGMENTS
clause.  This is usually done to allow vendor extensions to standard
MIBs, or to avoid editing a 'stable' RFC.

In SMI-DS, the AUGMENTS clause is preserved and adapted for use with
aggregated data objects, in order to maintain backward compatibility
with SMIv2.  Only inline variable declarations for ARRAY data objects
can be augmented.

In addition to the AUGMENTS clause, which models 1:1 existence
relationships between two ARRAY variables, a SPARSE-AUGMENTS clause is
provides to model conditional 1:1 existence relationships between the
augmenting ARRAY variable and the augmented ARRAY variable.

The AUGMENTS construct defines one or more nodes which are conceptually
added to the outermost containment layer of the augmented ARRAY
variable.  The augmenting ARRAY variable inherits all of the index
components of that ARRAY (exactly as with SMIv2).

A variant of the AUGMENTS construct is provided (called SPARSE-AUGMENTS)
for situations in which a static subset of an existing ARRAY is
augmented. The DESCRIPTION clause for an ARRAY which is a sparse
augmentation MUST explain the relationship between the augmenting and
augmented table.

The AUGMENTS clause in SMIv2 references the internal table node (e.g.,
ifEntry, not ifTable), but SMI-DS ARRAY variables do not need or use
this internal construct.  To remain compatible with SMIv2, an OBJECT
IDENTIFIER macro is used to declare an object descriptor which can be
used in AUGMENTS and SPARSE-AUGMENTS clauses.

AUGMENTS Example
----------------

The following trivial example shows how some high-capacity counters and
time-related attributes might be added to an existing array of packet
statistics.

TYPE ARRAY InetHostStats {
    DESCRIPTION
        "Example of a IP host stats table."






Expires December 15, 2002                                      [Page 17]





Internet Draft             SMI Data Structures             June 15, 2002


    INDEX { ifIndex, inetAddrType, inetAddr }

    ATTRIBUTE SCALAR inetAddrType {
        SYNTAX  InetAddressType
        MAX-ACCESS  not-accessible
        DESCRIPTION
            "The IP address type for the array entry.
             The InetAddressType values 'unknown(1)' and
             'dns(16)' are not allowed."
    } = 1

    ATTRIBUTE SCALAR inetAddr {
        SYNTAX  InetAddress
        MAX-ACCESS  not-accessible
        DESCRIPTION
            "The IP address for the array entry."
    } = 2

    ATTRIBUTE SCALAR inPkts {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       DESCRIPTION
          "The number of packets received by the specified host
           on the specified interface."
    } = 3

    ATTRIBUTE SCALAR outPkts {
       SYNTAX      Counter32
       MAX-ACCESS  read-only
       DESCRIPTION
          "The number of packets transmitted by the specified
           host on the specified interface."
    } = 4

    -- Octet counters removed to make example shorter
}

-- variable declaration for a InetHostStats data collection

VAR ARRAY ipStats {
    SYNTAX      InetHostStats
    STATUS      current
    DESCRIPTION
       "The IP host statistics for this network device."
} ::= { someBase 4 }





Expires December 15, 2002                                      [Page 18]





Internet Draft             SMI Data Structures             June 15, 2002


-- a struct containing additional information for each
-- set of counters

TYPE STRUCT HostStatsTimeData {
    DESCRIPTION
        "Add some times related objects associated with
         each set of counters."

    ATTRIBUTE SCALAR createTime {
       SYNTAX      TimeStamp
       MAX-ACCESS  read-only
       DESCRIPTION
          "The value of sysUpTime at the time this set of
           counters was created."
    } = 1

    ATTRIBUTE SCALAR updateInterval {
       SYNTAX      Unsigned32
       UNITS       "milliseconds"
       MAX-ACCESS  read-create
       DESCRIPTION
          "The average amount of time that elapses between
           internal polling intervals for this counter set.
           A value of zero indicates that the counter set
           values are not polled internally."
    } = 2
}

-- Augment the ipStats variable with the ipXStats variable:
--    - 2 HC packet counters
--    - a HostStatsTimeData STRUCT
--    - an ARRAY of InetPortNumber packet counters

TYPE ARRAY IpXStats {
    DESCRIPTION
        "Adds HC counters and additional information to
         the ipStats statistics."

    AUGMENTS { ipStats }

    ATTRIBUTE SCALAR inHCPkts {
        SYNTAX      Counter64
        MAX-ACCESS  read-only
        STATUS      current
        DESCRIPTION





Expires December 15, 2002                                      [Page 19]





Internet Draft             SMI Data Structures             June 15, 2002


            "The number of packets received by the specified
             host on the specified interface."
    } = 1

    ATTRIBUTE SCALAR outHCPkts {
        SYNTAX      Counter64
        MAX-ACCESS  read-only
        DESCRIPTION
            "The number of packets transmitted by the specified
             host on the specified interface."
    } = 2

    -- Octet counters removed to make example shorter

    ATTRIBUTE STRUCT timeData {
        SYNTAX      HostStatsTimeData
        MAX-ACCESS  read-only
        DESCRIPTION
            "Additional time-related information."
    } = 3

    ATTRIBUTE ARRAY portStats {
        DESCRIPTION
            "Extend the ARRAY with InetPort statistics."

        INDEX { inetPort }

        ATTRIBUTE SCALAR inetPort {
            SYNTAX      InetPortNumber
            MAX-ACCESS  not-accessible
            STATUS      current
            DESCRIPTION
                "The Internet port number for the array entry."
        } = 1

        ATTRIBUTE UNION uInPkts {
            SYNTAX      GenericCounter
            MAX-ACCESS  read-only
            STATUS      current
            DESCRIPTION
                "The number of packets received by the specified
                 host on the specified port."
        } = 2

        ATTRIBUTE UNION uOutPkts {





Expires December 15, 2002                                      [Page 20]





Internet Draft             SMI Data Structures             June 15, 2002


            SYNTAX      GenericCounter
            MAX-ACCESS  read-only
            STATUS      current
            DESCRIPTION
                "The number of packets transmitted by the specified
                 host on the specified port."
        } = 3

        -- Octet counters removed to make example shorter
    } = 4
}

VAR ARRAY ipXStats {
    SYNTAX      IpXStats
    DESCRIPTION
       "An example of an augmented array."
 ::= { someBase 5 }

Note 1) The following example lists the potential OID values for each of
the fields in the 'ipStats' and 'ipXStats' variables in the example
above.

In this example only the instances for interface 17, InetAddressType
'ipv4(1)', InetAddress '192.168.0.1', and InetPortNumber '80' are shown.

   ipStats                     ::=   { someBase 4 }
   ipStats[17]                 ::=   Not Available
   ipStats[17][1]              ::=   Not Available
   ipStats[17][1][192.168.0.1] ::=   Not Available

   ipStats[17][1][192.168.0.1].inPkts ::=
       { ipStats 1 3 17 1 4 192 168 0 1 }

   ipStats[17][1][192.168.0.1].outPkts ::=
       { ipStats 1 4 17 1 4 192 168 0 1 }

   ipXStats                    ::=   { someBase 5 }
   ipXStats[17][1][192.168.0.1].inHCPkts ::=
       { ipXStats 1 1 17 1 4 192 168 0 1 }

   ipXStats[17][1][192.168.0.1].outHCPkts ::=
       { ipXStats 1 2 17 1 4 192 168 0 1 }

   ipXStats[17][1][192.168.0.1].timeData ::=
       { ipXStats 1 3 17 1 4 192 168 0 1 }    (not-accessible)





Expires December 15, 2002                                      [Page 21]





Internet Draft             SMI Data Structures             June 15, 2002


   ipXStats[17][1][192.168.0.1].timeData.createTime ::=
       { ipXStats 1 3 1 17 1 4 192 168 0 1 }

   ipXStats[17][1][192.168.0.1].timeData.updateInterval ::=
       { ipXStats 1 3 2 17 1 4 192 168 0 1 }

   ipXStats[17][1][192.168.0.1].portStats ::=
       { ipXStats 1 4 17 1 4 192 168 0 1 }    (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80] ::= Not Available

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts ::=
       { ipXStats 1 4 2 17 1 4 192 168 0 1 80 }   (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c32 ::=
       { ipXStats 1 4 2 1 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c64 ::=
       { ipXStats 1 4 2 2 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c32pair ::=
       { ipXStats 1 4 2 3 17 1 4 192 168 0 1 80 } (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c32pair.c32low ::=
       { ipXStats 1 4 2 3 1 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uInPkts.c32pair.c32hi ::=
       { ipXStats 1 4 2 3 2 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts ::=
       { ipXStats 1 4 3 17 1 4 192 168 0 1 80 }   (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c32 ::=
       { ipXStats 1 4 3 1 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c64 ::=
       { ipXStats 1 4 3 2 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c32pair ::=
       { ipXStats 1 4 3 3 17 1 4 192 168 0 1 80 } (not-accessible)

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c32pair.c32low ::=
       { ipXStats 1 4 3 3 1 17 1 4 192 168 0 1 80 }

   ipXStats[17][1][192.168.0.1].portStats[80].uOutPkts.c32pair.c32hi ::=





Expires December 15, 2002                                      [Page 22]





Internet Draft             SMI Data Structures             June 15, 2002


       { ipXStats 1 4 3 3 2 17 1 4 192 168 0 1 80 }

Note 2) Although arbitrary levels of nested containment are
theoretically possible, SNMP varbind size limitations and common sense
design practices set practical limits on the complexity of data object
definitions.

Note 3) The SPPI provides an EXTENDS mechanism, which allows new SCALAR
objects to be defined in a table which conceptually adds INDEX
components to an existing table. This mechanism is accomplished by
defining an additional ARRAY (with the new INDEX components and objects)
in an AUGMENTS clause, like the 'portStats' example above.

SPARSE-AUGMENTS Example
-----------------------

The following example shows how information about physical sensors may
sparsely augment the entPhysicalTable [RFC2737].

TYPE ARRAY EntSensorData {
    DESCRIPTION
        "Adds the ability to read physical sensor values
         to the Entity MIB. An entSensorData object exists
         for each entPhysicalEntry for which the entPhysicalClass
         object value is 'sensor(8)'."
    REFERENCE
        "RFC 2737, section 3."

    SPARSE-AUGMENTS { entPhysicalEntry }

    ATTRIBUTE SCALAR entSensorType {
        SYNTAX        EntitySensorDataType
        MAX-ACCESS    read-only
        DESCRIPTION
            "The type of data returned by the associated
             entSensorValue object. ..."
    } = 1

    ATTRIBUTE SCALAR entSensorScale {
        SYNTAX        EntitySensorDataScale
        MAX-ACCESS    read-only
        DESCRIPTION
            "The exponent to apply to values returned by the
              associated entSensorValue object. ..."
    } = 2





Expires December 15, 2002                                      [Page 23]





Internet Draft             SMI Data Structures             June 15, 2002


    -- rest of entSensorEntry objects would follow ...

}

VAR ARRAY entSensorData {
    SYNTAX      EntSensorData
    DESCRIPTION
       "An example of a sparse augmentation."
} ::= { someBase 6 }

Note 1) SMI-DS objects can augment SMIv2 tables, since the SMIv2 <-->
SMI-DS conversion algorithms are transparent.  The augmented variable
object descriptor may be any value that would be accepted in an SMIv2
AUGMENTS clause.

Note 2) The following OIDs would be possible for the 'entSensorEntry'
augmentation. The instances for entPhysicalIndex == 17 are shown in this
example:

   entSensorData                    ::= { someBase 6 }
   entSensorData[17]                ::= Not Available
   entSensorData[17].entSensorType  ::= { entSensorData 1 1 17 }
   entSensorData[17].entSensorScale ::= { entSensorData 1 2 17 }


5.8.  SYNTAX POINTER Clause

The 'VariablePointer' and 'RowPointer' TEXTUAL-CONVENTIONs [RFC2579]
provide semantic constraints on the generic OBJECT IDENTIFIER, but they
can only be used to point to a variable or row of any type, not a
specific type.

SMI-DS provides a modified SYNTAX clause for object declarations, in
order to specify an OID that must reference a MIB object (SCALAR or
aggregated data object) of a particular type.  The value { 0 0 } is also
allowed and is reserved to indicate a NULL pointer.

The form "SYNTAX Pointer <type-name>" specifies an OID which should
contain only those values that de-reference to the same type as defined
by <type-name>, or contain the NULL pointer value { 0 0 }.

For example, if the RMON DataSource TC [RFC2021] was written in SMI-DS,
the Pointer construct might be used as follows:

TYPE SCALAR DataSource {





Expires December 15, 2002                                      [Page 24]





Internet Draft             SMI Data Structures             June 15, 2002


    SYNTAX Pointer InterfaceIndex
    MAX-ACCESS     read-create
    DESCRIPTION
        "Identifies the source of the data that the associated
         function is configured to analyze. This source can be any
         interface on this device. ...
         For example, if an entry were to receive data from
         interface #1, this object would be set to ifIndex.1."
}

Refer to section 6.2 for details on the 'SYNTAX Pointer' clause.







































Expires December 15, 2002                                      [Page 25]





Internet Draft             SMI Data Structures             June 15, 2002


6.  Definitions

The follow sections specify the SMI Data Structures syntax and
semantics.

6.1.  Syntax

-- top level construction

<module> ::=

    "MODULE" <module-name> "DEFINITIONS" "::=" "BEGIN"
        <imports-decl>
        <module-identity-decl>
        [<module-decl ...]
        [<compliance-section>]
    "END"

<module-name>  ::=  (same as SMIv2)

<imports-decl> ::=  (same as SMIv2)

<module-identity-decl> ::=  (same as SMIv2)

<module-decl> ::=

     ( <object-identifier> | <object-identity> |
       <type-decl> | <var-decl> | notification-decl> )

<object-identifier> ::= (SMIv2 OBJECT IDENTIFIER clause)

<object-identity> ::= (SMIv2 OBJECT-IDENTITY clause)

<type-decl> ::=

    "TYPE" ( <leaf-typedef> | <array-typedef> |
                <union-typedef> | <struct-typedef> )

<var-decl> ::=

    "VAR" ( <leaf-var-decl> | <array-var-decl> |
            <union-var-decl>  | <struct-var-decl> )

<leaf-typedef> ::=






Expires December 15, 2002                                      [Page 26]





Internet Draft             SMI Data Structures             June 15, 2002


    "SCALAR" <type-name> <leaf-core-decl>

<type-name> ::=

    (same rules as for SMIv2 TEXTUAL-CONVENTION descriptors)

<leaf-core-decl> ::=

    "{"
        [<display-part>]
        <syntax-clause>
        [<units-clause>]
        <max-access-clause>
        [<status-clause>]
        <description-clause>
        [<reference-clause>]
        [<defval-clause>]
    "}"

<display-part> ::=   (same as SMIv2 DIPLAY-HINT)

<syntax-clause> ::=

   ( <plain-syntax-clause> | <pointer-syntax-clause> )

<plain-syntax-clause> ::=

   (same as SMIv2, plus 64-bit numbers and float data types)

<pointer-syntax-clause> ::=

   "SYNTAX" "POINTER" <type-name>

<units-clause> ::= (same as SMIv2)

<max-access-clause> ::= (same as SMIv2)

<status-clause> ::= (same as SMIv2)

<description-clause> ::= (same as SMIv2)

<reference-clause> ::= (same as SMIv2)

<defval-clause> ::= (same as SMIv2)






Expires December 15, 2002                                      [Page 27]





Internet Draft             SMI Data Structures             June 15, 2002


<leaf-type-decl> ::=

    "SCALAR" <object-descriptor> <leaf-core-decl>
        "=" <N>

<object-descriptor> ::=

    (same rules as for SMIv2 OBJECT-TYPE descriptors)

<N> ::= an INTEGER in the range (1..4294967295)

<leaf-var-decl> ::=

    "SCALAR" <object-descriptor> <leaf-core-decl>
        "=" <oid-assignment>

<oid-assignment> ::=  (same as SMIv2)

<array-typedef> ::=

    "ARRAY" <type-name> "{"
       <description-clause>
       [<reference-clause>]
       <index-decl>
       <object-decl> [<object-decl> ...]
    "}"

<index-clause> ::=

     ( <index-decl> | <augments-decl> |
       <sparse-augments-decl> )

<index-decl> ::=

-- this syntax needs to change to support the optional
-- IMPLIED keyword before the last object-descriptor

    "INDEX" "{" <object-descriptor>
                [ "," <object-descriptor> ...] "}"

<augments-decl> ::=

    "AUGMENTS" "{" <object-descriptor> "}"

<sparse-augments-decl> ::=





Expires December 15, 2002                                      [Page 28]





Internet Draft             SMI Data Structures             June 15, 2002


    "SPARSE-AUGMENTS" "{" <object-descriptor> "}"

<object-decl> ::=

    "ATTRIBUTE" ( <leaf-type-decl>  |
                  <array-type-decl> |
                  <union-type-decl> |
                  <struct-type-decl> )

<array-type-decl> ::=

    ( <array-inline-type-decl> | <array-ref-type-decl> )

<array-inline-type-decl> ::=

    <array-inline-core-decl> <N>

<array-inline-core-decl> ::=

    "ARRAY" <object-descriptor> "{"
       <description-clause>
       [<reference-clause>]
       <index-decl>
       <object-decl> [<object-decl> ...]
    "}" "="

<array-ref-type-decl> ::=

    <array-ref-core-decl> <N>

<array-ref-core-decl> ::=

    "ARRAY" <object-descriptor> "{"
       <syntax-clause>
       [<max-access-clause>]
       <status-clause>
       <description-clause>
       [<reference-clause>]
    "}" "="

<array-var-decl> ::=

    <array-ref-core-decl> <oid-assignment>

<union-typedef> ::=





Expires December 15, 2002                                      [Page 29]





Internet Draft             SMI Data Structures             June 15, 2002


    "UNION" <type-name> "{"
        <description-clause>
        [<reference-clause>]
        <object-decl> [<object-decl> ...]
    "}"

<union-type-decl> ::=

    ( <union-inline-type-decl> | <union-ref-type-decl> )

<union-inline-type-decl> ::=

    <union-inline-core-decl> <N>

<union-inline-core-decl> ::=

    "UNION" <object-descriptor> "{"
        <description-clause>
        [<reference-clause>]
        <object-decl> [<object-decl> ...]
    "}" "="

<union-ref-type-decl> ::=

    <union-ref-core-decl> <N>

<union-ref-core-decl> ::=

    "UNION" <object-descriptor> "{"
        <syntax-clause>
        [<max-access-clause>]
        <status-clause>
        <description-clause>
        [<reference-clause>]
    "}" "="

<union-var-decl> ::=

    <union-ref-core-decl> <oid-assignment>

<struct-typedef> ::=

    "STRUCT" <type-name> "{"
        <description-clause>
        [<reference-clause>]





Expires December 15, 2002                                      [Page 30]





Internet Draft             SMI Data Structures             June 15, 2002


        <object-decl>  [<object-decl> ...]
    "}"

<struct-type-decl> ::=

    ( <struct-inline-type-decl> | <struct-ref-type-decl> )

<struct-inline-type-decl> ::=

    <struct-inline-core-decl> <N>

<struct-inline-core-decl> ::=

    "STRUCT" <object-descriptor> "{"
        <description-clause>
        [<reference-clause>]
        <object-decl>  [<object-decl> ...]
    "}" "="

<struct-ref-type-decl> ::=

    <struct-ref-core-decl> <N>

<struct-ref-core-decl> ::=

    "STRUCT" <object-descriptor> "{"
        <syntax-clause>
        [<max-access-clause>]
        <status-clause>
        <description-clause>
        [<reference-clause>]
    "}" "="

<struct-var-decl> ::=

    <struct-ref-core-decl> <oid-assignment>

<notification-decl> ::=

    "NOTIFICATION" <object-descriptor> "{"
        [<objects-part>]
        <status-clause>
        <description-clause>
        [<reference-clause>]
    "}" "=" <oid-assignment>





Expires December 15, 2002                                      [Page 31]





Internet Draft             SMI Data Structures             June 15, 2002


<objects-part> ::=

    "OBJECTS" "{" <object-descriptor>
                  [ "," <object-descriptor> ...] "}"

<compliance-section> ::=

    (same as SMIv2, except VAR node descriptors need to
     be fully qualified)

-- END


7.  Acknowledgements

This memo is a product of the SMIng Working Group.

Portions of the existing SMI RFCs, SMIng drafts, and the ANSI C
Programming Language inspired many of the concepts discussed in this
memo.






























Expires December 15, 2002                                      [Page 32]





Internet Draft             SMI Data Structures             June 15, 2002


8.  Normative References

[RFC1905]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Protocol Operations for Version 2 of the Simple
     Network Management Protocol (SNMPv2)", RFC 1905, SNMP Research,
     Inc., Cisco Systems, Inc., Dover Beach Consulting, Inc.,
     International Network Services, January 1996.

[RFC1906]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Transport Mappings for Version 2 of the Simple Network
     Management Protocol (SNMPv2)", RFC 1906, SNMP Research, Inc., Cisco
     Systems, Inc., Dover Beach Consulting, Inc., International Network
     Services, January 1996.

[RFC2026]
     Bradner, S., "The Internet Standards Process -- Revision 3", RFC
     2026, Harvard University, October, 1996.

[RFC2119]
     S. Bradner, "Key words for use in RFCs to Indicate Requirement
     Levels" RFC 2119, Harvard University, March 1997.

[RFC2571]
     Harrington, D., Presuhn, R., and B. Wijnen, "An Architecture for
     Describing SNMP Management Frameworks", RFC 2571, Cabletron
     Systems, Inc., BMC Software, Inc., IBM T. J. Watson Research, April
     1999.

[RFC2572]
     Case, J., Harrington D., Presuhn R., and B. Wijnen, "Message
     Processing and Dispatching for the Simple Network Management
     Protocol (SNMP)", RFC 2572, SNMP Research, Inc., Cabletron Systems,
     Inc., BMC Software, Inc., IBM T. J. Watson Research, April 1999.

[RFC2573]
     Levi, D., Meyer, P., and B. Stewart, "SNMPv3 Applications", RFC
     2573, SNMP Research, Inc., Secure Computing Corporation, Cisco
     Systems, April 1999.

[RFC2574]
     Blumenthal, U., and B. Wijnen, "User-based Security Model (USM) for
     version 3 of the Simple Network Management Protocol (SNMPv3)", RFC
     2574, IBM T. J. Watson Research, April 1999.





Expires December 15, 2002                                      [Page 33]





Internet Draft             SMI Data Structures             June 15, 2002


[RFC2575]
     Wijnen, B., Presuhn, R., and K. McCloghrie, "View-based Access
     Control Model (VACM) for the Simple Network Management Protocol
     (SNMP)", RFC 2575, IBM T. J. Watson Research, BMC Software, Inc.,
     Cisco Systems, Inc., April 1999.

[RFC2578]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Structure of Management Information Version 2
     (SMIv2)", RFC 2578, STD 58, Cisco Systems, SNMPinfo, TU
     Braunschweig, SNMP Research, First Virtual Holdings, International
     Network Services, April 1999.

[RFC2579]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Textual Conventions for SMIv2", RFC 2579, STD
     58, Cisco Systems, SNMPinfo, TU Braunschweig, SNMP Research, First
     Virtual Holdings, International Network Services, April 1999.

[RFC2580]
     McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M.,
     and S. Waldbusser, "Conformance Statements for SMIv2", RFC 2580,
     STD 58, Cisco Systems, SNMPinfo, TU Braunschweig, SNMP Research,
     First Virtual Holdings, International Network Services, April 1999.

9.  Informative References

[DSMON-MIB]
     Bierman, A., "Remote Monitoring MIB Extensions for Differentiated
     Services", Work in progress (draft-ietf-rmonmib-dsmon-mib-09.txt),
     Cisco Systems, Inc., November 2001.

[RFC1155]
     Rose, M., and K. McCloghrie, "Structure and Identification of
     Management Information for TCP/IP-based Internets", RFC 1155,
     Performance Systems International, Hughes LAN Systems, May 1990.

[RFC1157]
     Case, J., Fedor, M., Schoffstall, M., and J. Davin, "Simple Network
     Management Protocol", RFC 1157, SNMP Research, Performance Systems
     International, Performance Systems International, MIT Laboratory
     for Computer Science, May 1990.

[RFC1212]
     Rose, M., and K. McCloghrie, "Concise MIB Definitions", RFC 1212,





Expires December 15, 2002                                      [Page 34]





Internet Draft             SMI Data Structures             June 15, 2002


     Performance Systems International, Hughes LAN Systems, March 1991.

[RFC1215]
     M. Rose, "A Convention for Defining Traps for use with the SNMP",
     RFC 1215, Performance Systems International, March 1991.

[RFC1901]
     SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and S.
     Waldbusser, "Introduction to Community-based SNMPv2", RFC 1901,
     SNMP Research, Inc., Cisco Systems, Inc., Dover Beach Consulting,
     Inc., International Network Services, January 1996.

[RFC2021]
     S. Waldbusser, "Remote Network Monitoring Management Information
     Base Version 2 using SMIv2", RFC 2021, INS, January 1997.

[RFC2570]
     Case, J., Mundy, R., Partain, D., and B. Stewart, "Introduction to
     Version 3 of the Internet-standard Network Management Framework",
     RFC 2570, SNMP Research, Inc., TIS Labs at Network Associates,
     Inc., Ericsson, Cisco Systems, April 1999.

[RFC2737]
     McCloghrie, K., and A. Bierman, "Entity MIB (Version 2)", RFC 2737,
     Cisco Systems, Inc., December 1999.

[RFC2851]
     Daniele, M., Haberman, B., Routhier, S., and J. Schoenwaelder,
     "Textual Conventions for Internet Network Addresses", RFC 2851,
     Compaq Computer Corporation, Nortel Networks, Wind River Systems,
     Inc., TU Braunschweig, June 2000.

[RFC2863]
     McCloghrie, K., and F. Kastenholz, "The Interfaces Group MIB", RFC
     2863, Cisco Systems, Argon Networks, June, 2000.

[RFC3216]
     Elliot, C., Harrington, D., Jason, J., Schoenwaelder, J., Strauss,
     F., and W. Weiss, "SMIng Objectives", RFC 3216, Cisco Systems,
     Enterasys Networks, Intel Corporation, TU Braunschweig, Ellacoya
     Networks, December 2001.









Expires December 15, 2002                                      [Page 35]





Internet Draft             SMI Data Structures             June 15, 2002


10.  Author's Address

     Andy Bierman
     Cisco Systems, Inc.
     170 West Tasman Drive
     San Jose, CA USA 95134
     Phone: +1 408-527-3711
     Email: abierman@cisco.com










































Expires December 15, 2002                                      [Page 36]





Internet Draft             SMI Data Structures             June 15, 2002


11.  Full Copyright Statement

Copyright (C) The Internet Society (2002).  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are included
on all such copies and derivative works.  However, this document itself
may not be modified in any way, such as by removing the copyright notice
or references to the Internet Society or other Internet organizations,
except as needed for the purpose of developing Internet standards in
which case the procedures for copyrights defined in the Internet
Standards process must be followed, or as required to translate it into
languages other than English.

The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assigns.

This document and the information contained herein is provided on an "AS
IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK
FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT
LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT
INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR
FITNESS FOR A PARTICULAR PURPOSE.
























Expires December 15, 2002                                      [Page 37]





Internet Draft             SMI Data Structures             June 15, 2002


Table of Contents


1 Copyright Notice ................................................    1
2 Abstract ........................................................    2
3 Table of Contents ...............................................    2
4 The SNMP Network Management Framework ...........................    3
5 Overview ........................................................    4
5.1 Terms .........................................................    4
5.2 Design Objectives .............................................    5
5.3 Data Structure Constructs .....................................    6
5.4 Relationship to SMIv2 .........................................    7
5.5 Hierarchical Instance Naming ..................................    8
5.6 SMI-DS Data Object Usage Examples .............................   10
5.6.1 InetAddress Example .........................................   10
5.6.2 Generic High Capacity Counter Example .......................   13
5.6.3 Converted SMIv2 TABLE Example ...............................   15
5.7 Data Structure Augmentations ..................................   17
5.8 SYNTAX POINTER Clause .........................................   24
6 Definitions .....................................................   26
6.1 Syntax ........................................................   26
7 Acknowledgements ................................................   32
8 Normative References ............................................   33
9 Informative References ..........................................   34
10 Author's Address ...............................................   36
11 Full Copyright Statement .......................................   37
























Expires December 15, 2002                                      [Page 38]

