<!doctype html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>NCX Overview (draft 0.2)</title>
    <link rel="stylesheet" href="/css/ncx.css" type="text/css"/>
  </head>
<body>

<p>
<a href="index.html">NCX Home</a>
</p>

<h1 align="center">NCX Overview</h1>

<p>Contents:</p>

<ul>
<li><a href="#Overview">Overview</a>
  <ul>
  <li><a href="#Terms">Terms</a></li>
  <li><a href="#Problem_Statement">Problem Statement</a></li>
  <li><a href="#Solution_Proposal">Solution Proposal</a></li>
  <li><a href="#Design_Goals">Design Goals</a></li>
  <li><a href="#Design_NonGoals">Design Non-Goals</a></li>
  <li><a href="#Related_Work">Related Work</a></li>
  <li><a href="#NCX_Framework">NCX Framework</a></li>
  </ul>
</li>
<li><a href="#Data_Organization">Data Organization</a>
  <ul>
  <li><a href="#Owners">Owners</a></li>
  <li><a href="#Namespaces">Namespaces</a></li>
  <li><a href="#Configuration_Root">Configuration Root</a></li>
  <li><a href="#Applications">Applications</a>
    <ul>
    <li><a href="#Applications_Header_Nodes">Application Header Nodes</a></li>
    </ul>
  </li>
  <li><a href="#Application_Definitions">Application Specific Definitions</a>
    <ul>
    <li><a href="#RPC_Methods">RPC Methods</a></li>
    <li><a href="#Parameter_Sets">Parameter Sets</a></li>
    <li><a href="#Notifications">Notifications</a></li>
    </ul>
  </li> 
  <li><a href="#Config_Root">Configuration Root</a></li>
  <li><a href="#NV_Storage">Non-Volatile Configuration Storage</a></li>
  </ul>
</li>
<li><a href="#NCX_Naming">NCX Naming</a>
  <ul>
  <li><a href="#Names">Names</a></li>
  <li><a href="#Identifiers">Identifiers</a>
    <ul>
    <li><a href="#Definition_Identifiers">Definition Identifiers</a></li>
    <li><a href="#Instance_Identifiers">Instance Identifiers</a></li>
    </ul>
  </li>
  </ul>
</li>
</ul>

<h1><a name="Overview">Overview</a></h1>

<p>
The NCX Data Modeling language
is intended to greatly simplify the definition of 
programmatic interfaces for use with XML-based network management
protocols.
</p>

<p>
The following reference material is cited throughout 
this documentation.  It is suggested that the reader
be somewhat familiar with these concepts before 
advanced usage of the NCX language.
</p>

<table summary="Reference Material" border="1" align="center" width="100%">
<tr>  
<th>Source</th>
<th>Description</th>
</tr>

<tr>  
<td><a href="http://www.ietf.org">IETF</a></td>
<td>Internet Engineering Task Force</td>
</tr>

<tr>  
<td><a href="http://www.ietf.org/rfc/rfc4741.txt">NETCONF</a></td>
<td>Network Configuration Protocol</td>
</tr>

<tr>  
<td><a href="http://www.ietf.org/rfc/rfc2578.txt">SMIv2</a></td>
<td>Structure of Management Information, Version 2</td>
</tr>

<tr>  
<td><a href="http://www.ops.ietf.org/mib-doctors.html">MIB</a></td>
<td>Management Information Base</td>
</tr>

<tr>  
<td><a href="http://www.w3c.org/XML/">XML</a></td>
<td>Extensible Markup Language</td>
</tr>

<tr>  
<td><a href="http://www.w3.org/XML/Schema">XSD</a></td>
<td>XML Schema Definition</td>
</tr>

<tr>  
<td><a href="http://www.w3.org/TR/xpath">XPath</a></td>
<td>XML Path Specification</td>
</tr>

</table>

<h2><a name="Terms">Terms</a></h2>

<p>
The following terms are used throughout this documentation:
</p>

<table summary="Terms" border="1" align="center" width="100%">
<tr>  
<th>Term</th>
<th>Definition</th>
</tr>

<tr>  
<td><b>data model</b></td>
<td>
Formal representation of the application-specific components
of a conceptual network management programmatic interface
</td>
</tr>

<tr>  
<td><b>data model module</b></td>
<td>
Container of definitions pertaining to a specific data model
</td>
</tr>

<tr>  
<td><b>data model object</b></td>
<td>
A definition within a data model module that
represents a conceptual construct which can be accessed via a network
management protocol. Also called an <b>object</b>.
</td>
</tr>

<tr>  
<td><b>data type</b></td>
<td>
An abstract collection of properties, constructs, and syntax,
which can be assigned (by name) to a data model object
</td>
</tr>

<tr>  
<td><b>simple type</b></td>
<td>
A data type which defines simple conceptual content.
Unlike XSD, an NCX simple type may define metadata
(XML attributes). All NCX simple types except one
are encoded in XML as simple XML content.
</td>
</tr>

<tr>  
<td><b>complex type</b></td>
<td>
A data type which defines complex conceptual content.
In NCX, any data type which may define child nodes
of arbitrary content are considered to be complex types.
All NCX complex types are also XSD complex types.
</td>
</tr>

<tr>
<td><b>base type</b></td>
<td>
One of the <a href="datatypes.html#Base_Types">NCX data types</a> 
defined in the NCX language.  This is not the same as an 
XSD 'base' type. All derived types have a base type, which 
must be the same in order to compare two values of an arbitrary type.
</td>
</tr>

<tr>
<td><b>derived type</b></td>
<td>Any user-defined data type.</td>
</tr>

<tr>
<td><b>parent type</b></td>
<td>
The data type that a derived type is based upon.  This is the same
as the XSD 'base' type.  This can identify a Base Type or Derived Type.
</td>
</tr>

<tr>
<td><b>type chain</b></td>
<td>
The sequence of data type constructs which fully define a derived type.
When a type chain is searched for properties, it is done from newest 
to oldest. Conceptually, a search is started from the current type 
definition, and terminated when the appropriate property is found, 
or the NCX base type is reached.
</td>
</tr>

<tr>  
<td><b>owner</b></td>
<td>
The naming authority for a data model definition.
All owner names must be globally unique.
All definition names exist within the scope
of a single owner.
</td>
</tr>

<tr>  
<td><b>application</b></td>
<td>
A set of functionally-related, owner-specific, conceptual
data modeling interfaces.  All data model objects exist
within the scope and context of a single application.
</td>
</tr>

<tr>  
<td><b>parameter set</b></td>
<td>
A set of one or more functionally related parameters, which as
used within the NETCONF protocol in some manner.
</td>
</tr>

<tr>  
<td><b>RPC</b></td>
<td>
A Remote Procedure Call, as used within the NETCONF protocol.
</td>
</tr>

<tr>  
<td><b>RPC method</b></td>
<td>
A specific Remote Procedure Call, as used within the NETCONF protocol.
Also called a <b>protocol operation</b>
</td>
</tr>

<tr>  
<td><b>NETCONF Data Model</b></td>
<td>
The high-level organization and framework which encompasses
all protocol operations, conceptual data definitions,
and data model object instances.
</td>
</tr>

<tr>  
<td><b>MIB</b></td>
<td>Management Information Base</td>
</tr>

<tr>  
<td><b>NETCONF MIB</b></td>
<td>
The set of all possible data model objects that
all possible NETCONF agents could ever return in
a &lt;rpc-reply&gt; for a &lt;get&gt; operation.
</td>
</tr>

</table>

<h2><a name="Problem_Statement">Problem Statement</a></h2>

<p>
<b>Stuck with CLI</b>
</p>

<p>
Network operators and network equipment (NE) software developers
need a lot of expertise, and spend a lot of time, to configure,
control, and monitor network devices.
</p>

<p>
Network configuration has traditionally been very <b>proprietary</b>
in nature, and based on <b>screen-scraping</b>
Command Line Interface (CLI) commands
that can be stored in a textual file.  Configuration management
is usually done manually, and is prone to human-introduced error.
Often, scripts or applications which use the CLI as a programmatic interface
are developed ad-hoc to automate and simplify some repetitive management tasks.
</p>

<p>
Programmatic interfaces
built on top of the CLI are insufficient for the following reasons:
</p>
<ul>
<li>
CLI is proprietary, requiring extra effort by operators
to learn and manage different CLIs for different equipment.
</li>
<li>
CLI lacks a formal description language to completely
define all properties of the programmatic interface
</li>
<li>
CLI lacks any structured error responses, and very little
information about specific errors is available to applications
</li>
<li>
CLI lacks any sort of formalized transaction mechanism,
to safely lock, alter, and unlock configuration databases in
a multi-application environment.
</li>
</ul>


<p>
<b>Enter XML</b>
</p>

<p>
The 
<a href="http://www.ietf.org/html.charters/netconf-charter.html">
Network Configuration WG</a> has created a standard protocol
for Network Configuration, called
<a href="http://www.ietf.org/rfc/rfc4741.txt">NETCONF</a>,
which provides a standard XML-based programmatic interface for
network devices.  NETCONF is designed to allow easy integration with,
and migration from, CLI based programmatic interfaces.
</p>

<p>
NETCONF (by design) separates the application-specific
content within a network management operation from the operation itself.
There is currently no standard content defined for NETCONF.
Since it uses XML encoding, any data modeling language
that describe XML instance documents can be used to define
management definitions for use with the NETCONF protocol.
</p>

<p>
<b>Stuck With XSD</b>
</p>

<p>
Typically,
<b>XML Schema Definition</b> (XSD) is used to describe
valid schemas for XML instance documents for a particular XML application.
However, XSD is rather difficult for humans to work with efficiently.
It is verbose and complex, difficult to read and write, but is
still an excellent formal description mechanism for applications
to use.
</p>
<p>
Because XSD is so difficult for humans to understand and
define without errors, moving from CLI to XML based 
configuration management is not that easy.  An application
cannot really use an XSD schema to manage a network device
until the data model definitions accurately reflect the
native programmatic interface available from the NETCONF agent.
</p>
<p>
This 'human usability' problem is especially important
in the area of network management because increased
complexity increases the risk that something will break
in an unexpected way. Network operators and protocol
develops need to fully understand that the XML data model
correctly reflects the normative specification found in text.
This has proven difficult when using XSD to define the XML syntax.
</p>

<p>
Just as important as the human usability problems is the fact
that XSD is designed and intended for use as a generalized
formal definition of the content of XML instance documents.
</p>
<p>
<b>XSD does not address network management problems</b> that
have long been recognized and partially solved:
</p>

<ul>
<li>extensible modularity</li>
<li>definition and module lifecycle</li>
<li>user documentation</li>
<li>implementation conformance</li>
<li>maximum protocol access</li>
<li>integration with existing SNMP-based data structures</li>
<li>agent implementation conformance</li>
<li>conditional presence tests based on referential integrity
or protocol functionality</li>
<li>user-defined RPC Methods</li>
<li>user-defined Notifications</li>
<li>
user-defined data models compatible with standard NETCONF
protocol operations
</li>
<li>protocol operation dependent schema</li>
<li>conditional definitions based on platform capabilities</li>
</ul>


<p>
Although it is possible to
arbitrarily extend the &lt;appinfo&gt; element,
this XSD mechanism is by definition non-standard,
and 'off-the-shelf' XSD-based applications will not
be able to do anything useful with information encoded
in this manner.
</p>

<p>
In addition to the many aspects of standards-based data
model definition and maintenance that are not directly
addressed by XSD. The NETCONF protocol uses data model
schema differently, depending on the protocol operation
mode.
</p>

<p>
There are four different usage-based representations, 
which would each require its own XSD schema, that are
conceptually and simultaneously supported by a NETCONF Data Model:
</p>

<ol>
<li>
<b>full</b><br/>Conceptualization of all
data model objects and all possible instances. 
This is the <b>canonical representation</b>
that is defined as the combined contents of all data
model modules used within all managed systems. The data
properties represent the syntax, semantics, and requirements
of a data model, independent of all protocol operations.
</li>
<li>
<b>concise</b><br/>Conceptualization of all
data model object instances within a managed system.
Only the data model object values which have actually been 
configured to non-default values by a management application are 
within this representation. This is also called
the <b>no-defaults representation</b>.
</li>
<li>
<b>filter</b><br/>Conceptualization of all permutations
of all valid subtree filter expressions which are possible
for a particular data model object.  An XSD would
need to treat every element and every attribute as optional
in order to support this representation.  In addition,
unknown namespaces, elements and attributes are not
errors, but rather valid filter components which simply 
produce no matching output from the underlying data model
instances within the agent. This is also called the
<b>subtree filter representation</b>.
</li>
<li>
<b>edit</b><br/>Conceptualization of all permutations
of all valid data model instances which are possible
for a particular data model object, which permit
the NETCONF edit-mode 'operation' attribute (for 
the edit-config protocol operation) to be present.
An XSD would need to include this XML attribute
in every XML element within the conceptual 
configuration data model to represent this mode. 
This is also called the <b>edit-config representation</b>.
</li>
</ol>


<p>
<b>What's Next?</b>
</p>

<p>
There is a need for a human-friendly netconf management framework
and data model definition language, which has human-friendly
mechanisms for defining data models for use with the NETCONF protocol,
in a structured manner.
</p>

<p>
In addition, a data modeling framework which
addresses many of the underlying network management issues
is needed which is supported by the data modeling language.
</p>

<p>
This language and data modeling framework must provide many of
the features found in SNMP-based MIBs, while allowing full access
to new, more powerful data modeling mechanisms, available with XML.
</p>

<p>
In order to support XML-based applications efficiently, a tool to convert 
this language into XSD format must be available.
</p>

<h2><a name="Solution_Proposal">Solution Proposal</a></h2>

<p>
The Network Configuration Extensions (NCX) data modeling language 
and NCX Framework are designed
to address the requirements of distributed network management 
applications which implement the NETCONF protocol.
</p>

<h2><a name="Design_Goals">Design Goals</a></h2>

<p>
The design goals for the NCX language can be summarized as follows:
</p>

<ul>
<li>
Make each construct as simple as possible for humans to use and understand
</li>
<li>Encourage definition modularity and reuse</li>
<li>
Provide control of as many data type and data object properties as possible
</li>
<li>Provide mechanisms for data model module lifecycle management</li>
<li>Provide vendor-extensible mechanisms to assist tools automation</li>
<li>Reuse as many good ideas as possible
  from other languages such as C, XSD, SMIv2, and RelaxNG
</li>
<li>Hide NETCONF details from the data model designer</li>
<li>Allow sufficient data model design flexibility</li>
<li>Provide a simple access control framework that fully supports NETCONF</li>
<li>
Allow maximum integration and reuse of SMIv2-based management definitions
</li>
</ul>

<h2><a name="Design_NonGoals">Design Non-Goals</a></h2>

<p>
The NCX language is not intended to be:
</p>

<ul>
<li>a generalized XML Instance Document definition language like XSD</li>
<li>a mechanism to hide or negate bad data model design</li>
<li>a mechanism to insulate novice software developers from
conceptual data structure complexity</li>
<li>a mechanism which supports mixed-mode XML usage</li>
</ul>

<h2><a name="Related_Work">Related Work</a></h2>

<dl>
<dt>NETCONF</dt>
<dd>
The <b>NETCONF protocol</b>
defines standard operations to manage and control
the configuration of networking equipment. 
A layered conceptual model is utilized,
such that any valid XML data model content can be 
used with these protocol operations.  The protocol
can be easily extended with new standard and
vendor-specific operations.
<br/><br/>
However, the definition and implementation of complex data structures 
and management procedures is a traditionally difficult process,
which cannot easily be modeled or 'abstracted away'.  The NETCONF
protocol addresses many of these issues with its
RPC-based configuration database architecture,
but the data modeling aspects are not part of the standard.
</dd>

<dt>XSD</dt>
<dd>
The most popular data
modeling language for XML is <b>XML Schema Definition</b> (XSD)
This data modeling language is great for consumption by software tools,
but verbose and difficult for non-XSD experts to master, and avoid
semantic and syntactic mistakes.
A human-friendly data modeling language is needed which
can be algorithmically translated to XSD for machine consumption.
</dd>

<dt>RelaxNG</dt>
<dd>
The <b>RelaxNG</b> data modeling language 
is a significant improvement over XSD wrt/ user friendliness.
This data modeling language has two syntax forms; one using XML,
and another one developed later called Compact, which 
uses a simplified, programming language like syntax.
<br/><br/>
The progression from XSD to RelaxNG Compact syntax demonstrates
the need for human-friendly data model definitions.  This is especially
true in the area of network management, in which many
different people need to understand and agree on the contents
of technical specifications and standards.
</dd>

<dt>SMIv2</dt>
<dd>
Many years of experience with the SNMP protocol, and its ASN.1-based
Structure of Management Information Version 2 (<b>SMIv2</b>), 
have management interfaces have identified some strengths 
that need to be retained:

<ul>
 <li>
  structured tables with standardized indexing and instance naming</li>
 <li>modular definitions which can be imported and easily reused</li>
 <li>notification definitions</li>
 <li>agent conformance requirements</li>
 <li>standarized vendor extensibility mechanisms</li>
</ul>

<p>
SMIv2 and SNMP-based management also have 
some weaknesses that need to be avoided in NETCONF:
</p>

<ul>
<li>Embedded protocol operations in some data types 
(e.g., RowStatus and StorageType).</li>
<li>No real procedural interface</li>
<li>Error information is too simplistic</li>
<li>OID Naming is complicated and severely limited in length</li>
<li>Data modeling constructs (scalar and table) are not
sufficiently powerful to model complex network management interfaces.
</li>
<li>Too few protocol operations at too low an access granularity</li>
<li>No way to access table row instances or other
data aggregations in one conceptual operation</li>
<li>No way to add vendor-defined protocol operations or extend
standard protocol operations</li>
</ul>
</dd>

<dt>SMIng</dt>
<dd>
The SMIng Working Group (WG) within the IETF attempted
to develop a new SMI around 2002 - 2004. One proposal
was called <a href="http://www.ietf.org/rfc/rfc3780.txt">
SMI - Next Generation (SMIng)</a>.
It used a very readable syntax (NCX is similar in
syntax format to SMIng) and an object-oriented data definition
language.  The SMIng WG did not agree in the end, and
the SMIng proposal was published as an Information RFC anyway.
</dd>

<dt>SMI-DS</dt>
<dd>
Another proposal to the SMIng WG was a data modeling language
that integrated old SMIv2 tables and new nested tables within
the same OID hierarchy, called
<a href="./ref/smi-ds.txt">SMI- Data Structures (SMI-DS)</a>.
</dd>
</dl>

<h2><a name="NCX_Framework">NCX Framework</a></h2>

<p>
The NCX language is designed to simplify
definition, implementation, and deployment of NETCONF-based
distributed network management applications.
</p>

<p>
The NCX Framework includes the following components:
</p>
<ul>
<li>
 <a href="http://www.ietf.org/rfc/rfc4741.txt">NETCONF Protocol</a></li>
<li><a href="modules.html">NCX Data Modeling Language</a></li>
<li><a href="datatypes.html">NCX Data Types</a></li>
<li><a href="../ncx-modules/">Data Model Definition Modules</a></li>
<li><a href="#Data_Organization">Data Organization Framework</a></li>
<li><a href="nacm.html">NETCONF Access Control Model</a></li>
<li><a href="#SMI_Mapping">SMIv2 to NCX Data Model Mapping</a></li>
<li><a href="modules.html#Instance_Identifiers">
Data Instance Representation</a></li>
</ul>

<h1><a name="Data_Organization">Data Organization</a></h1>

<p>
The NCX Data Model adds some simplifying restrictions to
the natural structure of XML.  Not every possible construct
available in XSD is supported in NCX.  Instead, a comprehensive
set of data modeling constructs, compatible with SMIv2, XSD,
and XPath.
</p>

<p>
This section defines the concepts, organization, and naming conventions
used in the NCX Data Model:
</p>
<ul>
<li>Owners</li>
<li>Namespaces</li>
<li>Configuration Root</li>
<li>Applications</li>
<li>Application Specific Definitions</li>
<li>RPC Methods</li>
<li>Parameter Sets</li>
<li>Non-Volatile Configuration Storage</li>
</ul>

<h2><a name="Owners">Owners</a></h2>

<p>
All definitions (except the 
<a href="datatypes.html#Base_Types">NCX base types</a>)
are specified within the scope of an 'owner' name.  This is a globally
unique string value, which follows the <a href="modules.html#Names">NcxName</a>
type definition syntax and semantics.  It is expected that a registration
process such as IANA will be used to register owner name strings.
</p>

<p>
There are two reserved owner string names at this time:
</p>

<table summary="Owner Strings" border="1" align="center" width="100%">
<tr>  
<th>Name</th>
<th>Description</th>
</tr>

<tr>  
<td><b>ietf</b></td>
<td>
Owner of all NETCONF protocol definitions, SMI definitions,
and <a href="http://www.ietf.org">IETF</a> defined data models.
</td>
</tr>

<tr>  
<td><b>ncx</b></td>
<td>
Owner of all NCX protocol extension definitions, NCX and XSD data type 
definitions, and NCX data models.
</td>
</tr>

</table>

<h2><a name="Namespaces">Namespaces</a></h2>

<p>
All definitions 
are specified within a particular XML Namespace.  This is a globally
unique URI string value.  It is expected that a registration
process such as IANA will be used to register namespace URI
values and their meaning.
</p>

<p>
All namespace URI values are defined within the same naming scope,
and each namespace is considered to be owned by one owner.
Each owner can have an arbitrary number of namespaces assigned
to it.
</p>

<p>
There are three reserved namespace URI string values at this time:
</p>

<table summary="Reserved Namespaces" border="1" align="center" width="100%">
<tr>  
<th>Name</th>
<th>Owner</th>
<th>Description</th>
</tr>

<tr>  
<td><b>urn:ietf:params:xml:ns:netconf:base:1.0</b></td>
<td>ietf</td>
<td>
Namespace for the NETCONF Protocol, RFC 4741 version
</td>
</tr>

<tr>  
<td><b>http://www.w3.org/2000/xmlns</b></td>
<td>ncx</td>
<td>
Namespace for the 'xmlns' attribute
</td>
</tr>

<tr>  
<td><b>http://netconfcentral.org/ncx/1.0</b></td>
<td>ncx</td>
<td>
Namespace for the NCX Extensions to the NETCONF Protocol, Version 1.0
</td>
</tr>

<tr>  
<td><b>http://netconfcentral.org/&lt;owner&gt;/&lt;app&gt;</b></td>
<td>ncx</td>
<td>
Namespace for all versions of the NCX Data Model Application &lt;app&gt;,
defined by &lt;owner&gt;
</td>
</tr>

</table>


<h2><a name="Configuration_Root">Configuration Root</a></h2>

<p>
One of the basic components of the NCX Data Model is the concept
of the <b>configuration root</b>.
This is a conceptual container, which represents the root
of all contents of a NETCONF configuration database.
</p>

<p>
A configuration root is not bound to a specific configuration database.
The contents (i.e., child nodes) can conceptually be copied
or moved between configuration databases (e.g., 
copy &lt;running&gt; to &lt;startup&gt;).
</p>

<p>
All configuration databases contain only configuration 
application parameter sets, except the special
&lt;running&gt; configuration, which can contain configuration
and state data.
</p>

<p>
All configuration databases have a configuration root,
representing in Xpath with the instance identifier value '/';
</p>

<h2><a name="Applications">Applications</a></h2>

<p>
All definitions 
are specified within the context of a particular NCX Application..  
This is owner-unique string value, which follows 
the <a href="modules.html#Names">NcxName</a>
type definition syntax and semantics.
</p>

<p>
Conceptually, NCX Data Types do not need a namespace assignment,
since only data model objects are accessible via protocol operations,
but they are assigned one anyway for XSD translation purposes.
The special application name <b>types</b> is used (by convention)
in modules which contain only reusable data types and no accessible 
data model objects.
</p>

<h3><a name="Application_Header_Nodes">Application Header Nodes</a></h3>

<p>
An application header node is the top-level container for
data model parameter set definitions, for a specific application.
All application header nodes are child nodes of the conceptual
configuration root.
</p>

<pre>

    &lt;rpc message-id=&quot;101&quot; xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
      &lt;get-config&gt;
        &lt;source&gt;
          &lt;running/&gt;
        &lt;/source&gt;
        &lt;filter type=&quot;subtree&quot;&gt;
          &lt;interfaces xmlns=&quot;http://netconfcentral.org/ncx/interfaces&quot;/&gt;
          &lt;netconf xmlns=&quot;http://netconfcentral.org/ietf/netconf&quot;/&gt;
          &lt;routing xmlns=&quot;http://netconfcentral.org/ncx/routing&quot;/&gt;
        &lt;/filter&gt;
      &lt;/get-config&gt;
    &lt;/rpc&gt;

</pre>

<h2>
<a name="Application_Definitions">Application Specific Definitions</a>
</h2>

<p>
The purpose of an NCX data model module is to specify management definitions
for use with the NETCONF protocol, which is based on a procedural
model, using RPC methods (also called protocol operations) to define
the standard and vendor-specific procedures.
</p>

<p>
Every NCX module must represent definitions for exactly
one owner-specific application.  Any number of modules can
be used to contain the definitions for an application,
which all share the same owner-specific naming scope
and application-specific XML namespace.
</p>

<p>
There are three types of application-specific definitions:
</p>

<ul>
<li>RPC method</li>
<li>Parameter Set</li>
<li>Notification</li>
</ul>

<p>
Data type definitions are owner-specific, and can
be used by any owner or any application.
</p>

<p>
RPC Methods can use parameters, which are defined in RPC parameter sets.
</p>

<p>
Data models for use with the standard NETCONF protocol operations
are also defined in parameter sets.
</p>

<p>
Application-specific notification definitions can be specified,
which will be generated under certain conditions as a NETCONF
Event Notification message.
</p>

<h3><a name="RPC_Methods">RPC Methods</a></h3>

<p>
The top-level interface in NCX (and NETCONF) is the remote procedure call.
All management requests are made using an &lt;rpc&gt; element,
and all corresponding management responses are made using
an &lt;rpc-reply&gt; element, as defined in the NETCONF standard.
</p>

<p>
There are several standard RPC methods, owned by <b>ietf</b>,
that are defined within the NETCONF protocol:
</p>

<ul>
<li>get-config</li>
<li>edit-config</li>
<li>copy-config</li>
<li>delete-config</li>
<li>get</li>
<li>lock</li>
<li>unlock</li>
<li>validate</li>
<li>commit</li>
<li>discard-changes</li>
<li>close-session</li>
<li>kill-session</li>
</ul>

<p>
NCX has special support for some NETCONF operations which
use a configuration database parameter, such as &lt;edit-config&gt;.
For example, the 'operation' attribute used in NETCONF is automatically supported
and never has to be declared within a data model.
</p>

<h3><a name="Parameter_Sets">Parameter Sets</a></h3>

<p>
A Parameter is a conceptual instance of a specific data type.
It can be represented in different formats, such as XML or CLI.
</p>

<p>
A parameter must be defined with a Parameter Set, which can contain
read-only and/or writable parameters, as well as choices of parameters.
</p>

<p>
An <b>RPC parmset</b> is intended for use with one or more
particular RPC methods.  The parameter nodes are rooted
directly under the RPC method name node, which
is directly under the lt7rpc&gt; node.
</p>

<p>
A <b>data parmset</b> is intended to represent configuration and/or state
data for a specific application.  The parmset node must be contained
within the appropriate application node, and parameter nodes are
contained within the parmset node.
</p>

<p>
Parameter sets are 
different than a <b>struct</b> data object in three ways:
</p>

<ol>
<li>
A <b>data parmset node</b> is the only node type that is allowed
to be contained with an <b>application header node</b>.  A 
struct node is only allowed to be contained
within a parameter node or another parameter child node.
</li>
<li>
Child nodes within parameter sets may appear in any order
within an XML (or CLI) instance document.  Child nodes
within a structured complex type must appear in their defined order
</li>
<li>
Protocol error processing is affected by the parameter set definitions,
which represents the containment boundary for immediate fate-sharing
for all edit operations.  If the <b>continue-on-error</b> option
in the &lt;edit-config&gt; operation is used, then errors
detected in one data parmset will not impact processing of
data defined in a different data parmset.
</li>
</ol>

<h3><a name="Notifications">Notifications</a></h3>

<p>
The &lt;notification&gt; element is currently under development
by the NETCONF WG.  When it is completed, the 
<a href="modules.html#NCX_Notifications">notification</a> construct
can be used to define application-specific event notification
messages that will be generated for NETCONF sessions.
</p>

<p>
Just as with the protocol operations, the notification message
will contain a conceptual root called &lt;data&gt;, which can
be used to include an arbitrary amount of data from the &lt;running&gt;
configuration.
</p>

<h2><a name="Config_Root">Configuration Root</a></h2>

<p>
A <b>configuration root</b> is a special
conceptual data type which represents the top-level container
for all the application nodes and their parameter set instances,
comprising a conceptual configuration database.
</p>

<p>
By definition, there is only one conceptual configuration
database root.
The special data type <a href="datatypes.html#root">root</a>
is used to identify an element used for this purpose.
</p>

<p>
The 'root' data type yay only appear in RPC parmsets, not in data parmsets.
The &lt;config&gt; and &lt;filter&gt; parameters
found in some NETCONF protocol operations are instances
of the 'root' data type.  This data type is not allowed to
be nested in any way. Specifically, data parmset 'parm' nodes and
child nodes defined within complex data types are not permitted
to use the 'root' data type.
</p>


<h2><a name="NV_Storage">Non-Volatile Configuration Storage</a></h2>

<p>
The data representation capabilities of every configuration
database may not be the same within an agent.  For example,
it is not required in the NETCONF protocol to allow edit
operations on the &lt;startup&gt; configuration.  Some
implementations store configurations in non-volatile
memory in a different format than XML.  This is a common
practice an routers and switches.
</p>

<p>
Although the NETCONF protocol does not prohibit alternate
formats for configuration storage, it does not support it either.
Therefore, the <a href="extensions.html#NCX_Extensions"><b>with-defaults</b></a>
extension has been added to suppress the output of configuration data
instances which contain the default value for that parameter.
</p>

<p>
By default, an NCX configuration database is saved in XML format,
using a top-level (root) element named &lt;config&gt;.
The <b>with-defaults</b> attribute is used to suppress output
of default values for all relevant operations, including
saving the configuration in NV-storage.
</p>

<p>
The 'with-defaults=&quot;false&quot;' option produces the smallest 
possible output for NV-storage (or &lt;get-config&gt; retrieval), 
but assumes the default value will never change.  If a newer 
software release changes a default for a parameter, then this 
will cause a silent configuration change, if the NV-stored configuration
is done without defaults.
</p>

<p>
By default, configurations are saved as XML instance documents,
in which the top-level element is called &lt;config&gt;.
The following example shows an XML configuration file.
The <b>XML directive</b> on the first line should
be present to identify the content and its encoding.
</p>

<pre>
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;config&gt;
      &lt;nc-agent xmlns="http://example.com/xsd/nc-agent"&gt;
        &lt;nc-transport&gt;
          &lt;bindings&gt;
            &lt;binding&gt;
              &lt;id&gt;1&lt;/id&gt;
              &lt;protocol&gt;ssh&lt;/protocol&gt;
              &lt;port&gt;830&lt;/port&gt;
            &lt;/binding&gt;
            &lt;binding&gt;
              &lt;id&gt;2&lt;/id&gt;
              &lt;protocol&gt;ssh&lt;/protocol&gt;
              &lt;port&gt;22&lt;/port&gt;
            &lt;/binding&gt;
          &lt;/bindings&gt;
        &lt;/nc-transport&gt;
      &lt;/nc-agent&gt;
      &lt;security xmlns="http://example.com/xsd/security"&gt;
        &lt;ncx-access&gt;
          &lt;mode&gt;strict&lt;/mode&gt;
          &lt;groups&gt;
            &lt;group&gt;
              &lt;name&gt;control-staff&lt;/name&gt;
              &lt;users&gt;
                &lt;user&gt;andy&lt;/user&gt;
                &lt;user&gt;fred&lt;/user&gt;
              &lt;/users&gt;
            &lt;/group&gt;
            &lt;group&gt;
              &lt;name&gt;monitor-staff&lt;/name&gt;
              &lt;users&gt;
                &lt;user&gt;wilma&lt;/user&gt;
                &lt;user&gt;barney&lt;/user&gt;
              &lt;/users&gt;
            &lt;/group&gt;
          &lt;/groups&gt;
          &lt;rpc-type-acls&gt;
            &lt;rpc-type-acl&gt;
              &lt;group&gt;control-staff&lt;/group&gt;
              &lt;rpc-types&gt;config monitor debug exec other&lt;/rpc-types&gt;
            &lt;/rpc-type-acl&gt;
            &lt;rpc-type-acl&gt;
              &lt;group&gt;monitor-staff&lt;/group&gt;
              &lt;rpc-types&gt;monitor debug&lt;/rpc-types&gt;
            &lt;/rpc-type-acl&gt;
          &lt;/rpc-type-acls&gt;
        &lt;/ncx-access&gt;
      &lt;/security&gt;
    &lt;/config&gt;
    
</pre>

<h1><a name="NCX_Naming">NCX Naming</a></h1>

<p>
A <b>Name</b> is used to attach a string-based label to a conceptual 
entity.  Names are not required to be unique.
</p>

<p>
An <b>Identifier</b> is used to attach a string-based label 
to a conceptual entity.  Identifiers are required to be unique.
</p>

<h2><a name="Names">Names</a></h2>

<ul>
<li>NCX name strings are fields used within identifiers in some fashion</li>
<li>An NCX name string can be 1 to 1023 characters in length</li>
<li>All names are case-sensitive</li>
<li>The first character must be a letter ('a'..'z' or 'A'..'Z')</li>
<li>The rest of the characters in an NCX name can be any of:
  <ul>
  <li>letter ('a'..'z' or 'A'..'Z')</li>
  <li>number ('0'..'9')</li>
  <li>underscore ('_')</li>
  <li>dash ('-')</li>
  </ul>
</li>
</ul>

<p>
The NCX type for an NCX Name is defined as follows:
</p>

<pre>

    type NcxName {
      description "General Purpose NCX Name string.";
      syntax { 
	string (1..1023) pattern = "[a-z,A-Z][a-z,A-Z,0-9,\-,_]*"; 
      }
    }

</pre>

<h3><a name="Identifiers">Identifiers</a></h3>

<p>
There are two types of identifiers:
</p>

<ul>
<li><b>Definition Identifier</b><br/>
Used to identify conceptual data model definitions
</li>
<li><b>Instance Identifier</b><br/>
Used to identify conceptual instances of data model definitions
</li>
</ul>

<h4><a name="Definition_Identifiers">Definition Identifiers</a></h4>

<p>
Any definition identifier can be specified in a simple form or
a module-qualified form.  If a simple identifier is not found in
the current module, the imports section is checked to find
the module that contains the definition.
</p>

<p>
The module-qualified form of an identifier allows a specific module
to be specified, instead of checking the current module or checking
the imports section.  This allows definitions from different owners
to be used unambiguously within the current module, but it is more verbose.
</p>

<p>
The following table describes the various forms of Definition Identifiers:
</p>

<table summary="Definition Identifiers" border="1" align="center" width="100%">
<tr>  
<th>Name</th>
<th>Example</th>
<th>Description</th>
</tr>

<tr>  
<td>Simple Identifier</td>
<td> foo </td>
<td>Used to identify a module level definition within the same NCX module,
or from a module determined from the <a href="#NCX_Imports">imports</a> section.
Follows the encoding rules for an <a href="#Names">NCX Name</a>
</td>
</tr>

<tr>  
<td>Module Qualified Simple Identifier</td>
<td> acme:foo </td>
<td>Used to identify a module level definition from a specific NCX module.
Contains an <a href="#Hdr_Owner">owner</a> string, followed by
a colon (:) token, followed by a Simple Identifier.
</td>
</tr>

<tr>  
<td>Scoped Identifier</td>
<td> foo.bar.baz </td>
<td>Used to identify a nested construct within a module-level definition,
which is defined the same NCX module.
Contains a Simple Identifier, followed by one or more pairs of
a Period token (.), followed by a Simple Identifier.
</td>
</tr>

<tr>  
<td>Module Qualified Scoped Identifier</td>
<td> acme:foo.bar.baz </td>
<td>Used to identify a nested conceptual node within a module-level definition,
from a specific NCX module.
Contains an <a href="#Hdr_Owner">owner</a> string, followed by
a colon (:) token, followed by a Scoped Identifier.
</td>
</tr>
</table>

<p>
The NCX types for an NCX Definition Identifier are defined as follows:
</p>

<pre>

    type NcxSimpleId {
      description "Simple Definition Identifier string.";
      syntax { NcxName; }
    }

    type NcxScopedId {
      description "Scoped Definition Identifier string.";
      syntax {
	string (3..) pattern =
          "([a-z,A-Z][a-z,A-Z,0-9,\-,_]*)\.(([a-z,A-Z][a-z,A-Z,0-9,\-,_]*)+)";
      }
    }

    type NcxModQualId {
      description "Module Qualified Simple Definition Identifier string.";
      syntax {
	string (3..) pattern =
          "([a-z,A-Z][a-z,A-Z,0-9,\-,_]*):([a-z,A-Z][a-z,A-Z,0-9,\-,_]*)";
      }
    }

    type NcxModScopedId {
      description "Module Qualified Scoped Definition Identifier string.";
      syntax {
	string (5..) pattern =
          "([a-z,A-Z][a-z,A-Z,0-9,\-,_]*):([a-z,A-Z][a-z,A-Z,0-9,\-,_]*)\."
          "(([a-z,A-Z][a-z,A-Z,0-9,\-,_]*)+)";
      }
    }

    type NcxSimpleIdentifier {
      description "Union of all the simple identifier types.";
      syntax {
        union { NcxSimpleId NcxModQualId };
      }
    }

    type NcxIdentifier {
      description "Union of all the Identifier types.";
      syntax {
        union { NcxSimpleId NcxScopedId NcxModQualId NcxModScopedId };
      }
    }

</pre>

<h3><a name="Instance_Identifiers">Instance Identifiers</a></h3>

<p>
An NCX Instance Identifier is represented with an 
<b>Absolute <a href="http://www.w3.org/TR/xpath">Xpath</a> Expression</b>.
The Xpath Specification defines the allowable syntax
for a valid XPath expression.  
The NCX language imposes the following constraints and procedures
for an NCX Instance Identifier:
</p>

<ul>
<li>An instance identifier must 'match' exactly zero or one instance of 
  the indicated conceptual data model within a NETCONF implementation.</li>
<li>There is a common <b>fixed root</b>, i.e., starting with the
  &lt;rpc&gt; element for NETCONF methods and data, and 
  the &lt;notification&gt; for NETCONF Notifications.</li>
<li>There is also a conceptual <b>relative root</b> for data.
This is unnamed, and will be called something like &lt;config&gt; 
or &lt;data&gt; or &lt;filter&gt; in a NETCONF PDU.</li>
<li>There is no default namespace associated with the root, so
it must be specified within the PDU with appropriate 'xmlns' 
directives, so the prefixes used within the Xpath expression
can be resolved.</li>
<li>Each component within the Xpath expression must consist of properly 
formatted Qualified Name.
<pre>

   E.g., The default namespace is set to NETCONF Base:

   # fixed root, used in &lt;error-path&gt; elements
   /rpc/edit-config/config/ietf:interfaces/interface[name='eth0']/ifName

   /rpc/edit-config/acme:foo/bar/baz/ietf:interfaces/interface[name='eth5']

   /rpc/acme:secret-get-function/get-mode

   # relative root, used in &lt;get&gt; and &lt;get-config&gt; operations

   /acme:foo/bar/baz/ietf:interfaces/interface[name='eth5']

   /netconf/eventStreams/eventStream[name='syslog-stream']

</pre>
</li>
<li>An absolute Xpath expression containing sub-claused for
all relevant conceptual index (key) components represents 
an instance of conceptual data.</li>
<li>Index component expressions are concatenated to form
form a logical 'AND' expression,
in which all the terms must be true for the expression to be true.</li>
<li>The order of components within a conceptual index is significant.</li>
<li>The leftmost index component is called the <b>major index</b>.</li>
<li>Each <b>minor index</b> in succession (if any) is listed left to right, 
after the major index, in the order the index is defined within
the conceptual model.
<pre>

    E.g., the &lt;bar&gt; element represents a table indexed by 2 integers;
    a major index called 'x', and a minor index called 'y':

    /rpc/edit-config/config/acme:foo/bar[x=3][y=4]

    E.g., the &lt;baz&gt; element represents a table within &lt;bar&gt;,
    indexed by a string called 'name':

    /rpc/edit-config/config/foo/bar[x=3][y=4]/baz[name='fred']

</pre>
</li>
<li>Instances of unnamed data (e.g. maxOccurs="unbounded" and 
 no 'key' defined) are identified by their position, relative to 
 other instances of the same element</li>
<li>The short form of the 'position()' function in Xpath (e.g., foo[3]) 
is used to identify unnamed data instances.</li>
<li>The first occurrence of an unnamed instance is identified with the 
position value '1'.</li>
<li><b>Unnamed instances</b> are only identified by their integer position,
and can only be accessed by this position.</li>
<li><b>Named instances</b> are only identified by their associated 'index' 
clause (i.e. key), and can be accessed by their key value or position.
<pre>

    E.g., the relative named instance identifier for an interface named 'Eth0'

    /ietf:interfaces/interface[name='Eth0']

    E.g., the relative unnamed instance identifier for the
    third instance of &lt;goo&gt;:in the second instance of &lt;zoo&gt;:

    /acme:foo/bar[x=3][y=4]/baz[name='fred']/zoo[2]/goo[3]

</pre>
</li>
<li>RPC methods are identified by their path from the absolute root,
and instance identifiers used within &lt;error-path&gt; elements may identify
the entire path to the &lt;rpc&gt; element.
<pre>

    /rpc/edit-config/error-option

    /rpc/acme:get-table/index-parm

    /rpc/edit-config/config/interfaces/interface[name='eth0']

</pre>
</li>
</ul>

<p>
Instance identifiers are used as &lt;error-path&gt; element values
within the &lt;rpc-error&gt; field in NETCONF RPC replies.  They
(of course) can also used as the value of the 'select' attribute
in the &lt;filter&gt; parameter for the NETCONF &lt;get&gt; operation.
</p>

<p>
For any valid instance identifier, a valid 'subtree' filter expression
can be constructed.  (Details TBD).
</p>
    
<hr/>
<p>
Copyright &copy; 2007 by Andy Bierman, All Rights Reserved.
</p>
<p>Last-Updated: 2007-06-02</p>
</body>
</html>

