ncx-module test {
  header {
    description "Test module";
    version 1.0;
    owner ncx;
    application test;
    copyright "Copyright 2006 andybierman.com";
    contact-info "Send comments to <ietf@andybierman.com>.";
    last-update "2006-12-05";
    revision-history {
      1.0    "Initial version";
    }
  }
  imports {
    # 1) Go through the modules that have items
    #    explicitly listed, looking for the imported item
    # 2) If not found, go through the list again, checking
    #    the modules without an items list.

    import xsd;
    import smi { Counter32 Counter64 ZeroBasedCounter64 };
    import netconf { RpcDataReplyType };    
  }

  definitions {

    # definitions can appear in any order, but no forward
    # definitions are allowed.

    type String1 {
      syntax  {
        string pattern = "/c+";
      }
    } 

    type String2 {
      syntax  {
        string = { x "testing one two" "testing 3 4" }*;
      }
    } 

    type String3 {
      syntax  {
        String2;
      }
      metadata {
         String1  m1;
         string mstr;
      }
      default "x";
    } 

    type Enum1 {
      syntax  {
        enum = {  fred wilma barney=53  };
      }
    }

    type DateTimeStamp {
      description "Readonly timestamp in dateTime format.";
      syntax { dateTime; }
      max-access read-only;
      data-class state;
    }

    type Counter1 {
      description 
         "A description string needs quotes only if it contains 
          whitespace.";

      # the C expression syntax is permitted in a condition clause
      # only the 'capability' function is defined do far
      # xpath expression variant TBD
      # This is not usually used in a type decl, but it is allowed

      condition "capability(acme:bigcounters)";
      syntax {
        Counter64;
      }
      metadata {
        DateTimeStamp lastChangeTime?;
      }
      # default "defval";  but counters don't have defalts
      max-access "read-only";
      # appinfo { }
    }   

    # chained simple types inherit (or override) characteristics
    # just like OO classes (closest class def wins)

    type ZCounter {
      syntax { Counter1; }
      default "0";
    }

    # inline simple types are terminated with a semi-colon
    # but inline complex types are not
    type Struct1 {
      syntax {
        struct {
          int   a;    # signed 32 bit
          uint  b;    # unsigned 32 bit
          long  c;    # signed 64 bit
          ulong d;    # unsigned 64 bit
          float e;    # 32 bit IEEE real 
          double f;   # 64 bit IEEE real 
          string g;   # XSD string
          ustring h;  # XSD hexBinary
          xlist i;     # list of string  (not translated yet)
          list j {int};    # list of integers
          any   k;    # XSD anyType
          flag m;     # empty element flag
          enum n =    # enum is like C, start at 0, no num = prev + 1 
            { foo=1 bar baz=7 goo };   # bar(2)  goo(8)
          struct o {
            int x (1..10);
            string y = { up down testing };
          }

          # simple 1 of N choice, where 1 choice is one child node
          # or a group (in square brackets]
          choice p {
            Counter64 cnt;           # choice 1
            [ Counter32 locnt;       # choice 2
              Counter32 hicnt; ]     # choice 2
          }

          # table is really a row; element 'q' repeats
          # this is needed for named types, which may
          # be simple or complex. 
          # inline and remote index components are inserted first,
          # before any local components within the table 
          # TBD:
          #  complete remote index specification 
          #  How to support both forms
          #   Remote: ifIndex 
          #   Remote Scoped: ifEntry.ifIndex
          table q [int inline-index1, index2] {
            string index2;
            string column1 pattern = "\c+";
          }

          # container of 1 itemtype (simple or complex)
          container names [name] (100) {
            string name (1..255);
          }
        }
      }
      metadata {
        string test?;
      }
      appinfo {
        fred "flintstone";
        barney "rubble";
      }
    }

    type Test1Row {
      description "Test 1 Table";
      syntax  {
        table [str1, str2] (60)
        {
	   # inline definitions do not need to use
           # the contaainer data struct but the table
           # indexing is coupled to the table contents
           # and no reindexing is possible
           
           String1  str1;
           String2  str2;
           struct foo {
              int   x;
              int   y?;
              string z*;
           }
           long    longval;
        }
      }
      metadata {
         enum m1 = { notyp=1 deftyp settyp };
         uint m2?;
      }
    }

    type Row1 {
      description "Test 1 Row";
      syntax {
        struct {
           string  str1 = { foo bar baz };
           string  name (1..255);
           ulong   bytes?;
        }
      }
    }
    
    type CounterSet {
      description "Sample Counters";
      syntax {
        struct {
           Counter64  bytes;
           ZCounter   zbytes;
           Counter64  c3*;
           Counter64  c4+;
        }
      }
      metadata {
        dateTime   lastChangeTime;
      }
      max-access read-only;
      appinfo {
        counter-reset-events "reboot";
        discontinuity-object "sysUpTime.0";
      }
    }

    type Table1 {
      description "Test 1 Table with 1 local index and maxrows==60";
      syntax  {
        table [str1] (60) {
           string  str1 = { foo bar baz };
           string  name (1..255);
           ulong    bytes;
           table childtable [x] {
             int x;
             int y;
           }
        }
      }
      metadata { int t; }
    }

    type Table1a {
      description "Test 1A Table";
      syntax  {
        table [String3 name, int num] (60) {
           string  str1 = { foo bar baz };
           ulong    bytes;
        }
      }
    }

    type Container1 {
      description "Test 1 Container";
      syntax {
        container [testrow.str1] (60){
          Row1 testrow;
        }
      }
    }

    type Table2 {
      description "Nested Containers";
      syntax {
        table [x] {
          int x;
          
          container testrows [testrow.name, testrow.str1] {
            Row1 testrow;
          }
          container names [name] {
            string name (1..255);
          }
          Table1 tab1?;	
          Table1a tab1a;
          Container1 con1;
          int y;
        }
      }
    }

    parmset Parmset1 {
      description
        "Parameter Set Definitions contain writable parameters
         and read-only objects, 

         Data parmsets are collected in an application node
         in the XML (from the module header)
         RPC Parmsets are extensions of the rpcOperationType
         and are used directly (no container node) by 1 or more
         RPC methods.

         Parmsets for RPC input must not contain read-only
         mandatory parameters or parsing will always fail
         for that parameter.";

      condition "condition string syntax not checked yet";
      order strict;          # XML data should be strict order
      type rpc;
      appinfo {
         fooparm "Set to any string";
         fooflag;       # value optional == empty element
      }
      parms {
        parm p1 {
          description 
             "Parameters can be conditional. 
              Runtime Condition Language TBD.";
          condition "capability(acme:wifi-extensions)";
          type Container1;
          max-access read-write;
          usage conditional;   # default if condition clause present
        }
        parm p2 {
          type string;
        }
        parm p3 {
          type String3;
          usage optional;
        }
        parm p4 {
          type Row1;
        }
        parm p5 {
          condition "capability(acme:config-package)";
          type Table1;
        }
      }
    }

    parmset Parmset2 {
      order strict;
      type data;
      parms {
        parm p6 {
          type Table1a;
        }
        parm p7 {
          type Container1;
        }
        parm p8 {
          type Table2;
        }
        parm stats {
          type CounterSet;
          data-class state; 
        }
      }
    }

    parmset Test1Psd {
      description "Optional PSD Description";
      type rpc;
      parms {
        parm p1 {
          description 
             "Parameters can be conditional. 
              Runtime Condition Language TBD.";
          condition "capability(acme:wifi-extensions)";
          type Enum1;
          max-access read-write;
          usage conditional;
        }
        parm p2 {
          type Enum1;
        }
        parm p3 {
          type String1;
          usage optional;
        }

	# parmsets can have embedded choices
        # the same constructs are available in the syntax
        # clause with the 'choice' data type

        choice {

          parm p4 {
	    type Row1;
          }
      
        # to choose more than 1 param, square brackets are used to
        # create an inline group

        [
          parm p5 {
            type String2;
            usage optional;
          }
           parm p6 {
            type float;
            usage conditional;
          }
        ]

          parm p7 {
            type string;
          }

        }  # of of choice 
       
        parm p8 {
          type Test1Row;
        }
        parm p9 {
          type flag;
        }
        parm p10 {
          type any;
        }
      }
    }

    rpc rpc-one {
      description 
       "An RPC method is represented as an element which 
        replaces the abstract 'rpcType' and 'rpcOperationType'
        in the NETCONF schema.";
 
      # classification for this RPC method
      # other, config, exec, monitor, debug
      rpc-type debug;

      # input is optional; some RPCs (like discard-changes)
      # do not have any input.  If used, this must be
      # the name of an RPC parmset
      input Test1Psd;

      # output is not used in the agent or the XSD
      # if should be PrcOkReplyType or RpcDataReplyType
      # for NETCONF 1.0 protocol
      output RpcDataReplyType;
      appinfo {
        test-version "1.7";
      }
    }

  }
}