
<div>
   <h1 class="yang">ietf-yang-types.yang</h1>

   <ul id="nav">
      <li><a href="#">Typedefs</a>
         <ul>
            <li><a href="#counter32.39">counter32</a></li>
            <li><a href="#zero-based-counter32.69">zero-based-counter32</a></li>
            <li><a href="#counter64.95">counter64</a></li>
            <li><a href="#zero-based-counter64.125">zero-based-counter64</a></li>
            <li><a href="#gauge32.151">gauge32</a></li>
            <li><a href="#gauge64.173">gauge64</a></li>
            <li><a href="#object-identifier.200">object-identifier</a></li>
            <li><a href="#object-identifier-128.229">object-identifier-128</a></li>
            <li><a href="#date-and-time.245">date-and-time</a></li>
            <li><a href="#timeticks.300">timeticks</a></li>
            <li><a href="#timestamp.315">timestamp</a></li>
            <li><a href="#phys-address.339">phys-address</a></li>
            <li><a href="#xpath.356">xpath</a></li>
         </ul>
      </li>
   </ul>

<br />
<div class="yang">
<pre>

   <span class="yang_kw">module</span> <span class="yang_id">ietf-yang-types</span> {

      <span class="yang_kw">yang-version</span> <span class="yang_str">1</span>;

      <span class="yang_kw">namespace</span> <span class="yang_str">"urn:ietf:params:xml:ns:yang:yang-types"</span>;

      <span class="yang_kw">prefix</span> <span class="yang_str">"yang"</span>;

      <span class="yang_kw">organization</span>
         <span class="yang_str">"IETF NETMOD (NETCONF Data Modeling Language) Working Group"</span>;

      <span class="yang_kw">contact</span>
         <span class="yang_str">"WG Web:   &lt;http://tools.ietf.org/wg/netmod/&gt;
         WG List:  &lt;mailto:netmod@ietf.org&gt;
         
         WG Chair: David Partain
         	  &lt;mailto:david.partain@ericsson.com&gt;
         
         WG Chair: David Kessens
         	  &lt;mailto: david.kessens@nsn.com&gt;
         
         Editor:   Juergen Schoenwaelder
         	  &lt;mailto:j.schoenwaelder@jacobs-university.de&gt;"</span>;

      <span class="yang_kw">description</span>
         <span class="yang_str">"This module contains a collection of generally useful derived
         YANG data types.
         
         Copyright (C) 2009 The IETF Trust and the persons identified as
         the document authors.  This version of this YANG module is part
         of RFC XXXX; see the RFC itself for full legal notices."</span>;

      <span class="yang_kw">revision</span> <span class="yang_str">"2009-03-09"</span> {
         <span class="yang_kw">description</span>
            <span class="yang_str">"Initial revision, published as RFC XXXX."</span>;
      }


      <a name="counter32.39"></a><span class="yang_kw">typedef</span> <span class="yang_id">counter32</span> {
         <span class="yang_kw">type</span> <span class="yang_id">uint32</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The counter32 type represents a non-negative integer
            which monotonically increases until it reaches a
            maximum value of 2^32-1 (4294967295 decimal), when it
            wraps around and starts increasing again from zero.
            
            Counters have no defined `initial' value, and thus, a
            single value of a counter has (in general) no information
            content.  Discontinuities in the monotonically increasing
            value normally occur at re-initialization of the
            management system, and at other times as specified in the
            description of an object instance using this type.  If
            such other times can occur, for example, the creation of
            an object instance of type counter32 at times other than
            re-initialization, then a corresponding object should be
            defined, with an appropriate type, to indicate the last
            discontinuity.
            
            The counter32 type should not be used for configuration
            objects. A default statement should not be used for
            attributes with a type value of counter32.
            
            This type is in the value set and its semantics equivalent
            to the Counter32 type of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2578: Structure of Management Information Version 2 (SMIv2)"</span>;
      }

      <a name="zero-based-counter32.69"></a><span class="yang_kw">typedef</span> <span class="yang_id">zero-based-counter32</span> {
         <span class="yang_kw">type</span> <span class="yang_id"><a href="#counter32.39">counter32</a></span>;
         <span class="yang_kw">default</span> <span class="yang_str">"0"</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The zero-based-counter32 type represents a counter32
            which has the defined `initial' value zero.
            
            Objects of this type will be set to zero(0) on creation
            and will thereafter count appropriate events, wrapping
            back to zero(0) when the value 2^32 is reached.
            
            Provided that an application discovers the new object within
            the minimum time to wrap it can use the initial value as a
            delta since it last polled the table of which this object is
            part.  It is important for a management station to be aware
            of this minimum time and the actual time between polls, and
            to discard data if the actual time is too long or there is
            no defined minimum time.
            
            This type is in the value set and its semantics equivalent
            to the ZeroBasedCounter32 textual convention of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2021: Remote Network Monitoring Management Information
            	  Base Version 2 using SMIv2"</span>;
      }

      <a name="counter64.95"></a><span class="yang_kw">typedef</span> <span class="yang_id">counter64</span> {
         <span class="yang_kw">type</span> <span class="yang_id">uint64</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The counter64 type represents a non-negative integer
            which monotonically increases until it reaches a
            maximum value of 2^64-1 (18446744073709551615), when
            it wraps around and starts increasing again from zero.
            
            Counters have no defined `initial' value, and thus, a
            single value of a counter has (in general) no information
            content.  Discontinuities in the monotonically increasing
            value normally occur at re-initialization of the
            management system, and at other times as specified in the
            description of an object instance using this type.  If
            such other times can occur, for example, the creation of
            an object instance of type counter64 at times other than
            re-initialization, then a corresponding object should be
            defined, with an appropriate type, to indicate the last
            discontinuity.
            
            The counter64 type should not be used for configuration
            objects. A default statement should not be used for
            attributes with a type value of counter64.
            
            This type is in the value set and its semantics equivalent
            to the Counter64 type of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2578: Structure of Management Information Version 2 (SMIv2)"</span>;
      }

      <a name="zero-based-counter64.125"></a><span class="yang_kw">typedef</span> <span class="yang_id">zero-based-counter64</span> {
         <span class="yang_kw">type</span> <span class="yang_id"><a href="#counter64.95">counter64</a></span>;
         <span class="yang_kw">default</span> <span class="yang_str">"0"</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The zero-based-counter64 type represents a counter64 which
            has the defined `initial' value zero.
            
            Objects of this type will be set to zero(0) on creation
            and will thereafter count appropriate events, wrapping
            back to zero(0) when the value 2^64 is reached.
            
            Provided that an application discovers the new object within
            the minimum time to wrap it can use the initial value as a
            delta since it last polled the table of which this object is
            part.  It is important for a management station to be aware
            of this minimum time and the actual time between polls, and
            to discard data if the actual time is too long or there is
            no defined minimum time.
            
            This type is in the value set and its semantics equivalent
            to the ZeroBasedCounter64 textual convention of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2856: Textual Conventions for Additional High Capacity
            	  Data Types"</span>;
      }

      <a name="gauge32.151"></a><span class="yang_kw">typedef</span> <span class="yang_id">gauge32</span> {
         <span class="yang_kw">type</span> <span class="yang_id">uint32</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The gauge32 type represents a non-negative integer, which
            may increase or decrease, but shall never exceed a maximum
            value, nor fall below a minimum value.  The maximum value
            can not be greater than 2^32-1 (4294967295 decimal), and
            the minimum value can not be smaller than 0.  The value of
            a gauge32 has its maximum value whenever the information
            being modeled is greater than or equal to its maximum
            value, and has its minimum value whenever the information
            being modeled is smaller than or equal to its minimum value.
            If the information being modeled subsequently decreases
            below (increases above) the maximum (minimum) value, the
            gauge32 also decreases (increases).
            
            This type is in the value set and its semantics equivalent
            to the Counter32 type of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2578: Structure of Management Information Version 2 (SMIv2)"</span>;
      }

      <a name="gauge64.173"></a><span class="yang_kw">typedef</span> <span class="yang_id">gauge64</span> {
         <span class="yang_kw">type</span> <span class="yang_id">uint64</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The gauge64 type represents a non-negative integer, which
            may increase or decrease, but shall never exceed a maximum
            value, nor fall below a minimum value.  The maximum value
            can not be greater than 2^64-1 (18446744073709551615), and
            the minimum value can not be smaller than 0.  The value of
            a gauge64 has its maximum value whenever the information
            being modeled is greater than or equal to its maximum
            value, and has its minimum value whenever the information
            being modeled is smaller than or equal to its minimum value.
            If the information being modeled subsequently decreases
            below (increases above) the maximum (minimum) value, the
            gauge64 also decreases (increases).
            
            This type is in the value set and its semantics equivalent
            to the CounterBasedGauge64 SMIv2 textual convention defined
            in RFC 2856"</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2856: Textual Conventions for Additional High Capacity
            	  Data Types"</span>;
      }

      <a name="object-identifier.200"></a><span class="yang_kw">typedef</span> <span class="yang_id">object-identifier</span> {
         <span class="yang_kw">type</span> <span class="yang_id">string</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The object-identifier type represents administratively
            assigned names in a registration-hierarchical-name tree.
            
            Values of this type are denoted as a sequence of numerical
            non-negative sub-identifier values. Each sub-identifier
            value MUST NOT exceed 2^32-1 (4294967295). Sub-identifiers
            are separated by single dots and without any intermediate
            white space.
            
            Although the number of sub-identifiers is not limited,
            module designers should realize that there may be
            implementations that stick with the SMIv2 limit of 128
            sub-identifiers.
            
            This type is a superset of the SMIv2 OBJECT IDENTIFIER type
            since it is not restricted to 128 sub-identifiers."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"ISO/IEC 9834-1: Information technology -- Open Systems
            Interconnection -- Procedures for the operation of OSI
            Registration Authorities: General procedures and top
            arcs of the ASN.1 Object Identifier tree"</span>;
      }

      <a name="object-identifier-128.229"></a><span class="yang_kw">typedef</span> <span class="yang_id">object-identifier-128</span> {
         <span class="yang_kw">type</span> <span class="yang_id"><a href="#object-identifier.200">object-identifier</a></span> {
            <span class="yang_kw">pattern</span> <span class="yang_str">'\d*(.\d*){1,127}'</span>;
         }
         <span class="yang_kw">description</span>
            <span class="yang_str">"This type represents object-identifiers restricted to 128
            sub-identifiers.
            
            This type is in the value set and its semantics equivalent
            to the OBJECT IDENTIFIER type of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2578: Structure of Management Information Version 2 (SMIv2)"</span>;
      }

      <a name="date-and-time.245"></a><span class="yang_kw">typedef</span> <span class="yang_id">date-and-time</span> {
         <span class="yang_kw">type</span> <span class="yang_id">string</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The date-and-time type is a profile of the ISO 8601
                   standard for representation of dates and times using the
                   Gregorian calendar. The format is most easily described
                   using the following ABFN (see RFC 3339):
            
                   date-fullyear   = 4DIGIT
                   date-month      = 2DIGIT  ; 01-12
                   date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31
                   time-hour       = 2DIGIT  ; 00-23
                   time-minute     = 2DIGIT  ; 00-59
                   time-second     = 2DIGIT  ; 00-58, 00-59, 00-60
                   time-secfrac    = "." 1*DIGIT
                   time-numoffset  = ("+" / "-") time-hour ":" time-minute
                   time-offset     = "Z" / time-numoffset
            
                   partial-time    = time-hour ":" time-minute ":" time-second
                                     [time-secfrac]
                   full-date       = date-fullyear "-" date-month "-" date-mday
                   full-time       = partial-time time-offset
            
                   date-time       = full-date "T" full-time
            
                   The date-and-time type is consistent with the semantics defined
                   in RFC 3339. The data-and-time type is compatible with the
                   dateTime XML schema type with the following two notable
                   exceptions:
            
                   (a) The data-and-time type does not allow negative years.
            
                   (b) The data-and-time time-offset -00:00 indicates an unknown
                       time zone (see RFC 3339) while -00:00 and +00:00 and Z all
                       represent the same time zone in dateTime.
            
                   This type is not equivalent to the DateAndTime textual
                   convention of the SMIv2 since RFC 3339 uses a different
                   separator between full-date and full-time and provides
                   higher resolution of time-secfrac.
            
                   The canonical format for date-and-time values mandates the UTC
                   time format with the time-offset is indicated by the letter "Z".
                   This is consistent with the canonical format used by the
            ;
            "</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 3339: Date and Time on the Internet: Timestamps
            RFC 2579: Textual Conventions for SMIv2
            W3C REC-xmlschema-2-20041028: XML Schema Part 2: Datatypes
            	  Second Edition"</span>;
      }

      <a name="timeticks.300"></a><span class="yang_kw">typedef</span> <span class="yang_id">timeticks</span> {
         <span class="yang_kw">type</span> <span class="yang_id">uint32</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The timeticks type represents a non-negative integer which
            represents the time, modulo 2^32 (4294967296 decimal), in
            hundredths of a second between two epochs. When objects
            are defined which use this type, the description of the
            object identifies both of the reference epochs.
            
            This type is in the value set and its semantics equivalent
            to the TimeTicks type of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2578: Structure of Management Information Version 2 (SMIv2)"</span>;
      }

      <a name="timestamp.315"></a><span class="yang_kw">typedef</span> <span class="yang_id">timestamp</span> {
         <span class="yang_kw">type</span> <span class="yang_id"><a href="#timeticks.300">timeticks</a></span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"The timestamp type represents the value of an associated
            timeticks object at which a specific occurrence happened.
            The specific occurrence must be defined in the description
            of any object defined using this type.  When the specific
            occurrence occurred prior to the last time the associated
            timeticks attribute was zero, then the timestamp value is
            zero.  Note that this requires all timestamp values to be
            reset to zero when the value of the associated timeticks
            attribute reaches 497+ days and wraps around to zero.
            
            The associated timeticks object must be specified
            in the description of any object using this type.
            
            This type is in the value set and its semantics equivalent
            to the TimeStamp textual convention of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2579: Textual Conventions for SMIv2"</span>;
      }

      <a name="phys-address.339"></a><span class="yang_kw">typedef</span> <span class="yang_id">phys-address</span> {
         <span class="yang_kw">type</span> <span class="yang_id">string</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"Represents media- or physical-level addresses represented
            as a sequence octets, each octet represented by two hexadecimal
            numbers. Octets are separated by colons.
            
            This type is in the value set and its semantics equivalent
            to the PhysAddress textual convention of the SMIv2."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"RFC 2579: Textual Conventions for SMIv2"</span>;
      }

      <a name="xpath.356"></a><span class="yang_kw">typedef</span> <span class="yang_id">xpath</span> {
         <span class="yang_kw">type</span> <span class="yang_id">string</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"This type represents an XPATH 1.0 expression."</span>;
         <span class="yang_kw">reference</span>
            <span class="yang_str">"W3C REC-xpath-19991116: XML Path Language (XPath) Version 1.0"</span>;
      }
   }  <span class="yang_cmt">// module ietf-yang-types</span>
</pre>
</div>
</div>