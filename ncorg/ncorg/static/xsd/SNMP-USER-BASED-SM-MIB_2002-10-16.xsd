<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns="urn:ietf:params:xml:ns:yang:smiv2:SNMP-USER-BASED-SM-MIB"
   targetNamespace="urn:ietf:params:xml:ns:yang:smiv2:SNMP-USER-BASED-SM-MIB"
   elementFormDefault="qualified" attributeFormDefault="unqualified"
   xml:lang="en" version="2002-10-16"
   xmlns:ncx="http://netconfcentral.com/ncx"
   xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
   xmlns:snmp-framework="urn:ietf:params:xml:ns:yang:smiv2:SNMP-FRAMEWORK-MIB"
   xmlns:smiv2="urn:ietf:params:xml:ns:yang:smiv2:SNMPv2-TC"
   xmlns:smi="urn:ietf:params:xml:ns:yang:yang-smi"
   xmlns:yang="urn:ietf:params:xml:ns:yang:yang-types">
   <xs:annotation>
      <xs:documentation>
         Converted from YANG file 'SNMP-USER-BASED-SM-MIB.yang' by yangdump version 0.9.3
         
         Module: SNMP-USER-BASED-SM-MIB
         Organization: SNMPv3 Working Group
         Version: 2002-10-16
         Contact: WG-email:   snmpv3@lists.tislabs.com
         Subscribe:  majordomo@lists.tislabs.com
         	    In msg body:  subscribe snmpv3
         
         Chair:      Russ Mundy
         	    Network Associates Laboratories
         postal:     15204 Omega Drive, Suite 300
         	    Rockville, MD 20850-4601
         	    USA
         email:      mundy@tislabs.com
         
         phone:      +1 301-947-7107
         
         Co-Chair:   David Harrington
         	    Enterasys Networks
         Postal:     35 Industrial Way
         	    P. O. Box 5004
         	    Rochester, New Hampshire 03866-5005
         	    USA
         EMail:      dbh@enterasys.com
         Phone:      +1 603-337-2614
         
         Co-editor   Uri Blumenthal
         	    Lucent Technologies
         postal:     67 Whippany Rd.
         	    Whippany, NJ 07981
         	    USA
         email:      uri@lucent.com
         phone:      +1-973-386-2163
         
         Co-editor:  Bert Wijnen
         	    Lucent Technologies
         postal:     Schagen 33
         	    3461 GL Linschoten
         	    Netherlands
         email:      bwijnen@lucent.com
         phone:      +31-348-480-685
      </xs:documentation>
      <xs:documentation>
         The management information definitions for the
         SNMP User-based Security Model.
         
         Copyright (C) The Internet Society (2002). This
         version of this MIB module is part of RFC 3414;
         see the RFC itself for full legal notices.
      </xs:documentation>
      <xs:appinfo>
         <ncx:source>
            /home/andy/swdev/trunk/netconf/modules/./ietf/SNMP-USER-BASED-SM-MIB.yang
         </ncx:source>
         <ncx:organization>SNMPv3 Working Group</ncx:organization>
         <ncx:contact>
            WG-email:   snmpv3@lists.tislabs.com
            Subscribe:  majordomo@lists.tislabs.com
            	    In msg body:  subscribe snmpv3
            
            Chair:      Russ Mundy
            	    Network Associates Laboratories
            postal:     15204 Omega Drive, Suite 300
            	    Rockville, MD 20850-4601
            	    USA
            email:      mundy@tislabs.com
            
            phone:      +1 301-947-7107
            
            Co-Chair:   David Harrington
            	    Enterasys Networks
            Postal:     35 Industrial Way
            	    P. O. Box 5004
            	    Rochester, New Hampshire 03866-5005
            	    USA
            EMail:      dbh@enterasys.com
            Phone:      +1 603-337-2614
            
            Co-editor   Uri Blumenthal
            	    Lucent Technologies
            postal:     67 Whippany Rd.
            	    Whippany, NJ 07981
            	    USA
            email:      uri@lucent.com
            phone:      +1-973-386-2163
            
            Co-editor:  Bert Wijnen
            	    Lucent Technologies
            postal:     Schagen 33
            	    3461 GL Linschoten
            	    Netherlands
            email:      bwijnen@lucent.com
            phone:      +31-348-480-685
         </ncx:contact>
      </xs:appinfo>
      <xs:appinfo>
         <ncx:revision>
            <ncx:version>2002-10-16</ncx:version>
            <ncx:description>
               Changes in this revision:
               - Updated references and contact info.
               - Clarification to usmUserCloneFrom DESCRIPTION
                 clause
               - Fixed 'command responder' into 'command generator'
                 in last para of DESCRIPTION clause of
                 usmUserTable.
               This revision published as RFC3414.
            </ncx:description>
         </ncx:revision>
         <ncx:revision>
            <ncx:version>1999-01-20</ncx:version>
            <ncx:description>
               Clarifications, published as RFC2574
            </ncx:description>
         </ncx:revision>
         <ncx:revision>
            <ncx:version>1997-11-20</ncx:version>
            <ncx:description>
               Initial version, published as RFC2274
            </ncx:description>
         </ncx:revision>
      </xs:appinfo>
   </xs:annotation>

   <xs:simpleType name="KeyChange">
      <xs:annotation>
         <xs:documentation>
            Every definition of an object with this syntax must identify
            a protocol P, a secret key K, and a hash algorithm H
            that produces output of L octets.
            
            The object's value is a manager-generated, partially-random
            value which, when modified, causes the value of the secret
            key K, to be modified via a one-way function.
            
            The value of an instance of this object is the concatenation
            of two components: first a 'random' component and then a
            'delta' component.
            
            The lengths of the random and delta components
            are given by the corresponding value of the protocol P;
            if P requires K to be a fixed length, the length of both the
            random and delta components is that fixed length; if P
            allows the length of K to be variable up to a particular
            maximum length, the length of the random component is that
            maximum length and the length of the delta component is any
            length less than or equal to that maximum length.
            For example, usmHMACMD5AuthProtocol requires K to be a fixed
            length of 16 octets and L - of 16 octets.
            usmHMACSHAAuthProtocol requires K to be a fixed length of
            20 octets and L - of 20 octets. Other protocols may define
            other sizes, as deemed appropriate.
            
            When a requester wants to change the old key K to a new
            key keyNew on a remote entity, the 'random' component is
            obtained from either a true random generator, or from a
            pseudorandom generator, and the 'delta' component is
            computed as follows:
            
             - a temporary variable is initialized to the existing value
               of K;
             - if the length of the keyNew is greater than L octets,
               then:
                - the random component is appended to the value of the
                  temporary variable, and the result is input to the
                  the hash algorithm H to produce a digest value, and
                  the temporary variable is set to this digest value;
                - the value of the temporary variable is XOR-ed with
                  the first (next) L-octets (16 octets in case of MD5)
                  of the keyNew to produce the first (next) L-octets
                  (16 octets in case of MD5) of the 'delta' component.
                - the above two steps are repeated until the unused
                  portion of the keyNew component is L octets or less,
             - the random component is appended to the value of the
               temporary variable, and the result is input to the
               hash algorithm H to produce a digest value;
             - this digest value, truncated if necessary to be the same
               length as the unused portion of the keyNew, is XOR-ed
               with the unused portion of the keyNew to produce the
               (final portion of the) 'delta' component.
            
             For example, using MD5 as the hash algorithm H:
            
                iterations = (lenOfDelta - 1)/16; /* integer division */
                temp = keyOld;
                for (i = 0; i &lt; iterations; i++) {
            	temp = MD5 (temp || random);
            	delta[i*16 .. (i*16)+15] =
            	       temp XOR keyNew[i*16 .. (i*16)+15];
                }
                temp = MD5 (temp || random);
                delta[i*16 .. lenOfDelta-1] =
            	   temp XOR keyNew[i*16 .. lenOfDelta-1];
            
            The 'random' and 'delta' components are then concatenated as
            described above, and the resulting octet string is sent to
            the recipient as the new value of an instance of this object.
            
            At the receiver side, when an instance of this object is set
            to a new value, then a new value of K is computed as follows:
            
             - a temporary variable is initialized to the existing value
               of K;
             - if the length of the delta component is greater than L
               octets, then:
                - the random component is appended to the value of the
                  temporary variable, and the result is input to the
                  hash algorithm H to produce a digest value, and the
                  temporary variable is set to this digest value;
                - the value of the temporary variable is XOR-ed with
                  the first (next) L-octets (16 octets in case of MD5)
                  of the delta component to produce the first (next)
                  L-octets (16 octets in case of MD5) of the new value
                  of K.
                - the above two steps are repeated until the unused
                  portion of the delta component is L octets or less,
             - the random component is appended to the value of the
               temporary variable, and the result is input to the
               hash algorithm H to produce a digest value;
             - this digest value, truncated if necessary to be the same
               length as the unused portion of the delta component, is
               XOR-ed with the unused portion of the delta component to
               produce the (final portion of the) new value of K.
            
             For example, using MD5 as the hash algorithm H:
            
                iterations = (lenOfDelta - 1)/16; /* integer division */
                temp = keyOld;
                for (i = 0; i &lt; iterations; i++) {
            	temp = MD5 (temp || random);
            	keyNew[i*16 .. (i*16)+15] =
            	       temp XOR delta[i*16 .. (i*16)+15];
                }
                temp = MD5 (temp || random);
                keyNew[i*16 .. lenOfDelta-1] =
            	   temp XOR delta[i*16 .. lenOfDelta-1];
            
            The value of an object with this syntax, whenever it is
            retrieved by the management protocol, is always the zero
            length string.
            
            Note that the keyOld and keyNew are the localized keys.
            
            Note that it is probably wise that when an SNMP entity sends
            a SetRequest to change a key, that it keeps a copy of the old
            key until it has confirmed that the key change actually
            succeeded.
         </xs:documentation>
      </xs:annotation>
      <xs:restriction base="xs:base64Binary"/>
   </xs:simpleType>

   <xs:element name="usmStats">
      <xs:annotation>
         <xs:appinfo>
            <ncx:config>true</ncx:config>
            <smi:oid  smi:oid="1.3.6.1.6.3.15.1.1"/>
         </xs:appinfo>
      </xs:annotation>
      <xs:complexType>
         <xs:sequence>
            <xs:element name="usmStatsUnsupportedSecLevels"
               type="yang:counter32" minOccurs="0">
               <xs:annotation>
                  <xs:documentation>
                     The total number of packets received by the SNMP
                     engine which were dropped because they requested a
                     securityLevel that was unknown to the SNMP engine
                     or otherwise unavailable.
                  </xs:documentation>
                  <xs:appinfo>
                     <ncx:config>false</ncx:config>
                     <smi:oid  smi:oid="1.3.6.1.6.3.15.1.1.1"/>
                  </xs:appinfo>
               </xs:annotation>
            </xs:element>
            <xs:element name="usmStatsNotInTimeWindows"
               type="yang:counter32" minOccurs="0">
               <xs:annotation>
                  <xs:documentation>
                     The total number of packets received by the SNMP
                     engine which were dropped because they appeared
                     outside of the authoritative SNMP engine's window.
                  </xs:documentation>
                  <xs:appinfo>
                     <ncx:config>false</ncx:config>
                     <smi:oid  smi:oid="1.3.6.1.6.3.15.1.1.2"/>
                  </xs:appinfo>
               </xs:annotation>
            </xs:element>
            <xs:element name="usmStatsUnknownUserNames"
               type="yang:counter32" minOccurs="0">
               <xs:annotation>
                  <xs:documentation>
                     The total number of packets received by the SNMP
                     engine which were dropped because they referenced a
                     user that was not known to the SNMP engine.
                  </xs:documentation>
                  <xs:appinfo>
                     <ncx:config>false</ncx:config>
                     <smi:oid  smi:oid="1.3.6.1.6.3.15.1.1.3"/>
                  </xs:appinfo>
               </xs:annotation>
            </xs:element>
            <xs:element name="usmStatsUnknownEngineIDs"
               type="yang:counter32" minOccurs="0">
               <xs:annotation>
                  <xs:documentation>
                     The total number of packets received by the SNMP
                     engine which were dropped because they referenced an
                     snmpEngineID that was not known to the SNMP engine.
                  </xs:documentation>
                  <xs:appinfo>
                     <ncx:config>false</ncx:config>
                     <smi:oid  smi:oid="1.3.6.1.6.3.15.1.1.4"/>
                  </xs:appinfo>
               </xs:annotation>
            </xs:element>
            <xs:element name="usmStatsWrongDigests"
               type="yang:counter32" minOccurs="0">
               <xs:annotation>
                  <xs:documentation>
                     The total number of packets received by the SNMP
                     engine which were dropped because they didn't
                     contain the expected digest value.
                  </xs:documentation>
                  <xs:appinfo>
                     <ncx:config>false</ncx:config>
                     <smi:oid  smi:oid="1.3.6.1.6.3.15.1.1.5"/>
                  </xs:appinfo>
               </xs:annotation>
            </xs:element>
            <xs:element name="usmStatsDecryptionErrors"
               type="yang:counter32" minOccurs="0">
               <xs:annotation>
                  <xs:documentation>
                     The total number of packets received by the SNMP
                     engine which were dropped because they could not be
                     decrypted.
                  </xs:documentation>
                  <xs:appinfo>
                     <ncx:config>false</ncx:config>
                     <smi:oid  smi:oid="1.3.6.1.6.3.15.1.1.6"/>
                  </xs:appinfo>
               </xs:annotation>
            </xs:element>
            <xs:element name="__.usmStats.A__" minOccurs="0"
               maxOccurs="unbounded" abstract="true"/>
         </xs:sequence>
      </xs:complexType>
   </xs:element>

   <xs:element name="usmUser">
      <xs:annotation>
         <xs:appinfo>
            <ncx:config>true</ncx:config>
            <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2"/>
         </xs:appinfo>
      </xs:annotation>
      <xs:complexType>
         <xs:sequence>
            <xs:element name="usmUserSpinLock" type="smiv2:TestAndIncr"
               minOccurs="0">
               <xs:annotation>
                  <xs:documentation>
                     An advisory lock used to allow several cooperating
                     Command Generator Applications to coordinate their
                     use of facilities to alter secrets in the
                     usmUserTable.
                  </xs:documentation>
                  <xs:appinfo>
                     <ncx:config>true</ncx:config>
                     <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.1"/>
                  </xs:appinfo>
               </xs:annotation>
            </xs:element>
            <xs:element name="usmUserEntry" minOccurs="0"
               maxOccurs="unbounded">
               <xs:annotation>
                  <xs:documentation>
                     A user configured in the SNMP engine's Local
                     Configuration Datastore (LCD) for the User-based
                     Security Model.
                  </xs:documentation>
                  <xs:appinfo>
                     <ncx:ordered-by>system</ncx:ordered-by>
                     <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1"/>
                  </xs:appinfo>
               </xs:annotation>
               <xs:complexType>
                  <xs:sequence>
                     <xs:element name="usmUserEngineID"
                        type="snmp-framework:SnmpEngineID">
                        <xs:annotation>
                           <xs:documentation>
                              An SNMP engine's administratively-unique identifier.
                              
                              In a simple agent, this value is always that agent's
                              own snmpEngineID value.
                              
                              The value can also take the value of the snmpEngineID
                              of a remote SNMP engine with which this user can
                              communicate.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>false</ncx:config>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.1"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserName">
                        <xs:annotation>
                           <xs:documentation>
                              A human readable string representing the name of
                              the user.
                              
                              This is the (User-based Security) Model dependent
                              security ID.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>false</ncx:config>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.2"/>
                           </xs:appinfo>
                        </xs:annotation>
                        <xs:simpleType>
                           <xs:restriction
                              base="snmp-framework:SnmpAdminString">
                              <xs:minLength value="1"/>
                              <xs:maxLength value="32"/>
                           </xs:restriction>
                        </xs:simpleType>
                     </xs:element>
                     <xs:element name="usmUserSecurityName"
                        type="snmp-framework:SnmpAdminString"
                        minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              A human readable string representing the user in
                              Security Model independent format.
                              
                              The default transformation of the User-based Security
                              Model dependent security ID to the securityName and
                              vice versa is the identity function so that the
                              securityName is the same as the userName.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>false</ncx:config>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.3"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserCloneFrom"
                        type="smiv2:RowPointer" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              A pointer to another conceptual row in this
                              usmUserTable.  The user in this other conceptual
                              row is called the clone-from user.
                              
                              When a new user is created (i.e., a new conceptual
                              row is instantiated in this table), the privacy and
                              authentication parameters of the new user must be
                              cloned from its clone-from user. These parameters are:
                                - authentication protocol (usmUserAuthProtocol)
                                - privacy protocol (usmUserPrivProtocol)
                              They will be copied regardless of what the current
                              value is.
                              
                              Cloning also causes the initial values of the secret
                              authentication key (authKey) and the secret encryption
                              
                              key (privKey) of the new user to be set to the same
                              values as the corresponding secrets of the clone-from
                              user to allow the KeyChange process to occur as
                              required during user creation.
                              
                              The first time an instance of this object is set by
                              a management operation (either at or after its
                              instantiation), the cloning process is invoked.
                              Subsequent writes are successful but invoke no
                              action to be taken by the receiver.
                              The cloning process fails with an 'inconsistentName'
                              error if the conceptual row representing the
                              clone-from user does not exist or is not in an active
                              state when the cloning process is invoked.
                              
                              When this object is read, the ZeroDotZero OID
                              is returned.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.4"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserAuthProtocol"
                        type="smiv2:AutonomousType" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              An indication of whether messages sent on behalf of
                              this user to/from the SNMP engine identified by
                              usmUserEngineID, can be authenticated, and if so,
                              the type of authentication protocol which is used.
                              
                              An instance of this object is created concurrently
                              with the creation of any other object instance for
                              the same user (i.e., as part of the processing of
                              the set operation which creates the first object
                              instance in the same conceptual row).
                              
                              If an initial set operation (i.e. at row creation time)
                              tries to set a value for an unknown or unsupported
                              protocol, then a 'wrongValue' error must be returned.
                              
                              The value will be overwritten/set when a set operation
                              is performed on the corresponding instance of
                              usmUserCloneFrom.
                              
                              Once instantiated, the value of such an instance of
                              this object can only be changed via a set operation to
                              the value of the usmNoAuthProtocol.
                              
                              If a set operation tries to change the value of an
                              
                              existing instance of this object to any value other
                              than usmNoAuthProtocol, then an 'inconsistentValue'
                              error must be returned.
                              
                              If a set operation tries to set the value to the
                              usmNoAuthProtocol while the usmUserPrivProtocol value
                              in the same row is not equal to usmNoPrivProtocol,
                              then an 'inconsistentValue' error must be returned.
                              That means that an SNMP command generator application
                              must first ensure that the usmUserPrivProtocol is set
                              to the usmNoPrivProtocol value before it can set
                              the usmUserAuthProtocol value to usmNoAuthProtocol.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:default  smi:default="usmNoAuthProtocol"/>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.5"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserAuthKeyChange"
                        type="KeyChange" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              An object, which when modified, causes the secret
                              authentication key used for messages sent on behalf
                              of this user to/from the SNMP engine identified by
                              usmUserEngineID, to be modified via a one-way
                              function.
                              
                              The associated protocol is the usmUserAuthProtocol.
                              The associated secret key is the user's secret
                              authentication key (authKey). The associated hash
                              algorithm is the algorithm used by the user's
                              usmUserAuthProtocol.
                              
                              When creating a new user, it is an 'inconsistentName'
                              error for a set operation to refer to this object
                              unless it is previously or concurrently initialized
                              through a set operation on the corresponding instance
                              of usmUserCloneFrom.
                              
                              When the value of the corresponding usmUserAuthProtocol
                              is usmNoAuthProtocol, then a set is successful, but
                              effectively is a no-op.
                              
                              When this object is read, the zero-length (empty)
                              string is returned.
                              
                              The recommended way to do a key change is as follows:
                              
                                1) GET(usmUserSpinLock.0) and save in sValue.
                                2) generate the keyChange value based on the old
                                   (existing) secret key and the new secret key,
                                   let us call this kcValue.
                              
                              If you do the key change on behalf of another user:
                              
                                3) SET(usmUserSpinLock.0=sValue,
                              	 usmUserAuthKeyChange=kcValue
                              	 usmUserPublic=randomValue)
                              
                              If you do the key change for yourself:
                              
                                4) SET(usmUserSpinLock.0=sValue,
                              	 usmUserOwnAuthKeyChange=kcValue
                              	 usmUserPublic=randomValue)
                              
                              If you get a response with error-status of noError,
                              then the SET succeeded and the new key is active.
                              If you do not get a response, then you can issue a
                              GET(usmUserPublic) and check if the value is equal
                              to the randomValue you did send in the SET. If so, then
                              the key change succeeded and the new key is active
                              (probably the response got lost). If not, then the SET
                              request probably never reached the target and so you
                              can start over with the procedure above.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:default  smi:default=""/>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.6"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserOwnAuthKeyChange"
                        type="KeyChange" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              Behaves exactly as usmUserAuthKeyChange, with one
                              notable difference: in order for the set operation
                              to succeed, the usmUserName of the operation
                              requester must match the usmUserName that
                              indexes the row which is targeted by this
                              operation.
                              In addition, the USM security model must be
                              used for this operation.
                              
                              The idea here is that access to this column can be
                              public, since it will only allow a user to change
                              his own secret authentication key (authKey).
                              Note that this can only be done once the row is active.
                              
                              When a set is received and the usmUserName of the
                              requester is not the same as the umsUserName that
                              indexes the row which is targeted by this operation,
                              then a 'noAccess' error must be returned.
                              
                              When a set is received and the security model in use
                              is not USM, then a 'noAccess' error must be returned.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:default  smi:default=""/>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.7"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserPrivProtocol"
                        type="smiv2:AutonomousType" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              An indication of whether messages sent on behalf of
                              this user to/from the SNMP engine identified by
                              usmUserEngineID, can be protected from disclosure,
                              and if so, the type of privacy protocol which is used.
                              
                              An instance of this object is created concurrently
                              with the creation of any other object instance for
                              the same user (i.e., as part of the processing of
                              the set operation which creates the first object
                              instance in the same conceptual row).
                              
                              If an initial set operation (i.e. at row creation time)
                              tries to set a value for an unknown or unsupported
                              protocol, then a 'wrongValue' error must be returned.
                              
                              The value will be overwritten/set when a set operation
                              is performed on the corresponding instance of
                              usmUserCloneFrom.
                              
                              Once instantiated, the value of such an instance of
                              this object can only be changed via a set operation to
                              the value of the usmNoPrivProtocol.
                              
                              If a set operation tries to change the value of an
                              existing instance of this object to any value other
                              than usmNoPrivProtocol, then an 'inconsistentValue'
                              error must be returned.
                              
                              Note that if any privacy protocol is used, then you
                              must also use an authentication protocol. In other
                              words, if usmUserPrivProtocol is set to anything else
                              than usmNoPrivProtocol, then the corresponding instance
                              of usmUserAuthProtocol cannot have a value of
                              
                              usmNoAuthProtocol. If it does, then an
                              'inconsistentValue' error must be returned.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:default  smi:default="usmNoPrivProtocol"/>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.8"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserPrivKeyChange"
                        type="KeyChange" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              An object, which when modified, causes the secret
                              encryption key used for messages sent on behalf
                              of this user to/from the SNMP engine identified by
                              usmUserEngineID, to be modified via a one-way
                              function.
                              
                              The associated protocol is the usmUserPrivProtocol.
                              The associated secret key is the user's secret
                              privacy key (privKey). The associated hash
                              algorithm is the algorithm used by the user's
                              usmUserAuthProtocol.
                              
                              When creating a new user, it is an 'inconsistentName'
                              error for a set operation to refer to this object
                              unless it is previously or concurrently initialized
                              through a set operation on the corresponding instance
                              of usmUserCloneFrom.
                              
                              When the value of the corresponding usmUserPrivProtocol
                              is usmNoPrivProtocol, then a set is successful, but
                              effectively is a no-op.
                              
                              When this object is read, the zero-length (empty)
                              string is returned.
                              See the description clause of usmUserAuthKeyChange for
                              a recommended procedure to do a key change.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:default  smi:default=""/>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.9"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserOwnPrivKeyChange"
                        type="KeyChange" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              Behaves exactly as usmUserPrivKeyChange, with one
                              notable difference: in order for the Set operation
                              to succeed, the usmUserName of the operation
                              requester must match the usmUserName that indexes
                              
                              the row which is targeted by this operation.
                              In addition, the USM security model must be
                              used for this operation.
                              
                              The idea here is that access to this column can be
                              public, since it will only allow a user to change
                              his own secret privacy key (privKey).
                              Note that this can only be done once the row is active.
                              
                              When a set is received and the usmUserName of the
                              requester is not the same as the umsUserName that
                              indexes the row which is targeted by this operation,
                              then a 'noAccess' error must be returned.
                              
                              When a set is received and the security model in use
                              is not USM, then a 'noAccess' error must be returned.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:default  smi:default=""/>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.10"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserPublic" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              A publicly-readable value which can be written as part
                              of the procedure for changing a user's secret
                              authentication and/or privacy key, and later read to
                              determine whether the change of the secret was
                              effected.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:default  smi:default=""/>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.11"/>
                           </xs:appinfo>
                        </xs:annotation>
                        <xs:simpleType>
                           <xs:restriction base="xs:base64Binary">
                              <xs:maxLength value="32"/>
                           </xs:restriction>
                        </xs:simpleType>
                     </xs:element>
                     <xs:element name="usmUserStorageType"
                        type="smiv2:StorageType" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              The storage type for this conceptual row.
                              
                              Conceptual rows having the value 'permanent' must
                              allow write-access at a minimum to:
                              
                              - usmUserAuthKeyChange, usmUserOwnAuthKeyChange
                                and usmUserPublic for a user who employs
                                authentication, and
                              - usmUserPrivKeyChange, usmUserOwnPrivKeyChange
                                and usmUserPublic for a user who employs
                                privacy.
                              
                              Note that any user who employs authentication or
                              privacy must allow its secret(s) to be updated and
                              thus cannot be 'readOnly'.
                              
                              If an initial set operation tries to set the value to
                              'readOnly' for a user who employs authentication or
                              privacy, then an 'inconsistentValue' error must be
                              returned.  Note that if the value has been previously
                              set (implicit or explicit) to any value, then the rules
                              as defined in the StorageType Textual Convention apply.
                              
                              It is an implementation issue to decide if a SET for
                              a readOnly or permanent row is accepted at all. In some
                              contexts this may make sense, in others it may not. If
                              a SET for a readOnly or permanent row is not accepted
                              at all, then a 'wrongValue' error must be returned.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:default  smi:default="nonVolatile"/>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.12"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="usmUserStatus"
                        type="smiv2:RowStatus" minOccurs="0">
                        <xs:annotation>
                           <xs:documentation>
                              The status of this conceptual row.
                              
                              Until instances of all corresponding columns are
                              appropriately configured, the value of the
                              corresponding instance of the usmUserStatus column
                              is 'notReady'.
                              
                              In particular, a newly created row for a user who
                              employs authentication, cannot be made active until the
                              corresponding usmUserCloneFrom and usmUserAuthKeyChange
                              have been set.
                              
                              Further, a newly created row for a user who also
                              employs privacy, cannot be made active until the
                              usmUserPrivKeyChange has been set.
                              
                              The RowStatus TC [RFC2579] requires that this
                              DESCRIPTION clause states under which circumstances
                              other objects in this row can be modified:
                              
                              The value of this object has no effect on whether
                              other objects in this conceptual row can be modified,
                              except for usmUserOwnAuthKeyChange and
                              usmUserOwnPrivKeyChange. For these 2 objects, the
                              
                              value of usmUserStatus MUST be active.
                           </xs:documentation>
                           <xs:appinfo>
                              <ncx:config>true</ncx:config>
                              <smi:oid  smi:oid="1.3.6.1.6.3.15.1.2.2.1.13"/>
                           </xs:appinfo>
                        </xs:annotation>
                     </xs:element>
                     <xs:element name="__.usmUser.usmUserEntry.A__"
                        minOccurs="0" maxOccurs="unbounded"
                        abstract="true"/>
                  </xs:sequence>
               </xs:complexType>
               <xs:key name="usmUserEntry_Key">
                  <xs:selector xpath="."/>
                  <xs:field xpath="usmUserEngineID"/>
                  <xs:field xpath="usmUserName"/>
               </xs:key>
            </xs:element>
            <xs:element name="__.usmUser.A__" minOccurs="0"
               maxOccurs="unbounded" abstract="true"/>
         </xs:sequence>
      </xs:complexType>
   </xs:element>

</xs:schema>
