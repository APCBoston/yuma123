
<div>
   <h1 class="yang">SNMP-USER-BASED-SM-MIB.yang</h1>

   <ul id="nav">
      <li><a href="#">Typedefs</a>
         <ul>
            <li><a href="#KeyChange.97">KeyChange</a></li>
         </ul>
      </li>
      <li><a href="#">Objects</a>
         <ul>
            <li class="daddy"><a href="#usmStats.222">usmStats</a>
               <ul>
                  <li><a href="#usmStatsUnsupportedSecLevels.224">usmStatsUnsupportedSecLevels</a></li>
                  <li><a href="#usmStatsNotInTimeWindows.235">usmStatsNotInTimeWindows</a></li>
                  <li><a href="#usmStatsUnknownUserNames.245">usmStatsUnknownUserNames</a></li>
                  <li><a href="#usmStatsUnknownEngineIDs.255">usmStatsUnknownEngineIDs</a></li>
                  <li><a href="#usmStatsWrongDigests.265">usmStatsWrongDigests</a></li>
                  <li><a href="#usmStatsDecryptionErrors.275">usmStatsDecryptionErrors</a></li>
               </ul>
            </li>
            <li class="daddy"><a href="#usmUser.287">usmUser</a>
               <ul>
                  <li><a href="#usmUserSpinLock.289">usmUserSpinLock</a></li>
                  <li class="daddy"><a href="#usmUserEntry.303">usmUserEntry</a>
                     <ul>
                        <li><a href="#usmUserEngineID.313">usmUserEngineID</a></li>
                        <li><a href="#usmUserName.328">usmUserName</a></li>
                        <li><a href="#usmUserSecurityName.342">usmUserSecurityName</a></li>
                        <li><a href="#usmUserCloneFrom.356">usmUserCloneFrom</a></li>
                        <li><a href="#usmUserAuthProtocol.396">usmUserAuthProtocol</a></li>
                        <li><a href="#usmUserAuthKeyChange.441">usmUserAuthKeyChange</a></li>
                        <li><a href="#usmUserOwnAuthKeyChange.502">usmUserOwnAuthKeyChange</a></li>
                        <li><a href="#usmUserPrivProtocol.531">usmUserPrivProtocol</a></li>
                        <li><a href="#usmUserPrivKeyChange.575">usmUserPrivKeyChange</a></li>
                        <li><a href="#usmUserOwnPrivKeyChange.609">usmUserOwnPrivKeyChange</a></li>
                        <li><a href="#usmUserPublic.638">usmUserPublic</a></li>
                        <li><a href="#usmUserStorageType.653">usmUserStorageType</a></li>
                        <li><a href="#usmUserStatus.689">usmUserStatus</a></li>
                     </ul>
                  </li>
               </ul>
            </li>
         </ul>
      </li>
   </ul>

<br />
<div class="yang">
<pre>

   <span class="yang_kw">module</span> <span class="yang_id">SNMP-USER-BASED-SM-MIB</span> {

      <span class="yang_kw">yang-version</span> <span class="yang_str">1</span>;

      <span class="yang_kw">namespace</span>
         <span class="yang_str">"urn:ietf:params:xml:ns:yang:smiv2:SNMP-USER-BASED-SM-MIB"</span>;

      <span class="yang_kw">prefix</span> <span class="yang_str">"snmp-user"</span>;

      <span class="yang_kw">import</span> <a href="/modules/SNMP-FRAMEWORK-MIB/2002-10-14">SNMP-FRAMEWORK-MIB</a> {
         <span class="yang_kw">prefix</span> <span class="yang_str">"snmp-framework"</span>;
      }
      <span class="yang_kw">import</span> <a href="/modules/SNMPv2-TC/1999-04-01">SNMPv2-TC</a> {
         <span class="yang_kw">prefix</span> <span class="yang_str">"smiv2"</span>;
      }
      <span class="yang_kw">import</span> <a href="/modules/yang-smi/2008-03-20">yang-smi</a> {
         <span class="yang_kw">prefix</span> <span class="yang_str">"smi"</span>;
      }
      <span class="yang_kw">import</span> <a href="/modules/yang-types/2008-05-22">yang-types</a> {
         <span class="yang_kw">prefix</span> <span class="yang_str">"yang"</span>;
      }

      <span class="yang_kw">organization</span> <span class="yang_str">"SNMPv3 Working Group"</span>;

      <span class="yang_kw">contact</span>
         <span class="yang_str">"WG-email:   snmpv3@lists.tislabs.com
         Subscribe:  majordomo@lists.tislabs.com
         	    In msg body:  subscribe snmpv3
         
         Chair:      Russ Mundy
         	    Network Associates Laboratories
         postal:     15204 Omega Drive, Suite 300
         	    Rockville, MD 20850-4601
         	    USA
         email:      mundy@tislabs.com
         
         phone:      +1 301-947-7107
         
         Co-Chair:   David Harrington
         	    Enterasys Networks
         Postal:     35 Industrial Way
         	    P. O. Box 5004
         	    Rochester, New Hampshire 03866-5005
         	    USA
         EMail:      dbh@enterasys.com
         Phone:      +1 603-337-2614
         
         Co-editor   Uri Blumenthal
         	    Lucent Technologies
         postal:     67 Whippany Rd.
         	    Whippany, NJ 07981
         	    USA
         email:      uri@lucent.com
         phone:      +1-973-386-2163
         
         Co-editor:  Bert Wijnen
         	    Lucent Technologies
         postal:     Schagen 33
         	    3461 GL Linschoten
         	    Netherlands
         email:      bwijnen@lucent.com
         phone:      +31-348-480-685"</span>;

      <span class="yang_kw">description</span>
         <span class="yang_str">"The management information definitions for the
         SNMP User-based Security Model.
         
         Copyright (C) The Internet Society (2002). This
         version of this MIB module is part of RFC 3414;
         see the RFC itself for full legal notices."</span>;

      <span class="yang_kw">revision</span> <span class="yang_str">"2002-10-16"</span> {
         <span class="yang_kw">description</span>
            <span class="yang_str">"Changes in this revision:
            - Updated references and contact info.
            - Clarification to usmUserCloneFrom DESCRIPTION
              clause
            - Fixed 'command responder' into 'command generator'
              in last para of DESCRIPTION clause of
              usmUserTable.
            This revision published as RFC3414."</span>;
      }

      <span class="yang_kw">revision</span> <span class="yang_str">"1999-01-20"</span> {
         <span class="yang_kw">description</span> <span class="yang_str">"Clarifications, published as RFC2574"</span>;
      }

      <span class="yang_kw">revision</span> <span class="yang_str">"1997-11-20"</span> {
         <span class="yang_kw">description</span> <span class="yang_str">"Initial version, published as RFC2274"</span>;
      }

      <a name="KeyChange.97"></a><span class="yang_kw">typedef</span> <span class="yang_id">KeyChange</span> {
         <span class="yang_kw">type</span> <span class="yang_id">binary</span>;
         <span class="yang_kw">description</span>
            <span class="yang_str">"Every definition of an object with this syntax must identify
            a protocol P, a secret key K, and a hash algorithm H
            that produces output of L octets.
            
            The object's value is a manager-generated, partially-random
            value which, when modified, causes the value of the secret
            key K, to be modified via a one-way function.
            
            The value of an instance of this object is the concatenation
            of two components: first a 'random' component and then a
            'delta' component.
            
            The lengths of the random and delta components
            are given by the corresponding value of the protocol P;
            if P requires K to be a fixed length, the length of both the
            random and delta components is that fixed length; if P
            allows the length of K to be variable up to a particular
            maximum length, the length of the random component is that
            maximum length and the length of the delta component is any
            length less than or equal to that maximum length.
            For example, usmHMACMD5AuthProtocol requires K to be a fixed
            length of 16 octets and L - of 16 octets.
            usmHMACSHAAuthProtocol requires K to be a fixed length of
            20 octets and L - of 20 octets. Other protocols may define
            other sizes, as deemed appropriate.
            
            When a requester wants to change the old key K to a new
            key keyNew on a remote entity, the 'random' component is
            obtained from either a true random generator, or from a
            pseudorandom generator, and the 'delta' component is
            computed as follows:
            
             - a temporary variable is initialized to the existing value
               of K;
             - if the length of the keyNew is greater than L octets,
               then:
                - the random component is appended to the value of the
                  temporary variable, and the result is input to the
                  the hash algorithm H to produce a digest value, and
                  the temporary variable is set to this digest value;
                - the value of the temporary variable is XOR-ed with
                  the first (next) L-octets (16 octets in case of MD5)
                  of the keyNew to produce the first (next) L-octets
                  (16 octets in case of MD5) of the 'delta' component.
                - the above two steps are repeated until the unused
                  portion of the keyNew component is L octets or less,
             - the random component is appended to the value of the
               temporary variable, and the result is input to the
               hash algorithm H to produce a digest value;
             - this digest value, truncated if necessary to be the same
               length as the unused portion of the keyNew, is XOR-ed
               with the unused portion of the keyNew to produce the
               (final portion of the) 'delta' component.
            
             For example, using MD5 as the hash algorithm H:
            
                iterations = (lenOfDelta - 1)/16; /* integer division */
                temp = keyOld;
                for (i = 0; i &lt; iterations; i++) {
            	temp = MD5 (temp || random);
            	delta[i*16 .. (i*16)+15] =
            	       temp XOR keyNew[i*16 .. (i*16)+15];
                }
                temp = MD5 (temp || random);
                delta[i*16 .. lenOfDelta-1] =
            	   temp XOR keyNew[i*16 .. lenOfDelta-1];
            
            The 'random' and 'delta' components are then concatenated as
            described above, and the resulting octet string is sent to
            the recipient as the new value of an instance of this object.
            
            At the receiver side, when an instance of this object is set
            to a new value, then a new value of K is computed as follows:
            
             - a temporary variable is initialized to the existing value
               of K;
             - if the length of the delta component is greater than L
               octets, then:
                - the random component is appended to the value of the
                  temporary variable, and the result is input to the
                  hash algorithm H to produce a digest value, and the
                  temporary variable is set to this digest value;
                - the value of the temporary variable is XOR-ed with
                  the first (next) L-octets (16 octets in case of MD5)
                  of the delta component to produce the first (next)
                  L-octets (16 octets in case of MD5) of the new value
                  of K.
                - the above two steps are repeated until the unused
                  portion of the delta component is L octets or less,
             - the random component is appended to the value of the
               temporary variable, and the result is input to the
               hash algorithm H to produce a digest value;
             - this digest value, truncated if necessary to be the same
               length as the unused portion of the delta component, is
               XOR-ed with the unused portion of the delta component to
               produce the (final portion of the) new value of K.
            
             For example, using MD5 as the hash algorithm H:
            
                iterations = (lenOfDelta - 1)/16; /* integer division */
                temp = keyOld;
                for (i = 0; i &lt; iterations; i++) {
            	temp = MD5 (temp || random);
            	keyNew[i*16 .. (i*16)+15] =
            	       temp XOR delta[i*16 .. (i*16)+15];
                }
                temp = MD5 (temp || random);
                keyNew[i*16 .. lenOfDelta-1] =
            	   temp XOR delta[i*16 .. lenOfDelta-1];
            
            The value of an object with this syntax, whenever it is
            retrieved by the management protocol, is always the zero
            length string.
            
            Note that the keyOld and keyNew are the localized keys.
            
            Note that it is probably wise that when an SNMP entity sends
            a SetRequest to change a key, that it keeps a copy of the old
            key until it has confirmed that the key change actually
            succeeded."</span>;
      }

      <a name="usmStats.222"></a><span class="yang_kw">container</span> <span class="yang_id">usmStats</span> {
         <a name="usmStatsUnsupportedSecLevels.224"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmStatsUnsupportedSecLevels</span> {
            <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/yang-types/2008-05-22#counter32.28">yang:counter32</a></span>;
            <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
            <span class="yang_kw">description</span>
               <span class="yang_str">"The total number of packets received by the SNMP
               engine which were dropped because they requested a
               securityLevel that was unknown to the SNMP engine
               or otherwise unavailable."</span>;
            <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.1.1"</span>;
         }

         <a name="usmStatsNotInTimeWindows.235"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmStatsNotInTimeWindows</span> {
            <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/yang-types/2008-05-22#counter32.28">yang:counter32</a></span>;
            <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
            <span class="yang_kw">description</span>
               <span class="yang_str">"The total number of packets received by the SNMP
               engine which were dropped because they appeared
               outside of the authoritative SNMP engine's window."</span>;
            <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.1.2"</span>;
         }

         <a name="usmStatsUnknownUserNames.245"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmStatsUnknownUserNames</span> {
            <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/yang-types/2008-05-22#counter32.28">yang:counter32</a></span>;
            <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
            <span class="yang_kw">description</span>
               <span class="yang_str">"The total number of packets received by the SNMP
               engine which were dropped because they referenced a
               user that was not known to the SNMP engine."</span>;
            <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.1.3"</span>;
         }

         <a name="usmStatsUnknownEngineIDs.255"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmStatsUnknownEngineIDs</span> {
            <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/yang-types/2008-05-22#counter32.28">yang:counter32</a></span>;
            <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
            <span class="yang_kw">description</span>
               <span class="yang_str">"The total number of packets received by the SNMP
               engine which were dropped because they referenced an
               snmpEngineID that was not known to the SNMP engine."</span>;
            <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.1.4"</span>;
         }

         <a name="usmStatsWrongDigests.265"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmStatsWrongDigests</span> {
            <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/yang-types/2008-05-22#counter32.28">yang:counter32</a></span>;
            <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
            <span class="yang_kw">description</span>
               <span class="yang_str">"The total number of packets received by the SNMP
               engine which were dropped because they didn't
               contain the expected digest value."</span>;
            <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.1.5"</span>;
         }

         <a name="usmStatsDecryptionErrors.275"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmStatsDecryptionErrors</span> {
            <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/yang-types/2008-05-22#counter32.28">yang:counter32</a></span>;
            <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
            <span class="yang_kw">description</span>
               <span class="yang_str">"The total number of packets received by the SNMP
               engine which were dropped because they could not be
               decrypted."</span>;
            <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.1.6"</span>;
         }
         <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.1"</span>;
      }  <span class="yang_cmt">// container usmStats</span>

      <a name="usmUser.287"></a><span class="yang_kw">container</span> <span class="yang_id">usmUser</span> {
         <a name="usmUserSpinLock.289"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserSpinLock</span> {
            <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMPv2-TC/1999-04-01#TestAndIncr.109">smiv2:TestAndIncr</a></span>;
            <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
            <span class="yang_kw">description</span>
               <span class="yang_str">"An advisory lock used to allow several cooperating
               Command Generator Applications to coordinate their
               use of facilities to alter secrets in the
               usmUserTable."</span>;
            <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.1"</span>;
         }

         <a name="usmUserEntry.303"></a><span class="yang_kw">list</span> <span class="yang_id">usmUserEntry</span> {
            <span class="yang_kw">key</span> "<a href="#usmUserEngineID.313">usmUserEngineID</a> <a href="#usmUserName.328">usmUserName</a>";
            <span class="yang_kw">ordered-by</span> <span class="yang_str">"system"</span>;
            <span class="yang_kw">description</span>
               <span class="yang_str">"A user configured in the SNMP engine's Local
               Configuration Datastore (LCD) for the User-based
               Security Model."</span>;
            <a name="usmUserEngineID.313"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserEngineID</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMP-FRAMEWORK-MIB/2002-10-14#SnmpEngineID.105">snmp-framework:SnmpEngineID</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"An SNMP engine's administratively-unique identifier.
                  
                  In a simple agent, this value is always that agent's
                  own snmpEngineID value.
                  
                  The value can also take the value of the snmpEngineID
                  of a remote SNMP engine with which this user can
                  communicate."</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.1"</span>;
            }

            <a name="usmUserName.328"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserName</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMP-FRAMEWORK-MIB/2002-10-14#SnmpAdminString.377">snmp-framework:SnmpAdminString</a></span> {
                  <span class="yang_kw">length</span> <span class="yang_str">"1..32"</span>;
               }
               <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"A human readable string representing the name of
                  the user.
                  
                  This is the (User-based Security) Model dependent
                  security ID."</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.2"</span>;
            }

            <a name="usmUserSecurityName.342"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserSecurityName</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMP-FRAMEWORK-MIB/2002-10-14#SnmpAdminString.377">snmp-framework:SnmpAdminString</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"false"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"A human readable string representing the user in
                  Security Model independent format.
                  
                  The default transformation of the User-based Security
                  Model dependent security ID to the securityName and
                  vice versa is the identity function so that the
                  securityName is the same as the userName."</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.3"</span>;
            }

            <a name="usmUserCloneFrom.356"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserCloneFrom</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMPv2-TC/1999-04-01#RowPointer.171">smiv2:RowPointer</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"A pointer to another conceptual row in this
                  usmUserTable.  The user in this other conceptual
                  row is called the clone-from user.
                  
                  When a new user is created (i.e., a new conceptual
                  row is instantiated in this table), the privacy and
                  authentication parameters of the new user must be
                  cloned from its clone-from user. These parameters are:
                    - authentication protocol (usmUserAuthProtocol)
                    - privacy protocol (usmUserPrivProtocol)
                  They will be copied regardless of what the current
                  value is.
                  
                  Cloning also causes the initial values of the secret
                  authentication key (authKey) and the secret encryption
                  
                  key (privKey) of the new user to be set to the same
                  values as the corresponding secrets of the clone-from
                  user to allow the KeyChange process to occur as
                  required during user creation.
                  
                  The first time an instance of this object is set by
                  a management operation (either at or after its
                  instantiation), the cloning process is invoked.
                  Subsequent writes are successful but invoke no
                  action to be taken by the receiver.
                  The cloning process fails with an 'inconsistentName'
                  error if the conceptual row representing the
                  clone-from user does not exist or is not in an active
                  state when the cloning process is invoked.
                  
                  When this object is read, the ZeroDotZero OID
                  is returned."</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.4"</span>;
            }

            <a name="usmUserAuthProtocol.396"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserAuthProtocol</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMPv2-TC/1999-04-01#AutonomousType.141">smiv2:AutonomousType</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"An indication of whether messages sent on behalf of
                  this user to/from the SNMP engine identified by
                  usmUserEngineID, can be authenticated, and if so,
                  the type of authentication protocol which is used.
                  
                  An instance of this object is created concurrently
                  with the creation of any other object instance for
                  the same user (i.e., as part of the processing of
                  the set operation which creates the first object
                  instance in the same conceptual row).
                  
                  If an initial set operation (i.e. at row creation time)
                  tries to set a value for an unknown or unsupported
                  protocol, then a 'wrongValue' error must be returned.
                  
                  The value will be overwritten/set when a set operation
                  is performed on the corresponding instance of
                  usmUserCloneFrom.
                  
                  Once instantiated, the value of such an instance of
                  this object can only be changed via a set operation to
                  the value of the usmNoAuthProtocol.
                  
                  If a set operation tries to change the value of an
                  
                  existing instance of this object to any value other
                  than usmNoAuthProtocol, then an 'inconsistentValue'
                  error must be returned.
                  
                  If a set operation tries to set the value to the
                  usmNoAuthProtocol while the usmUserPrivProtocol value
                  in the same row is not equal to usmNoPrivProtocol,
                  then an 'inconsistentValue' error must be returned.
                  That means that an SNMP command generator application
                  must first ensure that the usmUserPrivProtocol is set
                  to the usmNoPrivProtocol value before it can set
                  the usmUserAuthProtocol value to usmNoAuthProtocol."</span>;
               <a href="/modules/yang-smi/2008-03-20#default.33">smi:default</a> <span class="yang_str">"usmNoAuthProtocol"</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.5"</span>;
            }

            <a name="usmUserAuthKeyChange.441"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserAuthKeyChange</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="#KeyChange.97">KeyChange</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"An object, which when modified, causes the secret
                  authentication key used for messages sent on behalf
                  of this user to/from the SNMP engine identified by
                  usmUserEngineID, to be modified via a one-way
                  function.
                  
                  The associated protocol is the usmUserAuthProtocol.
                  The associated secret key is the user's secret
                  authentication key (authKey). The associated hash
                  algorithm is the algorithm used by the user's
                  usmUserAuthProtocol.
                  
                  When creating a new user, it is an 'inconsistentName'
                  error for a set operation to refer to this object
                  unless it is previously or concurrently initialized
                  through a set operation on the corresponding instance
                  of usmUserCloneFrom.
                  
                  When the value of the corresponding usmUserAuthProtocol
                  is usmNoAuthProtocol, then a set is successful, but
                  effectively is a no-op.
                  
                  When this object is read, the zero-length (empty)
                  string is returned.
                  
                  The recommended way to do a key change is as follows:
                  
                    1) GET(usmUserSpinLock.0) and save in sValue.
                    2) generate the keyChange value based on the old
                       (existing) secret key and the new secret key,
                       let us call this kcValue.
                  
                  If you do the key change on behalf of another user:
                  
                    3) SET(usmUserSpinLock.0=sValue,
                  	 usmUserAuthKeyChange=kcValue
                  	 usmUserPublic=randomValue)
                  
                  If you do the key change for yourself:
                  
                    4) SET(usmUserSpinLock.0=sValue,
                  	 usmUserOwnAuthKeyChange=kcValue
                  	 usmUserPublic=randomValue)
                  
                  If you get a response with error-status of noError,
                  then the SET succeeded and the new key is active.
                  If you do not get a response, then you can issue a
                  GET(usmUserPublic) and check if the value is equal
                  to the randomValue you did send in the SET. If so, then
                  the key change succeeded and the new key is active
                  (probably the response got lost). If not, then the SET
                  request probably never reached the target and so you
                  can start over with the procedure above."</span>;
               <a href="/modules/yang-smi/2008-03-20#default.33">smi:default</a> <span class="yang_str">""</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.6"</span>;
            }

            <a name="usmUserOwnAuthKeyChange.502"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserOwnAuthKeyChange</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="#KeyChange.97">KeyChange</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"Behaves exactly as usmUserAuthKeyChange, with one
                  notable difference: in order for the set operation
                  to succeed, the usmUserName of the operation
                  requester must match the usmUserName that
                  indexes the row which is targeted by this
                  operation.
                  In addition, the USM security model must be
                  used for this operation.
                  
                  The idea here is that access to this column can be
                  public, since it will only allow a user to change
                  his own secret authentication key (authKey).
                  Note that this can only be done once the row is active.
                  
                  When a set is received and the usmUserName of the
                  requester is not the same as the umsUserName that
                  indexes the row which is targeted by this operation,
                  then a 'noAccess' error must be returned.
                  
                  When a set is received and the security model in use
                  is not USM, then a 'noAccess' error must be returned."</span>;
               <a href="/modules/yang-smi/2008-03-20#default.33">smi:default</a> <span class="yang_str">""</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.7"</span>;
            }

            <a name="usmUserPrivProtocol.531"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserPrivProtocol</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMPv2-TC/1999-04-01#AutonomousType.141">smiv2:AutonomousType</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"An indication of whether messages sent on behalf of
                  this user to/from the SNMP engine identified by
                  usmUserEngineID, can be protected from disclosure,
                  and if so, the type of privacy protocol which is used.
                  
                  An instance of this object is created concurrently
                  with the creation of any other object instance for
                  the same user (i.e., as part of the processing of
                  the set operation which creates the first object
                  instance in the same conceptual row).
                  
                  If an initial set operation (i.e. at row creation time)
                  tries to set a value for an unknown or unsupported
                  protocol, then a 'wrongValue' error must be returned.
                  
                  The value will be overwritten/set when a set operation
                  is performed on the corresponding instance of
                  usmUserCloneFrom.
                  
                  Once instantiated, the value of such an instance of
                  this object can only be changed via a set operation to
                  the value of the usmNoPrivProtocol.
                  
                  If a set operation tries to change the value of an
                  existing instance of this object to any value other
                  than usmNoPrivProtocol, then an 'inconsistentValue'
                  error must be returned.
                  
                  Note that if any privacy protocol is used, then you
                  must also use an authentication protocol. In other
                  words, if usmUserPrivProtocol is set to anything else
                  than usmNoPrivProtocol, then the corresponding instance
                  of usmUserAuthProtocol cannot have a value of
                  
                  usmNoAuthProtocol. If it does, then an
                  'inconsistentValue' error must be returned."</span>;
               <a href="/modules/yang-smi/2008-03-20#default.33">smi:default</a> <span class="yang_str">"usmNoPrivProtocol"</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.8"</span>;
            }

            <a name="usmUserPrivKeyChange.575"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserPrivKeyChange</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="#KeyChange.97">KeyChange</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"An object, which when modified, causes the secret
                  encryption key used for messages sent on behalf
                  of this user to/from the SNMP engine identified by
                  usmUserEngineID, to be modified via a one-way
                  function.
                  
                  The associated protocol is the usmUserPrivProtocol.
                  The associated secret key is the user's secret
                  privacy key (privKey). The associated hash
                  algorithm is the algorithm used by the user's
                  usmUserAuthProtocol.
                  
                  When creating a new user, it is an 'inconsistentName'
                  error for a set operation to refer to this object
                  unless it is previously or concurrently initialized
                  through a set operation on the corresponding instance
                  of usmUserCloneFrom.
                  
                  When the value of the corresponding usmUserPrivProtocol
                  is usmNoPrivProtocol, then a set is successful, but
                  effectively is a no-op.
                  
                  When this object is read, the zero-length (empty)
                  string is returned.
                  See the description clause of usmUserAuthKeyChange for
                  a recommended procedure to do a key change."</span>;
               <a href="/modules/yang-smi/2008-03-20#default.33">smi:default</a> <span class="yang_str">""</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.9"</span>;
            }

            <a name="usmUserOwnPrivKeyChange.609"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserOwnPrivKeyChange</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="#KeyChange.97">KeyChange</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"Behaves exactly as usmUserPrivKeyChange, with one
                  notable difference: in order for the Set operation
                  to succeed, the usmUserName of the operation
                  requester must match the usmUserName that indexes
                  
                  the row which is targeted by this operation.
                  In addition, the USM security model must be
                  used for this operation.
                  
                  The idea here is that access to this column can be
                  public, since it will only allow a user to change
                  his own secret privacy key (privKey).
                  Note that this can only be done once the row is active.
                  
                  When a set is received and the usmUserName of the
                  requester is not the same as the umsUserName that
                  indexes the row which is targeted by this operation,
                  then a 'noAccess' error must be returned.
                  
                  When a set is received and the security model in use
                  is not USM, then a 'noAccess' error must be returned."</span>;
               <a href="/modules/yang-smi/2008-03-20#default.33">smi:default</a> <span class="yang_str">""</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.10"</span>;
            }

            <a name="usmUserPublic.638"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserPublic</span> {
               <span class="yang_kw">type</span> <span class="yang_id">binary</span> {
                  <span class="yang_kw">length</span> <span class="yang_str">"0..32"</span>;
               }
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"A publicly-readable value which can be written as part
                  of the procedure for changing a user's secret
                  authentication and/or privacy key, and later read to
                  determine whether the change of the secret was
                  effected."</span>;
               <a href="/modules/yang-smi/2008-03-20#default.33">smi:default</a> <span class="yang_str">""</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.11"</span>;
            }

            <a name="usmUserStorageType.653"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserStorageType</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMPv2-TC/1999-04-01#StorageType.719">smiv2:StorageType</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"The storage type for this conceptual row.
                  
                  Conceptual rows having the value 'permanent' must
                  allow write-access at a minimum to:
                  
                  - usmUserAuthKeyChange, usmUserOwnAuthKeyChange
                    and usmUserPublic for a user who employs
                    authentication, and
                  - usmUserPrivKeyChange, usmUserOwnPrivKeyChange
                    and usmUserPublic for a user who employs
                    privacy.
                  
                  Note that any user who employs authentication or
                  privacy must allow its secret(s) to be updated and
                  thus cannot be 'readOnly'.
                  
                  If an initial set operation tries to set the value to
                  'readOnly' for a user who employs authentication or
                  privacy, then an 'inconsistentValue' error must be
                  returned.  Note that if the value has been previously
                  set (implicit or explicit) to any value, then the rules
                  as defined in the StorageType Textual Convention apply.
                  
                  It is an implementation issue to decide if a SET for
                  a readOnly or permanent row is accepted at all. In some
                  contexts this may make sense, in others it may not. If
                  a SET for a readOnly or permanent row is not accepted
                  at all, then a 'wrongValue' error must be returned."</span>;
               <a href="/modules/yang-smi/2008-03-20#default.33">smi:default</a> <span class="yang_str">"nonVolatile"</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.12"</span>;
            }

            <a name="usmUserStatus.689"></a><span class="yang_kw">leaf</span> <span class="yang_id">usmUserStatus</span> {
               <span class="yang_kw">type</span> <span class="yang_id"><a href="/modules/SNMPv2-TC/1999-04-01#RowStatus.183">smiv2:RowStatus</a></span>;
               <span class="yang_kw">config</span> <span class="yang_str">"true"</span>;
               <span class="yang_kw">description</span>
                  <span class="yang_str">"The status of this conceptual row.
                  
                  Until instances of all corresponding columns are
                  appropriately configured, the value of the
                  corresponding instance of the usmUserStatus column
                  is 'notReady'.
                  
                  In particular, a newly created row for a user who
                  employs authentication, cannot be made active until the
                  corresponding usmUserCloneFrom and usmUserAuthKeyChange
                  have been set.
                  
                  Further, a newly created row for a user who also
                  employs privacy, cannot be made active until the
                  usmUserPrivKeyChange has been set.
                  
                  The RowStatus TC [RFC2579] requires that this
                  DESCRIPTION clause states under which circumstances
                  other objects in this row can be modified:
                  
                  The value of this object has no effect on whether
                  other objects in this conceptual row can be modified,
                  except for usmUserOwnAuthKeyChange and
                  usmUserOwnPrivKeyChange. For these 2 objects, the
                  
                  value of usmUserStatus MUST be active."</span>;
               <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1.13"</span>;
            }
            <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2.2.1"</span>;
         }  <span class="yang_cmt">// list usmUserEntry</span>
         <a href="/modules/yang-smi/2008-03-20#oid.21">smi:oid</a> <span class="yang_str">"1.3.6.1.6.3.15.1.2"</span>;
      }  <span class="yang_cmt">// container usmUser</span>
   }  <span class="yang_cmt">// module SNMP-USER-BASED-SM-MIB</span>
</pre>
</div>
</div>